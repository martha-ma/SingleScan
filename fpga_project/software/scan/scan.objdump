
scan.elf:     file format elf32-littlenios2
scan.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00040244

Program Header:
    LOAD off    0x00001020 vaddr 0x00040020 paddr 0x00040020 align 2**12
         filesz 0x0001d12c memsz 0x00024324 flags rwx
    LOAD off    0x0001f000 vaddr 0x00081000 paddr 0x00081000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00081000  00081000  0001f000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  00040020  00040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000d12c  00040244  00040244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000c240  0004d370  0004d370  0000e370  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00003b9c  000595b0  000595b0  0001a5b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000071f8  0005d14c  0005d14c  0001e14c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  00064344  00064344  0001f020  2**0
                  CONTENTS
  7 .epcs_flash   00000000  00081020  00081020  0001f020  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0001f020  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000008d8  00000000  00000000  0001f048  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000f372  00000000  00000000  0001f920  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00004757  00000000  00000000  0002ec92  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000051fe  00000000  00000000  000333e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002480  00000000  00000000  000385e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003967  00000000  00000000  0003aa68  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00000f46  00000000  00000000  0003e3cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000020  00000000  00000000  0003f318  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000208  00000000  00000000  0003f338  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  00042bee  2**0
                  CONTENTS, READONLY
 19 .cpu          00000005  00000000  00000000  00042bf1  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00042bf6  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00042bf7  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00042bf8  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00042bfc  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00042c00  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000009  00000000  00000000  00042c04  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000009  00000000  00000000  00042c0d  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000009  00000000  00000000  00042c16  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000006  00000000  00000000  00042c1f  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000001f  00000000  00000000  00042c25  2**0
                  CONTENTS, READONLY
 30 .jdi          0000603c  00000000  00000000  00042c44  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000a4c87  00000000  00000000  00048c80  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00081000 l    d  .entry	00000000 .entry
00040020 l    d  .exceptions	00000000 .exceptions
00040244 l    d  .text	00000000 .text
0004d370 l    d  .rodata	00000000 .rodata
000595b0 l    d  .rwdata	00000000 .rwdata
0005d14c l    d  .bss	00000000 .bss
00064344 l    d  .onchip_memory	00000000 .onchip_memory
00081020 l    d  .epcs_flash	00000000 .epcs_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../scan_bsp//obj/HAL/src/crt0.o
0004027c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 bsp.c
00000000 l    df *ABS*	00000000 device.c
00000000 l    df *ABS*	00000000 fpga2nios_protocol.c
00040e9c l     F .text	00000134 hex2ascii
00000000 l    df *ABS*	00000000 iic.c
00041ac0 l     F .text	00000078 start
00041b38 l     F .text	00000090 stop
00041bc8 l     F .text	000000a8 wait_slave_ack
00041c70 l     F .text	00000098 master_send_ack
00041d08 l     F .text	00000098 no_ack
00041e64 l     F .text	000000c4 iic_read
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 nios2fpga_protocol.c
00042d6c l     F .text	00000078 check_sum
00000000 l    df *ABS*	00000000 pc2dev.c
00000000 l    df *ABS*	00000000 queue.c
00000000 l    df *ABS*	00000000 region.c
00000000 l    df *ABS*	00000000 remote_update.c
00000000 l    df *ABS*	00000000 sick_protocol.c
00045f9c l     F .text	000000a8 string2hex
00046044 l     F .text	000000c8 find_index
00000000 l    df *ABS*	00000000 socket.c
0005d15e l     O .bss	00000002 local_port
00000000 l    df *ABS*	00000000 tim561.c
00000000 l    df *ABS*	00000000 user_interrupt.c
00000000 l    df *ABS*	00000000 w5500.c
0005d1ec l     O .bss	00000010 SSIZE
0005d1fc l     O .bss	00000010 RSIZE
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00049be4 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00049d4c l     F .text	00000034 alt_dev_reg
0005ba08 l     O .rwdata	000000cc epcs_flash
0005bad4 l     O .rwdata	00001060 jtag_uart
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
00049e38 l     F .text	00000034 alt_flash_device_register
00049ec0 l     F .text	00000488 alt_epcs_flash_query
0004a348 l     F .text	000000ec alt_epcs_flash_memcmp
0004a720 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_fifo_util.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0004b0ec l     F .text	0000020c altera_avalon_jtag_uart_irq
0004b2f8 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0004b930 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 epcs_commands.c
0004ba80 l     F .text	00000038 epcs_test_wip
0004bab8 l     F .text	0000003c epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0004c18c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0004c2b8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0004c2e4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0004c5e4 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0004c724 l     F .text	0000003c alt_get_errno
0004c760 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
0005ccdc l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0005d174 g     O .bss	00000004 alt_instruction_exception_handler
0004a694 g     F .text	0000008c alt_epcs_flash_get_info
00059eac g     O .rwdata	000004bd udp_reponse
00049cd0 g     F .text	0000007c alt_main
00060084 g     O .bss	00001fbc CycleData
00064244 g     O .bss	00000100 alt_irq
0004ac4c g     F .text	0000005c altera_avalon_fifo_write_almostfull
000595b0 g       *ABS*	00000000 __flash_rwdata_start
000410b8 g     F .text	00000708 fpga2nios_parse
000434f4 g     F .text	00000164 write_laser_presdo
00040ca0 g     F .text	000001fc set_default
00046c6c g     F .text	00000080 close_socket
000596f4 g     O .rwdata	00000014 nios2pc
00047254 g     F .text	000000a0 recv
00046d84 g     F .text	000002b0 connect
00048ba4 g     F .text	0000005c setRTR
00048afc g     F .text	0000003c getSIPR
00045e74 g     F .text	00000098 image_read
0005d14c g     O .bss	00000001 isTcpEstablished
00047aa4 g     F .text	0000007c timer_initial
0004a9c4 g     F .text	00000098 altera_avalon_fifo_init
0005d15c g     O .bss	00000001 sMI_3E_flag
0004810c g     F .text	00000078 SPI_I2S_ReceiveData
00045f0c g     F .text	00000090 image_erase
0004ad04 g     F .text	00000058 altera_avalon_fifo_write_fifo
00042de4 g     F .text	00000020 motor_init
00081000 g       *ABS*	00000000 __alt_mem_epcs_flash
00049098 g     F .text	00000130 recv_data_processing
00048910 g     F .text	0000003c getGWIP
0004cb80 g     F .text	00000024 altera_nios2_gen2_irq_init
0004baf4 g     F .text	000000fc epcs_sector_erase
00081000 g     F .entry	0000001c __reset
0004aea0 g     F .text	00000028 altera_avalon_fifo_read_backpressure
00043010 g     F .text	000004c4 init_fpga_sys
0005a36c g     O .rwdata	000008f0 tim561_index
00040020 g       *ABS*	00000000 __flash_exceptions_start
0005b574 g     O .rwdata	00000010 sMI_0_3_F4724744_stop
0005d180 g     O .bss	00000004 errno
000423f4 g     F .text	00000038 led_status_light
00040c14 g     F .text	0000008c set_network
00045d7c g     F .text	000000f8 image_write
0005ac5c g     O .rwdata	000008f0 tim561_respons
0005d16c g     O .bss	00000004 alt_argv
00065100 g       *ABS*	00000000 _gp
0004ab90 g     F .text	00000060 altera_avalon_fifo_clear_event
0005cb5c g     O .rwdata	00000180 alt_fd_list
00048a00 g     F .text	00000048 setkeepalive
00042fa0 g     F .text	00000070 set_laser_paramter
0004bd38 g     F .text	0000006c epcs_write_status_register
00048988 g     F .text	0000003c setSHAR
0004c484 g     F .text	00000090 alt_find_dev
000493d4 g     F .text	00000148 memcpy
0004c6a8 g     F .text	0000007c alt_io_redirect
0004d370 g       *ABS*	00000000 __DTOR_END__
00048184 g     F .text	0000008c IINCHIP_WRITE
00048b78 g     F .text	0000002c getIR
0004c548 g     F .text	0000009c alt_exception_cause_generated_bad_addr
0004a82c g     F .text	00000100 alt_epcs_flash_write_block
00048c00 g     F .text	00000040 setRCR
0004b4f0 g     F .text	0000021c altera_avalon_jtag_uart_read
000595b0 g     O .rwdata	00000134 SysPara
00049318 g     F .text	00000064 .hidden __udivsi3
00064140 g     O .bss	00000104 image
0004cf4c g     F .text	00000090 alt_icache_flush
00047590 g     F .text	0000048c recvfrom
0005b54c g     O .rwdata	00000028 sMI_2
0005b598 g     O .rwdata	0000038d sRI_15B_reply
00046aa4 g     F .text	000001c8 socket
0005d134 g     O .rwdata	00000004 alt_max_fd
00048008 g     F .text	00000030 IINCHIP_CSon
000468d4 g     F .text	000001d0 sick_pos_packet
00042e04 g     F .text	00000114 nios2fpga_data_packet
0004a7b4 g     F .text	00000078 alt_epcs_flash_erase_block
0005d158 g     O .bss	00000004 Nios2FPGA_pck
0005da0c g     O .bss	00000021 ConfigMsg
0005d144 g     O .rwdata	00000004 _global_impure_ptr
0004c004 g     F .text	0000005c epcs_exit_4_bytes_mode
00064344 g       *ABS*	00000000 __bss_end
00049af4 g     F .text	000000f0 alt_iic_isr_register
0004ca78 g     F .text	00000108 alt_tick
0004709c g     F .text	000001b8 send
0005b928 g     O .rwdata	000000b3 sRI_1DC_reply
00041074 g     F .text	00000044 read_fpga_data
00048c40 g     F .text	0000005c clearIR
00049aa8 g     F .text	0000004c alt_ic_irq_enabled
00048a84 g     F .text	0000003c getSUBR
0004c9dc g     F .text	0000009c alt_alarm_stop
00041f28 g     F .text	000000ac eeprom_write_byte
0005d164 g     O .bss	00000004 alt_irq_active
000400fc g     F .exceptions	000000d4 alt_irq_handler
0005cb34 g     O .rwdata	00000028 alt_dev_null
0005e004 g     O .bss	00000014 LaserDataQueue
00048e84 g     F .text	000000e4 getSn_RX_RSR
00041884 g     F .text	0000008c process_ld_waring
000457c4 g     F .text	00000078 queue_count
0004c298 g     F .text	00000020 alt_dcache_flush_all
0005d160 g     O .bss	00000004 timer_isr_context
00048ac0 g     F .text	0000003c getSHAR
00043658 g     F .text	00000114 pc_data_to_fpga
0005b584 g     O .rwdata	00000014 sRI_E6_reply
0004abf0 g     F .text	0000005c altera_avalon_fifo_write_ienable
0005d14c g       *ABS*	00000000 __ram_rwdata_end
00060074 g     O .bss	0000000d led_time_flag
00040000 g       *ABS*	00000000 __alt_mem_onchip_memory
0004ab00 g     F .text	0000002c altera_avalon_fifo_read_almostempty
0005d12c g     O .rwdata	00000008 alt_dev_list
000595b0 g       *ABS*	00000000 __ram_rodata_end
0005da2d g     O .bss	00000021 RecvMsg
000423bc g     F .text	00000038 led_power_light
0004937c g     F .text	00000058 .hidden __umodsi3
0004bec0 g     F .text	00000068 epcs_read_electronic_signature
00040bd0 g     F .text	00000044 reboot
00064344 g       *ABS*	00000000 end
00047034 g     F .text	00000068 disconnect
0004242c g     F .text	00000088 init_avalon_fifo
0004b02c g     F .text	000000c0 altera_avalon_jtag_uart_init
0004376c g     F .text	00001718 pc2dev_parse
000401d0 g     F .exceptions	00000074 alt_instruction_exception_entry
0004ab2c g     F .text	0000003c altera_avalon_fifo_read_event
0004d370 g       *ABS*	00000000 __CTOR_LIST__
0006d000 g       *ABS*	00000000 __alt_stack_pointer
0004b9a8 g     F .text	0000007c alt_avalon_timer_sc_init
00048378 g     F .text	00000174 wiz_read_buf
0004b70c g     F .text	00000224 altera_avalon_jtag_uart_write
000419c4 g     F .text	000000fc process_sys_temp_waring
0004adc8 g     F .text	0000004c altera_avalon_fifo_read_fifo
00059708 g     O .rwdata	000006f8 alarm_region
0004d1bc g     F .text	00000180 __call_exitprocs
00040a8c g     F .text	000000ec test
0004102c g     F .text	00000048 fpga_is_has_data
00040244 g     F .text	0000003c _start
0005d178 g     O .bss	00000004 _alt_tick_rate
0004cba4 g     F .text	000001fc alt_avalon_spi_command
0005d17c g     O .bss	00000004 _alt_nticks
0005e018 g     O .bss	0000005c fpga2nios_data
00049db8 g     F .text	00000080 alt_sys_init
000458a4 g     F .text	00000040 queue_is_empty
00045748 g     F .text	0000007c queue_pop
0004d0a4 g     F .text	00000118 __register_exitproc
000421d4 g     F .text	000000d0 eeprom_read_byte
0005d20c g     O .bss	00000800 buffer
00045ba8 g     F .text	00000194 read_sys_para
000497b8 g     F .text	000000d0 strncmp
00040b78 g     F .text	00000058 Reset_W5500
000489c4 g     F .text	0000003c setSIPR
00045d3c g     F .text	00000040 rd_switch_io_value
0005d110 g     O .rwdata	00000008 sMI_0_3_F4724744_start
0004610c g     F .text	000007c8 sick_protocol_process
0004b398 g     F .text	00000068 altera_avalon_jtag_uart_close
0005d184 g     O .bss	00000068 sys_warn
000595b0 g       *ABS*	00000000 __ram_rwdata_start
0004d370 g       *ABS*	00000000 __ram_rodata_start
000472f4 g     F .text	0000029c sendto
0004ba24 g     F .text	0000005c epcs_read_status_register
00040334 g     F .text	00000758 tim561_run
000434d4 g     F .text	00000020 close_peripheral_dev
0004aec8 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0004cea8 g     F .text	000000a4 alt_get_fd
00062040 g     O .bss	00002100 send_buffer
00047fa8 g     F .text	00000030 watchdog_feed
0004bf28 g     F .text	00000080 epcs_read_device_id
0004d028 g     F .text	0000007c memcmp
00046cec g     F .text	00000098 listen
0004af88 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00064344 g       *ABS*	00000000 __alt_stack_base
0004afd8 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0004aa5c g     F .text	0000003c altera_avalon_fifo_read_status
000402c8 g     F .text	0000006c delay_us
0004ae74 g     F .text	0000002c altera_avalon_fifo_read_other_info
0004cda0 g     F .text	00000108 alt_find_file
0004c320 g     F .text	000000a4 alt_dev_llist_insert
00048a48 g     F .text	0000003c getGAR
000422a4 g     F .text	00000118 eeprom_sequential_read
0004851c g     F .text	000003b8 sysinit
0005d118 g     O .rwdata	00000008 alt_flash_dev_list
0005d100 g     O .rwdata	00000008 txsize
000458e4 g     F .text	000000a0 region_save2eeprom
0005d14c g       *ABS*	00000000 __bss_start
00048210 g     F .text	000000a4 IINCHIP_READ
0004951c g     F .text	00000128 memset
00045ad4 g     F .text	00000078 region_read_from_rom
000424b4 g     F .text	000008b8 main
00040280 g     F .text	00000048 delay_ms
00045b4c g     F .text	0000005c save_sys_para
0005d170 g     O .bss	00000004 alt_envp
000596e4 g     O .rwdata	00000010 pc2nios
00048d20 g     F .text	00000040 getSn_IR
0004af28 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0004ab68 g     F .text	00000028 altera_avalon_fifo_read_level
0005d108 g     O .rwdata	00000008 rxsize
000456c8 g     F .text	00000080 queue_push
00059e9c g     O .rwdata	0000000d RSSI_Field_end
0005d138 g     O .rwdata	00000004 alt_errno
00059e00 g     O .rwdata	0000006d frame_start
00041fd4 g     F .text	00000200 eeprom_write_page
00049220 g     F .text	00000084 .hidden __divsi3
0004d370 g       *ABS*	00000000 __CTOR_END__
00048f68 g     F .text	00000130 send_data_processing
00047b20 g     F .text	00000458 timer_isr_interrupt
0004a434 g     F .text	00000260 alt_epcs_flash_write
00049644 g     F .text	000000dc strcmp
00048c9c g     F .text	00000084 setSn_MSS
0004d370 g       *ABS*	00000000 __flash_rodata_start
0005d150 g     O .bss	00000004 SysStatus
0004d370 g       *ABS*	00000000 __DTOR_LIST__
00048d60 g     F .text	00000040 getSn_SR
0005da4e g     O .bss	000005b4 pub_buf
00049d80 g     F .text	00000038 alt_irq_init
0004c978 g     F .text	00000064 alt_release_fd
0004568c g     F .text	0000003c queue_clear
0004cfdc g     F .text	00000014 atexit
00048da0 g     F .text	000000e4 getSn_TX_FSR
0004583c g     F .text	00000068 queue_is_full
0005d148 g     O .rwdata	00000004 _impure_ptr
0005d168 g     O .bss	00000004 alt_argc
0004c424 g     F .text	00000060 _do_dtors
00045984 g     F .text	00000150 region_save2fpga
00040020 g       .exceptions	00000000 alt_irq_entry
000480b0 g     F .text	0000005c IINCHIP_SpiSendData
0005d124 g     O .rwdata	00000008 alt_fs_list
000484ec g     F .text	00000030 iinchip_init
0005d154 g     O .bss	00000001 isPowerUp
00042f18 g     F .text	00000088 nios2fpga_data_write
00040020 g       *ABS*	00000000 __ram_exceptions_start
0004bbf0 g     F .text	000000f4 epcs_read_buffer
00049e6c g     F .text	00000054 alt_epcs_flash_init
0004ae14 g     F .text	00000060 altera_avalon_fifo_write_other_info
00049944 g     F .text	00000050 alt_ic_isr_register
00041da0 g     F .text	000000c4 iic_write
00048b38 g     F .text	00000040 setMR
0005d14c g       *ABS*	00000000 _edata
00064344 g       *ABS*	00000000 _end
00049888 g     F .text	00000068 alt_flash_open_dev
00040244 g       *ABS*	00000000 __ram_exceptions_end
0004b400 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
000491c8 g     F .text	00000058 setSn_IR
00049a1c g     F .text	0000008c alt_ic_irq_disable
0004bfa8 g     F .text	0000005c epcs_enter_4_bytes_mode
0004cff0 g     F .text	00000038 exit
000417c0 g     F .text	000000c4 process_motor_waring
000498f0 g     F .text	00000054 alt_flash_close_dev
000492a4 g     F .text	00000074 .hidden __modsi3
0004894c g     F .text	0000003c setSUBR
0004aa98 g     F .text	0000003c altera_avalon_fifo_read_ienable
0006d000 g       *ABS*	00000000 __alt_data_end
00040020 g     F .exceptions	00000000 alt_exception
0005b9dc g     O .rwdata	0000002c sMI_reply
0004d33c g     F .text	00000034 _exit
0004c060 g     F .text	0000012c alt_alarm_start
00041910 g     F .text	000000b4 process_window_dust_waring
00048074 g     F .text	0000003c getIINCHIP_TxMAX
0004aad4 g     F .text	0000002c altera_avalon_fifo_read_almostfull
00049720 g     F .text	00000098 strlen
0004bce4 g     F .text	00000054 epcs_write_enable
0004c824 g     F .text	00000154 open
0004ad5c g     F .text	0000006c altera_avalon_read_fifo
0005e074 g     O .bss	00002000 LaserData
00044e84 g     F .text	0000077c pc2dev_packet
0004c514 g     F .text	00000034 alt_icache_flush_all
0005d120 g     O .rwdata	00000004 alt_priority_mask
00047fd8 g     F .text	00000030 IINCHIP_CSoff
00047f78 g     F .text	00000030 watchdog_init
000482b4 g     F .text	000000c4 wiz_write_buf
00049994 g     F .text	00000088 alt_ic_irq_enable
00047a1c g     F .text	00000088 find_index_old
00048038 g     F .text	0000003c getIINCHIP_RxMAX
000488d4 g     F .text	0000003c setGAR
0004a92c g     F .text	00000098 alt_epcs_flash_read
0004aca8 g     F .text	0000005c altera_avalon_fifo_write_almostempty
0005d13c g     O .rwdata	00000008 alt_alarm_list
00040fd0 g     F .text	0000005c big_swap_little
0004c3c4 g     F .text	00000060 _do_ctors
00059e70 g     O .rwdata	0000002a RSSI_Field_start
0004c1c8 g     F .text	000000d0 close
00045600 g     F .text	0000008c queue_init
00049c4c g     F .text	00000084 alt_load
0004bda4 g     F .text	0000011c epcs_write_buffer



Disassembly of section .entry:

00081000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   81000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   81004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   81008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   8100c:	00bffd16 	blt	zero,r2,81004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   81010:	00400134 	movhi	at,4
    ori r1, r1, %lo(_start)
   81014:	08409114 	ori	at,at,580
    jmp r1
   81018:	0800683a 	jmp	at
   8101c:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>

Disassembly of section .exceptions:

00040020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   40020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   40024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   40028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   4002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   40030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   40034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   40038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   4003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   40040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   40044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   40048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   4004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   40050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   40054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   40058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   4005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   40060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   40064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   40068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   4006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   40070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   40074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   40078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   4007c:	10000326 	beq	r2,zero,4008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   40080:	20000226 	beq	r4,zero,4008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   40084:	00400fc0 	call	400fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   40088:	00000706 	br	400a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   4008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   40090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
   40094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
   40098:	00401d00 	call	401d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
   4009c:	1000021e 	bne	r2,zero,400a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
   400a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   400a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   400a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   400ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   400b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   400b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   400b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   400bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   400c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   400c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   400c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   400cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   400d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   400d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   400d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   400dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   400e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   400e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   400e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   400ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   400f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   400f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   400f8:	ef80083a 	eret

000400fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   400fc:	defff904 	addi	sp,sp,-28
   40100:	dfc00615 	stw	ra,24(sp)
   40104:	df000515 	stw	fp,20(sp)
   40108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   4010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   40110:	0005313a 	rdctl	r2,ipending
   40114:	e0bffe15 	stw	r2,-8(fp)

  return active;
   40118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   4011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   40120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   40124:	00800044 	movi	r2,1
   40128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   4012c:	e0fffb17 	ldw	r3,-20(fp)
   40130:	e0bffc17 	ldw	r2,-16(fp)
   40134:	1884703a 	and	r2,r3,r2
   40138:	10001426 	beq	r2,zero,4018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   4013c:	008001b4 	movhi	r2,6
   40140:	10909104 	addi	r2,r2,16964
   40144:	e0fffd17 	ldw	r3,-12(fp)
   40148:	180690fa 	slli	r3,r3,3
   4014c:	10c5883a 	add	r2,r2,r3
   40150:	10c00017 	ldw	r3,0(r2)
   40154:	008001b4 	movhi	r2,6
   40158:	10909104 	addi	r2,r2,16964
   4015c:	e13ffd17 	ldw	r4,-12(fp)
   40160:	200890fa 	slli	r4,r4,3
   40164:	1105883a 	add	r2,r2,r4
   40168:	10800104 	addi	r2,r2,4
   4016c:	10800017 	ldw	r2,0(r2)
   40170:	1009883a 	mov	r4,r2
   40174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
   40178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   4017c:	0005313a 	rdctl	r2,ipending
   40180:	e0bfff15 	stw	r2,-4(fp)

  return active;
   40184:	e0bfff17 	ldw	r2,-4(fp)
   40188:	00000706 	br	401a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
   4018c:	e0bffc17 	ldw	r2,-16(fp)
   40190:	1085883a 	add	r2,r2,r2
   40194:	e0bffc15 	stw	r2,-16(fp)
      i++;
   40198:	e0bffd17 	ldw	r2,-12(fp)
   4019c:	10800044 	addi	r2,r2,1
   401a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   401a4:	003fe106 	br	4012c <__alt_mem_epcs_flash+0xfffbf12c>

    active = alt_irq_pending ();
   401a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   401ac:	e0bffb17 	ldw	r2,-20(fp)
   401b0:	103fdb1e 	bne	r2,zero,40120 <__alt_mem_epcs_flash+0xfffbf120>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   401b4:	0001883a 	nop
}
   401b8:	0001883a 	nop
   401bc:	e037883a 	mov	sp,fp
   401c0:	dfc00117 	ldw	ra,4(sp)
   401c4:	df000017 	ldw	fp,0(sp)
   401c8:	dec00204 	addi	sp,sp,8
   401cc:	f800283a 	ret

000401d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
   401d0:	defffb04 	addi	sp,sp,-20
   401d4:	dfc00415 	stw	ra,16(sp)
   401d8:	df000315 	stw	fp,12(sp)
   401dc:	df000304 	addi	fp,sp,12
   401e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
   401e4:	000531fa 	rdctl	r2,exception
   401e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
   401ec:	e0bffd17 	ldw	r2,-12(fp)
   401f0:	10801f0c 	andi	r2,r2,124
   401f4:	1004d0ba 	srli	r2,r2,2
   401f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
   401fc:	0005333a 	rdctl	r2,badaddr
   40200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   40204:	d0a01d17 	ldw	r2,-32652(gp)
   40208:	10000726 	beq	r2,zero,40228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   4020c:	d0a01d17 	ldw	r2,-32652(gp)
   40210:	e0fffd17 	ldw	r3,-12(fp)
   40214:	e1bffe17 	ldw	r6,-8(fp)
   40218:	e17fff17 	ldw	r5,-4(fp)
   4021c:	1809883a 	mov	r4,r3
   40220:	103ee83a 	callr	r2
   40224:	00000206 	br	40230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   40228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
   4022c:	0005883a 	mov	r2,zero
}
   40230:	e037883a 	mov	sp,fp
   40234:	dfc00117 	ldw	ra,4(sp)
   40238:	df000017 	ldw	fp,0(sp)
   4023c:	dec00204 	addi	sp,sp,8
   40240:	f800283a 	ret

Disassembly of section .text:

00040244 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   40244:	06c001b4 	movhi	sp,6
    ori sp, sp, %lo(__alt_stack_pointer)
   40248:	def40014 	ori	sp,sp,53248
    movhi gp, %hi(_gp)
   4024c:	068001b4 	movhi	gp,6
    ori gp, gp, %lo(_gp)
   40250:	d6944014 	ori	gp,gp,20736
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   40254:	00800174 	movhi	r2,5
    ori r2, r2, %lo(__bss_start)
   40258:	10b45314 	ori	r2,r2,53580

    movhi r3, %hi(__bss_end)
   4025c:	00c001b4 	movhi	r3,6
    ori r3, r3, %lo(__bss_end)
   40260:	18d0d114 	ori	r3,r3,17220

    beq r2, r3, 1f
   40264:	10c00326 	beq	r2,r3,40274 <_start+0x30>

0:
    stw zero, (r2)
   40268:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   4026c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   40270:	10fffd36 	bltu	r2,r3,40268 <__alt_mem_epcs_flash+0xfffbf268>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   40274:	0049c4c0 	call	49c4c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   40278:	0049cd00 	call	49cd0 <alt_main>

0004027c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   4027c:	003fff06 	br	4027c <__alt_mem_epcs_flash+0xfffbf27c>

00040280 <delay_ms>:
};

Sys_Status SysStatus;
// 500us宸﹀彸
void delay_ms(unsigned int d)
{
   40280:	defffd04 	addi	sp,sp,-12
   40284:	df000215 	stw	fp,8(sp)
   40288:	df000204 	addi	fp,sp,8
   4028c:	e13fff15 	stw	r4,-4(fp)
    int i = 0;
   40290:	e03ffe15 	stw	zero,-8(fp)
    while(i < d * 1000)
   40294:	00000306 	br	402a4 <delay_ms+0x24>
        i++;
   40298:	e0bffe17 	ldw	r2,-8(fp)
   4029c:	10800044 	addi	r2,r2,1
   402a0:	e0bffe15 	stw	r2,-8(fp)
Sys_Status SysStatus;
// 500us宸﹀彸
void delay_ms(unsigned int d)
{
    int i = 0;
    while(i < d * 1000)
   402a4:	e0bfff17 	ldw	r2,-4(fp)
   402a8:	1080fa24 	muli	r2,r2,1000
   402ac:	e0fffe17 	ldw	r3,-8(fp)
   402b0:	18bff936 	bltu	r3,r2,40298 <__alt_mem_epcs_flash+0xfffbf298>
        i++;
}
   402b4:	0001883a 	nop
   402b8:	e037883a 	mov	sp,fp
   402bc:	df000017 	ldw	fp,0(sp)
   402c0:	dec00104 	addi	sp,sp,4
   402c4:	f800283a 	ret

000402c8 <delay_us>:

// 1.4us宸﹀彸
void delay_us(unsigned int d)
{
   402c8:	defffc04 	addi	sp,sp,-16
   402cc:	df000315 	stw	fp,12(sp)
   402d0:	df000304 	addi	fp,sp,12
   402d4:	e13fff15 	stw	r4,-4(fp)
    int i = 0;
   402d8:	e03ffd15 	stw	zero,-12(fp)
    int j = 0;
   402dc:	e03ffe15 	stw	zero,-8(fp)
    for(i = 0; i < d; i++)
   402e0:	e03ffd15 	stw	zero,-12(fp)
   402e4:	00000b06 	br	40314 <delay_us+0x4c>
    {
        for(j = 0; j < 2; j++)
   402e8:	e03ffe15 	stw	zero,-8(fp)
   402ec:	00000306 	br	402fc <delay_us+0x34>
   402f0:	e0bffe17 	ldw	r2,-8(fp)
   402f4:	10800044 	addi	r2,r2,1
   402f8:	e0bffe15 	stw	r2,-8(fp)
   402fc:	e0bffe17 	ldw	r2,-8(fp)
   40300:	10800090 	cmplti	r2,r2,2
   40304:	103ffa1e 	bne	r2,zero,402f0 <__alt_mem_epcs_flash+0xfffbf2f0>
// 1.4us宸﹀彸
void delay_us(unsigned int d)
{
    int i = 0;
    int j = 0;
    for(i = 0; i < d; i++)
   40308:	e0bffd17 	ldw	r2,-12(fp)
   4030c:	10800044 	addi	r2,r2,1
   40310:	e0bffd15 	stw	r2,-12(fp)
   40314:	e0fffd17 	ldw	r3,-12(fp)
   40318:	e0bfff17 	ldw	r2,-4(fp)
   4031c:	18bff236 	bltu	r3,r2,402e8 <__alt_mem_epcs_flash+0xfffbf2e8>
        for(j = 0; j < 2; j++)
        {
            ;
        }
    }
}
   40320:	0001883a 	nop
   40324:	e037883a 	mov	sp,fp
   40328:	df000017 	ldw	fp,0(sp)
   4032c:	dec00104 	addi	sp,sp,4
   40330:	f800283a 	ret

00040334 <tim561_run>:

void tim561_run(void)
{
   40334:	defff804 	addi	sp,sp,-32
   40338:	dfc00715 	stw	ra,28(sp)
   4033c:	df000615 	stw	fp,24(sp)
   40340:	df000604 	addi	fp,sp,24
    uint8  boardcast_ip[4] = {255, 255, 255, 255};
   40344:	00bfffc4 	movi	r2,-1
   40348:	e0bffd45 	stb	r2,-11(fp)
   4034c:	00bfffc4 	movi	r2,-1
   40350:	e0bffd85 	stb	r2,-10(fp)
   40354:	00bfffc4 	movi	r2,-1
   40358:	e0bffdc5 	stb	r2,-9(fp)
   4035c:	00bfffc4 	movi	r2,-1
   40360:	e0bffe05 	stb	r2,-8(fp)
    uint16 local_port      = 30718;
   40364:	009dff84 	movi	r2,30718
   40368:	e0bffb8d 	sth	r2,-18(fp)
    uint8  remote_ip[4];
    uint16 remote_port;
    uint16 len = 0;
   4036c:	e03ffc0d 	sth	zero,-16(fp)
    uint8  status;
    uint8  socket0_error = 0;
   40370:	e03ffc85 	stb	zero,-14(fp)
    uint8  socket2_error = 0;
   40374:	e03ffb05 	stb	zero,-20(fp)
    uint8  socket0_close = 0;
   40378:	e03ffcc5 	stb	zero,-13(fp)
    uint8  socket2_close = 0;
   4037c:	e03ffb45 	stb	zero,-19(fp)
    status               = getSn_SR(SOCKET0);
   40380:	0009883a 	mov	r4,zero
   40384:	0048d600 	call	48d60 <getSn_SR>
   40388:	e0bffd05 	stb	r2,-12(fp)
    switch(status)
   4038c:	e0bffd03 	ldbu	r2,-12(fp)
   40390:	10c00768 	cmpgeui	r3,r2,29
   40394:	18005b1e 	bne	r3,zero,40504 <tim561_run+0x1d0>
   40398:	100690ba 	slli	r3,r2,2
   4039c:	00800134 	movhi	r2,4
   403a0:	1080ec04 	addi	r2,r2,944
   403a4:	1885883a 	add	r2,r3,r2
   403a8:	10800017 	ldw	r2,0(r2)
   403ac:	1000683a 	jmp	r2
   403b0:	000404b8 	rdprs	zero,zero,4114
   403b4:	00040504 	movi	zero,4116
   403b8:	00040504 	movi	zero,4116
   403bc:	00040504 	movi	zero,4116
   403c0:	00040504 	movi	zero,4116
   403c4:	00040504 	movi	zero,4116
   403c8:	00040504 	movi	zero,4116
   403cc:	00040504 	movi	zero,4116
   403d0:	00040504 	movi	zero,4116
   403d4:	00040504 	movi	zero,4116
   403d8:	00040504 	movi	zero,4116
   403dc:	00040504 	movi	zero,4116
   403e0:	00040504 	movi	zero,4116
   403e4:	00040504 	movi	zero,4116
   403e8:	00040504 	movi	zero,4116
   403ec:	00040504 	movi	zero,4116
   403f0:	00040504 	movi	zero,4116
   403f4:	000404f4 	movhi	zero,4115
   403f8:	00040504 	movi	zero,4116
   403fc:	00040424 	muli	zero,zero,4112
   40400:	0004050c 	andi	zero,zero,4116
   40404:	00040504 	movi	zero,4116
   40408:	0004050c 	andi	zero,zero,4116
   4040c:	00040430 	cmpltui	zero,zero,4112
   40410:	00040504 	movi	zero,4116
   40414:	00040504 	movi	zero,4116
   40418:	00040504 	movi	zero,4116
   4041c:	00040504 	movi	zero,4116
   40420:	000404a0 	cmpeqi	zero,zero,4114
    {
        case SOCK_INIT:
            listen(SOCKET0);
   40424:	0009883a 	mov	r4,zero
   40428:	0046cec0 	call	46cec <listen>
            break;
   4042c:	00003a06 	br	40518 <tim561_run+0x1e4>
        case SOCK_ESTABLISHED:
            if(getSn_IR(SOCKET0) & Sn_IR_CON)
   40430:	0009883a 	mov	r4,zero
   40434:	0048d200 	call	48d20 <getSn_IR>
   40438:	10803fcc 	andi	r2,r2,255
   4043c:	1080004c 	andi	r2,r2,1
   40440:	10000326 	beq	r2,zero,40450 <tim561_run+0x11c>
            {
                setSn_IR(SOCKET0, Sn_IR_CON);
   40444:	01400044 	movi	r5,1
   40448:	0009883a 	mov	r4,zero
   4044c:	00491c80 	call	491c8 <setSn_IR>
            }
            len = getSn_RX_RSR(SOCKET0);
   40450:	0009883a 	mov	r4,zero
   40454:	0048e840 	call	48e84 <getSn_RX_RSR>
   40458:	e0bffc0d 	sth	r2,-16(fp)
            if(len > 0)
   4045c:	e0bffc0b 	ldhu	r2,-16(fp)
   40460:	10000c26 	beq	r2,zero,40494 <tim561_run+0x160>
            {
                recv(SOCKET0, buffer, len);
   40464:	e0bffc0b 	ldhu	r2,-16(fp)
   40468:	100d883a 	mov	r6,r2
   4046c:	014001b4 	movhi	r5,6
   40470:	29748304 	addi	r5,r5,-11764
   40474:	0009883a 	mov	r4,zero
   40478:	00472540 	call	47254 <recv>
                pc2dev_parse(SOCKET0, buffer, len);
   4047c:	e0bffc0b 	ldhu	r2,-16(fp)
   40480:	100d883a 	mov	r6,r2
   40484:	014001b4 	movhi	r5,6
   40488:	29748304 	addi	r5,r5,-11764
   4048c:	0009883a 	mov	r4,zero
   40490:	004376c0 	call	4376c <pc2dev_parse>
                // send(0, buffer, len);
            }
            isTcpEstablished = 1;
   40494:	00800044 	movi	r2,1
   40498:	d0a01305 	stb	r2,-32692(gp)
            break;
   4049c:	00001e06 	br	40518 <tim561_run+0x1e4>
        case SOCK_CLOSE_WAIT:
            socket0_close++;
   404a0:	e0bffcc3 	ldbu	r2,-13(fp)
   404a4:	10800044 	addi	r2,r2,1
   404a8:	e0bffcc5 	stb	r2,-13(fp)
            close_socket(SOCKET0);
   404ac:	0009883a 	mov	r4,zero
   404b0:	0046c6c0 	call	46c6c <close_socket>
            break;
   404b4:	00001806 	br	40518 <tim561_run+0x1e4>
        case SOCK_CLOSED:
            socket(SOCKET0, Sn_MR_TCP, 2111, Sn_MR_ND);
   404b8:	01c00804 	movi	r7,32
   404bc:	01820fc4 	movi	r6,2111
   404c0:	01400044 	movi	r5,1
   404c4:	0009883a 	mov	r4,zero
   404c8:	0046aa40 	call	46aa4 <socket>
            if(isTcpEstablished)
   404cc:	d0a01303 	ldbu	r2,-32692(gp)
   404d0:	10803fcc 	andi	r2,r2,255
   404d4:	10000f26 	beq	r2,zero,40514 <tim561_run+0x1e0>
            {
                Reset_W5500();
   404d8:	0040b780 	call	40b78 <Reset_W5500>
                delay_ms(500);
   404dc:	01007d04 	movi	r4,500
   404e0:	00402800 	call	40280 <delay_ms>
                set_default();  // 璁剧疆榛樿MAC銆両P銆丟W銆丼UB銆丏NS
   404e4:	0040ca00 	call	40ca0 <set_default>
                set_network();  // 閰嶇疆鍒濆鍖朓P淇℃伅骞舵墦鍗帮紝鍒濆鍖�8涓猄ocket
   404e8:	0040c140 	call	40c14 <set_network>
                isTcpEstablished = 0;
   404ec:	d0201305 	stb	zero,-32692(gp)
            }
            break;
   404f0:	00000806 	br	40514 <tim561_run+0x1e0>
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
        case 0x11:
            socket0_error++;
   404f4:	e0bffc83 	ldbu	r2,-14(fp)
   404f8:	10800044 	addi	r2,r2,1
   404fc:	e0bffc85 	stb	r2,-14(fp)
            break;
   40500:	00000506 	br	40518 <tim561_run+0x1e4>
        default:
            len = 0;
   40504:	e03ffc0d 	sth	zero,-16(fp)
            break;
   40508:	00000306 	br	40518 <tim561_run+0x1e4>
                isTcpEstablished = 0;
            }
            break;
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
   4050c:	0001883a 	nop
   40510:	00000106 	br	40518 <tim561_run+0x1e4>
                delay_ms(500);
                set_default();  // 璁剧疆榛樿MAC銆両P銆丟W銆丼UB銆丏NS
                set_network();  // 閰嶇疆鍒濆鍖朓P淇℃伅骞舵墦鍗帮紝鍒濆鍖�8涓猄ocket
                isTcpEstablished = 0;
            }
            break;
   40514:	0001883a 	nop
        default:
            len = 0;
            break;
    }

    status = getSn_SR(SOCKET1);
   40518:	01000044 	movi	r4,1
   4051c:	0048d600 	call	48d60 <getSn_SR>
   40520:	e0bffd05 	stb	r2,-12(fp)
    switch(status)
   40524:	e0bffd03 	ldbu	r2,-12(fp)
   40528:	10c00768 	cmpgeui	r3,r2,29
   4052c:	1800541e 	bne	r3,zero,40680 <tim561_run+0x34c>
   40530:	100690ba 	slli	r3,r2,2
   40534:	00800134 	movhi	r2,4
   40538:	10815204 	addi	r2,r2,1352
   4053c:	1885883a 	add	r2,r3,r2
   40540:	10800017 	ldw	r2,0(r2)
   40544:	1000683a 	jmp	r2
   40548:	00040648 	cmpgei	zero,zero,4121
   4054c:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40550:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40554:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40558:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   4055c:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40560:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40564:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40568:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   4056c:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40570:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40574:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40578:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   4057c:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40580:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40584:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40588:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   4058c:	00040670 	cmpltui	zero,zero,4121
   40590:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   40594:	000405bc 	xorhi	zero,zero,4118
   40598:	00040688 	cmpgei	zero,zero,4122
   4059c:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   405a0:	00040688 	cmpgei	zero,zero,4122
   405a4:	000405c8 	cmpgei	zero,zero,4119
   405a8:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   405ac:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   405b0:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   405b4:	00040680 	call	4068 <__alt_mem_onchip_memory-0x3bf98>
   405b8:	00040630 	cmpltui	zero,zero,4120
    {
        case SOCK_INIT:
            listen(SOCKET1);
   405bc:	01000044 	movi	r4,1
   405c0:	0046cec0 	call	46cec <listen>
            break;
   405c4:	00003506 	br	4069c <tim561_run+0x368>
        case SOCK_ESTABLISHED:
            if(getSn_IR(SOCKET1) & Sn_IR_CON)
   405c8:	01000044 	movi	r4,1
   405cc:	0048d200 	call	48d20 <getSn_IR>
   405d0:	10803fcc 	andi	r2,r2,255
   405d4:	1080004c 	andi	r2,r2,1
   405d8:	10000326 	beq	r2,zero,405e8 <tim561_run+0x2b4>
            {
                setSn_IR(SOCKET1, Sn_IR_CON);
   405dc:	01400044 	movi	r5,1
   405e0:	01000044 	movi	r4,1
   405e4:	00491c80 	call	491c8 <setSn_IR>
            }
            len = getSn_RX_RSR(SOCKET1);
   405e8:	01000044 	movi	r4,1
   405ec:	0048e840 	call	48e84 <getSn_RX_RSR>
   405f0:	e0bffc0d 	sth	r2,-16(fp)
            if(len > 0)
   405f4:	e0bffc0b 	ldhu	r2,-16(fp)
   405f8:	10002526 	beq	r2,zero,40690 <tim561_run+0x35c>
            {
                recv(SOCKET1, buffer, len);
   405fc:	e0bffc0b 	ldhu	r2,-16(fp)
   40600:	100d883a 	mov	r6,r2
   40604:	014001b4 	movhi	r5,6
   40608:	29748304 	addi	r5,r5,-11764
   4060c:	01000044 	movi	r4,1
   40610:	00472540 	call	47254 <recv>
                pc2dev_parse(SOCKET1, buffer, len);
   40614:	e0bffc0b 	ldhu	r2,-16(fp)
   40618:	100d883a 	mov	r6,r2
   4061c:	014001b4 	movhi	r5,6
   40620:	29748304 	addi	r5,r5,-11764
   40624:	01000044 	movi	r4,1
   40628:	004376c0 	call	4376c <pc2dev_parse>
            }
            break;
   4062c:	00001806 	br	40690 <tim561_run+0x35c>
        case SOCK_CLOSE_WAIT:
            socket2_close++;
   40630:	e0bffb43 	ldbu	r2,-19(fp)
   40634:	10800044 	addi	r2,r2,1
   40638:	e0bffb45 	stb	r2,-19(fp)
            close_socket(SOCKET1);
   4063c:	01000044 	movi	r4,1
   40640:	0046c6c0 	call	46c6c <close_socket>
            break;
   40644:	00001506 	br	4069c <tim561_run+0x368>
        case SOCK_CLOSED:
            socket(SOCKET1, Sn_MR_TCP, 2111, Sn_MR_ND);
   40648:	01c00804 	movi	r7,32
   4064c:	01820fc4 	movi	r6,2111
   40650:	01400044 	movi	r5,1
   40654:	01000044 	movi	r4,1
   40658:	0046aa40 	call	46aa4 <socket>
            if(isTcpEstablished)
   4065c:	d0a01303 	ldbu	r2,-32692(gp)
   40660:	10803fcc 	andi	r2,r2,255
   40664:	10000c26 	beq	r2,zero,40698 <tim561_run+0x364>
            {
                // Reset_W5500();
                // delay_ms(500);
                // set_default();  // 璁剧疆榛樿MAC銆両P銆丟W銆丼UB銆丏NS
                // set_network();  // 閰嶇疆鍒濆鍖朓P淇℃伅骞舵墦鍗帮紝鍒濆鍖�8涓猄ocket
                isTcpEstablished = 0;
   40668:	d0201305 	stb	zero,-32692(gp)
            }
            break;
   4066c:	00000a06 	br	40698 <tim561_run+0x364>
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
        case 0x11:
            socket2_error++;
   40670:	e0bffb03 	ldbu	r2,-20(fp)
   40674:	10800044 	addi	r2,r2,1
   40678:	e0bffb05 	stb	r2,-20(fp)
            break;
   4067c:	00000706 	br	4069c <tim561_run+0x368>
        default:
            len = 0;
   40680:	e03ffc0d 	sth	zero,-16(fp)
            break;
   40684:	00000506 	br	4069c <tim561_run+0x368>
                isTcpEstablished = 0;
            }
            break;
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
   40688:	0001883a 	nop
   4068c:	00000306 	br	4069c <tim561_run+0x368>
            if(len > 0)
            {
                recv(SOCKET1, buffer, len);
                pc2dev_parse(SOCKET1, buffer, len);
            }
            break;
   40690:	0001883a 	nop
   40694:	00000106 	br	4069c <tim561_run+0x368>
                // delay_ms(500);
                // set_default();  // 璁剧疆榛樿MAC銆両P銆丟W銆丼UB銆丏NS
                // set_network();  // 閰嶇疆鍒濆鍖朓P淇℃伅骞舵墦鍗帮紝鍒濆鍖�8涓猄ocket
                isTcpEstablished = 0;
            }
            break;
   40698:	0001883a 	nop
        default:
            len = 0;
            break;
    }

    status = getSn_SR(SOCKET4);
   4069c:	01000104 	movi	r4,4
   406a0:	0048d600 	call	48d60 <getSn_SR>
   406a4:	e0bffd05 	stb	r2,-12(fp)
    switch(status)
   406a8:	e0bffd03 	ldbu	r2,-12(fp)
   406ac:	10c00768 	cmpgeui	r3,r2,29
   406b0:	1800501e 	bne	r3,zero,407f4 <tim561_run+0x4c0>
   406b4:	100690ba 	slli	r3,r2,2
   406b8:	00800134 	movhi	r2,4
   406bc:	1081b304 	addi	r2,r2,1740
   406c0:	1885883a 	add	r2,r3,r2
   406c4:	10800017 	ldw	r2,0(r2)
   406c8:	1000683a 	jmp	r2
   406cc:	000407cc 	andi	zero,zero,4127
   406d0:	000407f4 	movhi	zero,4127
   406d4:	000407f4 	movhi	zero,4127
   406d8:	000407f4 	movhi	zero,4127
   406dc:	000407f4 	movhi	zero,4127
   406e0:	000407f4 	movhi	zero,4127
   406e4:	000407f4 	movhi	zero,4127
   406e8:	000407f4 	movhi	zero,4127
   406ec:	000407f4 	movhi	zero,4127
   406f0:	000407f4 	movhi	zero,4127
   406f4:	000407f4 	movhi	zero,4127
   406f8:	000407f4 	movhi	zero,4127
   406fc:	000407f4 	movhi	zero,4127
   40700:	000407f4 	movhi	zero,4127
   40704:	000407f4 	movhi	zero,4127
   40708:	000407f4 	movhi	zero,4127
   4070c:	000407f4 	movhi	zero,4127
   40710:	000407e4 	muli	zero,zero,4127
   40714:	000407f4 	movhi	zero,4127
   40718:	00040740 	call	4074 <__alt_mem_onchip_memory-0x3bf8c>
   4071c:	000407fc 	xorhi	zero,zero,4127
   40720:	000407f4 	movhi	zero,4127
   40724:	000407fc 	xorhi	zero,zero,4127
   40728:	0004074c 	andi	zero,zero,4125
   4072c:	000407f4 	movhi	zero,4127
   40730:	000407f4 	movhi	zero,4127
   40734:	000407f4 	movhi	zero,4127
   40738:	000407f4 	movhi	zero,4127
   4073c:	000407b4 	movhi	zero,4126
    {
        case SOCK_INIT:
            listen(SOCKET4);
   40740:	01000104 	movi	r4,4
   40744:	0046cec0 	call	46cec <listen>
            break;
   40748:	00002f06 	br	40808 <tim561_run+0x4d4>
        case SOCK_ESTABLISHED:
            if(getSn_IR(SOCKET4) & Sn_IR_CON)
   4074c:	01000104 	movi	r4,4
   40750:	0048d200 	call	48d20 <getSn_IR>
   40754:	10803fcc 	andi	r2,r2,255
   40758:	1080004c 	andi	r2,r2,1
   4075c:	10000326 	beq	r2,zero,4076c <tim561_run+0x438>
            {
                setSn_IR(SOCKET4, Sn_IR_CON);
   40760:	01400044 	movi	r5,1
   40764:	01000104 	movi	r4,4
   40768:	00491c80 	call	491c8 <setSn_IR>
            }
            len = getSn_RX_RSR(SOCKET4);
   4076c:	01000104 	movi	r4,4
   40770:	0048e840 	call	48e84 <getSn_RX_RSR>
   40774:	e0bffc0d 	sth	r2,-16(fp)
            if(len > 0)
   40778:	e0bffc0b 	ldhu	r2,-16(fp)
   4077c:	10002126 	beq	r2,zero,40804 <tim561_run+0x4d0>
            {
                recv(SOCKET4, buffer, len);
   40780:	e0bffc0b 	ldhu	r2,-16(fp)
   40784:	100d883a 	mov	r6,r2
   40788:	014001b4 	movhi	r5,6
   4078c:	29748304 	addi	r5,r5,-11764
   40790:	01000104 	movi	r4,4
   40794:	00472540 	call	47254 <recv>
                pc2dev_parse(SOCKET4, buffer, len);
   40798:	e0bffc0b 	ldhu	r2,-16(fp)
   4079c:	100d883a 	mov	r6,r2
   407a0:	014001b4 	movhi	r5,6
   407a4:	29748304 	addi	r5,r5,-11764
   407a8:	01000104 	movi	r4,4
   407ac:	004376c0 	call	4376c <pc2dev_parse>
                // send(0, buffer, len);
            }
            break;
   407b0:	00001406 	br	40804 <tim561_run+0x4d0>
        case SOCK_CLOSE_WAIT:
            socket2_close++;
   407b4:	e0bffb43 	ldbu	r2,-19(fp)
   407b8:	10800044 	addi	r2,r2,1
   407bc:	e0bffb45 	stb	r2,-19(fp)
            close_socket(SOCKET4);
   407c0:	01000104 	movi	r4,4
   407c4:	0046c6c0 	call	46c6c <close_socket>
            break;
   407c8:	00000f06 	br	40808 <tim561_run+0x4d4>
        case SOCK_CLOSED:
            socket(SOCKET4, Sn_MR_TCP, 2112, Sn_MR_ND);
   407cc:	01c00804 	movi	r7,32
   407d0:	01821004 	movi	r6,2112
   407d4:	01400044 	movi	r5,1
   407d8:	01000104 	movi	r4,4
   407dc:	0046aa40 	call	46aa4 <socket>
            break;
   407e0:	00000906 	br	40808 <tim561_run+0x4d4>
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
        case 0x11:
            socket2_error++;
   407e4:	e0bffb03 	ldbu	r2,-20(fp)
   407e8:	10800044 	addi	r2,r2,1
   407ec:	e0bffb05 	stb	r2,-20(fp)
            break;
   407f0:	00000506 	br	40808 <tim561_run+0x4d4>
        default:
            len = 0;
   407f4:	e03ffc0d 	sth	zero,-16(fp)
            break;
   407f8:	00000306 	br	40808 <tim561_run+0x4d4>
        case SOCK_CLOSED:
            socket(SOCKET4, Sn_MR_TCP, 2112, Sn_MR_ND);
            break;
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
   407fc:	0001883a 	nop
   40800:	00000106 	br	40808 <tim561_run+0x4d4>
            {
                recv(SOCKET4, buffer, len);
                pc2dev_parse(SOCKET4, buffer, len);
                // send(0, buffer, len);
            }
            break;
   40804:	0001883a 	nop
        default:
            len = 0;
            break;
    }

    status = getSn_SR(SOCKET5);
   40808:	01000144 	movi	r4,5
   4080c:	0048d600 	call	48d60 <getSn_SR>
   40810:	e0bffd05 	stb	r2,-12(fp)
    switch(status)
   40814:	e0bffd03 	ldbu	r2,-12(fp)
   40818:	10c00768 	cmpgeui	r3,r2,29
   4081c:	1800501e 	bne	r3,zero,40960 <tim561_run+0x62c>
   40820:	100690ba 	slli	r3,r2,2
   40824:	00800134 	movhi	r2,4
   40828:	10820e04 	addi	r2,r2,2104
   4082c:	1885883a 	add	r2,r3,r2
   40830:	10800017 	ldw	r2,0(r2)
   40834:	1000683a 	jmp	r2
   40838:	00040938 	rdprs	zero,zero,4132
   4083c:	00040960 	cmpeqi	zero,zero,4133
   40840:	00040960 	cmpeqi	zero,zero,4133
   40844:	00040960 	cmpeqi	zero,zero,4133
   40848:	00040960 	cmpeqi	zero,zero,4133
   4084c:	00040960 	cmpeqi	zero,zero,4133
   40850:	00040960 	cmpeqi	zero,zero,4133
   40854:	00040960 	cmpeqi	zero,zero,4133
   40858:	00040960 	cmpeqi	zero,zero,4133
   4085c:	00040960 	cmpeqi	zero,zero,4133
   40860:	00040960 	cmpeqi	zero,zero,4133
   40864:	00040960 	cmpeqi	zero,zero,4133
   40868:	00040960 	cmpeqi	zero,zero,4133
   4086c:	00040960 	cmpeqi	zero,zero,4133
   40870:	00040960 	cmpeqi	zero,zero,4133
   40874:	00040960 	cmpeqi	zero,zero,4133
   40878:	00040960 	cmpeqi	zero,zero,4133
   4087c:	00040950 	cmplti	zero,zero,4133
   40880:	00040960 	cmpeqi	zero,zero,4133
   40884:	000408ac 	andhi	zero,zero,4130
   40888:	00040968 	cmpgeui	zero,zero,4133
   4088c:	00040960 	cmpeqi	zero,zero,4133
   40890:	00040968 	cmpgeui	zero,zero,4133
   40894:	000408b8 	rdprs	zero,zero,4130
   40898:	00040960 	cmpeqi	zero,zero,4133
   4089c:	00040960 	cmpeqi	zero,zero,4133
   408a0:	00040960 	cmpeqi	zero,zero,4133
   408a4:	00040960 	cmpeqi	zero,zero,4133
   408a8:	00040920 	cmpeqi	zero,zero,4132
    {
        case SOCK_INIT:
            listen(SOCKET5);
   408ac:	01000144 	movi	r4,5
   408b0:	0046cec0 	call	46cec <listen>
            break;
   408b4:	00002f06 	br	40974 <tim561_run+0x640>
        case SOCK_ESTABLISHED:
            if(getSn_IR(SOCKET5) & Sn_IR_CON)
   408b8:	01000144 	movi	r4,5
   408bc:	0048d200 	call	48d20 <getSn_IR>
   408c0:	10803fcc 	andi	r2,r2,255
   408c4:	1080004c 	andi	r2,r2,1
   408c8:	10000326 	beq	r2,zero,408d8 <tim561_run+0x5a4>
            {
                setSn_IR(SOCKET5, Sn_IR_CON);
   408cc:	01400044 	movi	r5,1
   408d0:	01000144 	movi	r4,5
   408d4:	00491c80 	call	491c8 <setSn_IR>
            }

            len = getSn_RX_RSR(SOCKET5);
   408d8:	01000144 	movi	r4,5
   408dc:	0048e840 	call	48e84 <getSn_RX_RSR>
   408e0:	e0bffc0d 	sth	r2,-16(fp)
            if(len > 0)
   408e4:	e0bffc0b 	ldhu	r2,-16(fp)
   408e8:	10002126 	beq	r2,zero,40970 <tim561_run+0x63c>
            {
                recv(SOCKET5, buffer, len);
   408ec:	e0bffc0b 	ldhu	r2,-16(fp)
   408f0:	100d883a 	mov	r6,r2
   408f4:	014001b4 	movhi	r5,6
   408f8:	29748304 	addi	r5,r5,-11764
   408fc:	01000144 	movi	r4,5
   40900:	00472540 	call	47254 <recv>
                pc2dev_parse(SOCKET5, buffer, len);
   40904:	e0bffc0b 	ldhu	r2,-16(fp)
   40908:	100d883a 	mov	r6,r2
   4090c:	014001b4 	movhi	r5,6
   40910:	29748304 	addi	r5,r5,-11764
   40914:	01000144 	movi	r4,5
   40918:	004376c0 	call	4376c <pc2dev_parse>
                // send(0, buffer, len);
            }
            break;
   4091c:	00001406 	br	40970 <tim561_run+0x63c>
        case SOCK_CLOSE_WAIT:
            socket2_close++;
   40920:	e0bffb43 	ldbu	r2,-19(fp)
   40924:	10800044 	addi	r2,r2,1
   40928:	e0bffb45 	stb	r2,-19(fp)
            close_socket(SOCKET5);
   4092c:	01000144 	movi	r4,5
   40930:	0046c6c0 	call	46c6c <close_socket>
            break;
   40934:	00000f06 	br	40974 <tim561_run+0x640>
        case SOCK_CLOSED:
            socket(SOCKET5, Sn_MR_TCP, 2112, Sn_MR_ND);
   40938:	01c00804 	movi	r7,32
   4093c:	01821004 	movi	r6,2112
   40940:	01400044 	movi	r5,1
   40944:	01000144 	movi	r4,5
   40948:	0046aa40 	call	46aa4 <socket>
            break;
   4094c:	00000906 	br	40974 <tim561_run+0x640>
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
        case 0x11:
            socket2_error++;
   40950:	e0bffb03 	ldbu	r2,-20(fp)
   40954:	10800044 	addi	r2,r2,1
   40958:	e0bffb05 	stb	r2,-20(fp)
            break;
   4095c:	00000506 	br	40974 <tim561_run+0x640>
        default:
            len = 0;
   40960:	e03ffc0d 	sth	zero,-16(fp)
            break;
   40964:	00000306 	br	40974 <tim561_run+0x640>
        case SOCK_CLOSED:
            socket(SOCKET5, Sn_MR_TCP, 2112, Sn_MR_ND);
            break;
        case SOCK_LISTEN:
        case SOCK_SYNRECV:
            break;
   40968:	0001883a 	nop
   4096c:	00000106 	br	40974 <tim561_run+0x640>
            {
                recv(SOCKET5, buffer, len);
                pc2dev_parse(SOCKET5, buffer, len);
                // send(0, buffer, len);
            }
            break;
   40970:	0001883a 	nop
        default:
            len = 0;
            break;
    }

    switch(getSn_SR(SOCKET7))
   40974:	010001c4 	movi	r4,7
   40978:	0048d600 	call	48d60 <getSn_SR>
   4097c:	10803fcc 	andi	r2,r2,255
   40980:	10003426 	beq	r2,zero,40a54 <tim561_run+0x720>
   40984:	108008a0 	cmpeqi	r2,r2,34
   40988:	1000011e 	bne	r2,zero,40990 <tim561_run+0x65c>
            break;
        case SOCK_CLOSED:
            socket(SOCKET7, Sn_MR_UDP, local_port, 0);
            break;
    }
}
   4098c:	00003906 	br	40a74 <tim561_run+0x740>
    }

    switch(getSn_SR(SOCKET7))
    {
        case SOCK_UDP:  // Socket???????(??)??
            delay_ms(10);
   40990:	01000284 	movi	r4,10
   40994:	00402800 	call	40280 <delay_ms>
            if(getSn_IR(SOCKET7) & Sn_IR_RECV)
   40998:	010001c4 	movi	r4,7
   4099c:	0048d200 	call	48d20 <getSn_IR>
   409a0:	10803fcc 	andi	r2,r2,255
   409a4:	1080010c 	andi	r2,r2,4
   409a8:	10000326 	beq	r2,zero,409b8 <tim561_run+0x684>
            {
                setSn_IR(SOCKET7, Sn_IR_RECV);
   409ac:	01400104 	movi	r5,4
   409b0:	010001c4 	movi	r4,7
   409b4:	00491c80 	call	491c8 <setSn_IR>
            }

            if((len = getSn_RX_RSR(SOCKET7)) > 0)
   409b8:	010001c4 	movi	r4,7
   409bc:	0048e840 	call	48e84 <getSn_RX_RSR>
   409c0:	e0bffc0d 	sth	r2,-16(fp)
   409c4:	e0bffc0b 	ldhu	r2,-16(fp)
   409c8:	10002926 	beq	r2,zero,40a70 <tim561_run+0x73c>
            {
                memset(buffer, 0, len + 1);
   409cc:	e0bffc0b 	ldhu	r2,-16(fp)
   409d0:	10800044 	addi	r2,r2,1
   409d4:	100d883a 	mov	r6,r2
   409d8:	000b883a 	mov	r5,zero
   409dc:	010001b4 	movhi	r4,6
   409e0:	21348304 	addi	r4,r4,-11764
   409e4:	004951c0 	call	4951c <memset>
                recvfrom(SOCKET7, buffer, len, remote_ip, &remote_port);
   409e8:	e0fffc0b 	ldhu	r3,-16(fp)
   409ec:	e13ffe44 	addi	r4,fp,-7
   409f0:	e0bfff84 	addi	r2,fp,-2
   409f4:	d8800015 	stw	r2,0(sp)
   409f8:	200f883a 	mov	r7,r4
   409fc:	180d883a 	mov	r6,r3
   40a00:	014001b4 	movhi	r5,6
   40a04:	29748304 	addi	r5,r5,-11764
   40a08:	010001c4 	movi	r4,7
   40a0c:	00475900 	call	47590 <recvfrom>
                // sendto(1, buffer, len, remote_ip, remote_port);
                sendto(SOCKET7, udp_reponse, 1213, boardcast_ip, remote_port);
   40a10:	e0bfff8b 	ldhu	r2,-2(fp)
   40a14:	10bfffcc 	andi	r2,r2,65535
   40a18:	e0fffd44 	addi	r3,fp,-11
   40a1c:	d8800015 	stw	r2,0(sp)
   40a20:	180f883a 	mov	r7,r3
   40a24:	01812f44 	movi	r6,1213
   40a28:	014001b4 	movhi	r5,6
   40a2c:	2967ab04 	addi	r5,r5,-24916
   40a30:	010001c4 	movi	r4,7
   40a34:	00472f40 	call	472f4 <sendto>
                alarm_region.change_region_flag = 0x01;
   40a38:	008001b4 	movhi	r2,6
   40a3c:	10a5c204 	addi	r2,r2,-26872
   40a40:	00c00044 	movi	r3,1
   40a44:	10c00085 	stb	r3,2(r2)
                isPowerUp                       = 0x01;
   40a48:	00800044 	movi	r2,1
   40a4c:	d0a01505 	stb	r2,-32684(gp)
            }
            break;
   40a50:	00000706 	br	40a70 <tim561_run+0x73c>
        case SOCK_CLOSED:
            socket(SOCKET7, Sn_MR_UDP, local_port, 0);
   40a54:	e0bffb8b 	ldhu	r2,-18(fp)
   40a58:	000f883a 	mov	r7,zero
   40a5c:	100d883a 	mov	r6,r2
   40a60:	01400084 	movi	r5,2
   40a64:	010001c4 	movi	r4,7
   40a68:	0046aa40 	call	46aa4 <socket>
            break;
   40a6c:	00000106 	br	40a74 <tim561_run+0x740>
                // sendto(1, buffer, len, remote_ip, remote_port);
                sendto(SOCKET7, udp_reponse, 1213, boardcast_ip, remote_port);
                alarm_region.change_region_flag = 0x01;
                isPowerUp                       = 0x01;
            }
            break;
   40a70:	0001883a 	nop
        case SOCK_CLOSED:
            socket(SOCKET7, Sn_MR_UDP, local_port, 0);
            break;
    }
}
   40a74:	0001883a 	nop
   40a78:	e037883a 	mov	sp,fp
   40a7c:	dfc00117 	ldw	ra,4(sp)
   40a80:	df000017 	ldw	fp,0(sp)
   40a84:	dec00204 	addi	sp,sp,8
   40a88:	f800283a 	ret

00040a8c <test>:

void test(void)
{
   40a8c:	defe6304 	addi	sp,sp,-1652
   40a90:	dfc19c15 	stw	ra,1648(sp)
   40a94:	df019b15 	stw	fp,1644(sp)
   40a98:	df019b04 	addi	fp,sp,1644
    IINCHIP_CSon();
   40a9c:	00480080 	call	48008 <IINCHIP_CSon>
    Reset_W5500();
   40aa0:	0040b780 	call	40b78 <Reset_W5500>
    delay_ms(500);
   40aa4:	01007d04 	movi	r4,500
   40aa8:	00402800 	call	40280 <delay_ms>
    int           time        = 1;
   40aac:	00800044 	movi	r2,1
   40ab0:	e0be6615 	stw	r2,-1640(fp)
    unsigned char data        = 0x1e;
   40ab4:	00800784 	movi	r2,30
   40ab8:	e0be6705 	stb	r2,-1636(fp)
    int           offset_addr = 4096;
   40abc:	00840004 	movi	r2,4096
   40ac0:	e0be6815 	stw	r2,-1632(fp)
    int           len         = TARGET_NUMBER * 2;
   40ac4:	00819584 	movi	r2,1622
   40ac8:	e0be6915 	stw	r2,-1628(fp)
    unsigned char buf[811 * 2];
    IOWR_ALTERA_AVALON_PIO_DATA(W5500_INT_BASE, 0x00);
   40acc:	0007883a 	mov	r3,zero
   40ad0:	00800234 	movhi	r2,8
   40ad4:	10886804 	addi	r2,r2,8608
   40ad8:	10c00035 	stwio	r3,0(r2)
    while(1)
    {
        if(time)
   40adc:	e0be6617 	ldw	r2,-1640(fp)
   40ae0:	10001a26 	beq	r2,zero,40b4c <test+0xc0>
        {
            for(int i = 0; i < 811 * 2; i++)
   40ae4:	e03e6515 	stw	zero,-1644(fp)
   40ae8:	00000806 	br	40b0c <test+0x80>
                buf[i] = data;
   40aec:	e0fe6a04 	addi	r3,fp,-1624
   40af0:	e0be6517 	ldw	r2,-1644(fp)
   40af4:	1885883a 	add	r2,r3,r2
   40af8:	e0fe6703 	ldbu	r3,-1636(fp)
   40afc:	10c00005 	stb	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DATA(W5500_INT_BASE, 0x00);
    while(1)
    {
        if(time)
        {
            for(int i = 0; i < 811 * 2; i++)
   40b00:	e0be6517 	ldw	r2,-1644(fp)
   40b04:	10800044 	addi	r2,r2,1
   40b08:	e0be6515 	stw	r2,-1644(fp)
   40b0c:	e0be6517 	ldw	r2,-1644(fp)
   40b10:	10819590 	cmplti	r2,r2,1622
   40b14:	103ff51e 	bne	r2,zero,40aec <__alt_mem_epcs_flash+0xfffbfaec>
                buf[i] = data;
            eeprom_write_page(offset_addr, buf, len);
   40b18:	e0fe6817 	ldw	r3,-1632(fp)
   40b1c:	e0be6917 	ldw	r2,-1628(fp)
   40b20:	113fffcc 	andi	r4,r2,65535
   40b24:	e0be6a04 	addi	r2,fp,-1624
   40b28:	200d883a 	mov	r6,r4
   40b2c:	100b883a 	mov	r5,r2
   40b30:	1809883a 	mov	r4,r3
   40b34:	0041fd40 	call	41fd4 <eeprom_write_page>
            memset(buf, 0, TARGET_NUMBER * 2);
   40b38:	e0be6a04 	addi	r2,fp,-1624
   40b3c:	01819584 	movi	r6,1622
   40b40:	000b883a 	mov	r5,zero
   40b44:	1009883a 	mov	r4,r2
   40b48:	004951c0 	call	4951c <memset>
        }
        //		alarm_region.read_from_rom(&alarm_region, alarm_region.change_region_value * 3);
        eeprom_sequential_read(offset_addr, buf, len);
   40b4c:	e0fe6817 	ldw	r3,-1632(fp)
   40b50:	e0be6917 	ldw	r2,-1628(fp)
   40b54:	113fffcc 	andi	r4,r2,65535
   40b58:	e0be6a04 	addi	r2,fp,-1624
   40b5c:	200d883a 	mov	r6,r4
   40b60:	100b883a 	mov	r5,r2
   40b64:	1809883a 	mov	r4,r3
   40b68:	00422a40 	call	422a4 <eeprom_sequential_read>
        delay_us(1000);
   40b6c:	0100fa04 	movi	r4,1000
   40b70:	00402c80 	call	402c8 <delay_us>
    }
   40b74:	003fd906 	br	40adc <__alt_mem_epcs_flash+0xfffbfadc>

00040b78 <Reset_W5500>:

uint8 pub_buf[1460];


void Reset_W5500(void)
{
   40b78:	defffe04 	addi	sp,sp,-8
   40b7c:	dfc00115 	stw	ra,4(sp)
   40b80:	df000015 	stw	fp,0(sp)
   40b84:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DATA(W5500_RST_BASE, 0x00);
   40b88:	0007883a 	mov	r3,zero
   40b8c:	00800234 	movhi	r2,8
   40b90:	10886c04 	addi	r2,r2,8624
   40b94:	10c00035 	stwio	r3,0(r2)
    delay_ms(5);
   40b98:	01000144 	movi	r4,5
   40b9c:	00402800 	call	40280 <delay_ms>
    IOWR_ALTERA_AVALON_PIO_DATA(W5500_RST_BASE, 0x01);
   40ba0:	00c00044 	movi	r3,1
   40ba4:	00800234 	movhi	r2,8
   40ba8:	10886c04 	addi	r2,r2,8624
   40bac:	10c00035 	stwio	r3,0(r2)
    delay_ms(5);
   40bb0:	01000144 	movi	r4,5
   40bb4:	00402800 	call	40280 <delay_ms>
}
   40bb8:	0001883a 	nop
   40bbc:	e037883a 	mov	sp,fp
   40bc0:	dfc00117 	ldw	ra,4(sp)
   40bc4:	df000017 	ldw	fp,0(sp)
   40bc8:	dec00204 	addi	sp,sp,8
   40bcc:	f800283a 	ret

00040bd0 <reboot>:
//reboot
void reboot(void)
{
   40bd0:	defffc04 	addi	sp,sp,-16
   40bd4:	dfc00315 	stw	ra,12(sp)
   40bd8:	df000215 	stw	fp,8(sp)
   40bdc:	df000204 	addi	fp,sp,8
    pFunction Jump_To_Application;
    uint32 JumpAddress;
    JumpAddress = *(unsigned int*) (0x00000004);
   40be0:	00800104 	movi	r2,4
   40be4:	10800017 	ldw	r2,0(r2)
   40be8:	e0bffe15 	stw	r2,-8(fp)
    Jump_To_Application = (pFunction) JumpAddress;
   40bec:	e0bffe17 	ldw	r2,-8(fp)
   40bf0:	e0bfff15 	stw	r2,-4(fp)
    Jump_To_Application();
   40bf4:	e0bfff17 	ldw	r2,-4(fp)
   40bf8:	103ee83a 	callr	r2
}
   40bfc:	0001883a 	nop
   40c00:	e037883a 	mov	sp,fp
   40c04:	dfc00117 	ldw	ra,4(sp)
   40c08:	df000017 	ldw	fp,0(sp)
   40c0c:	dec00204 	addi	sp,sp,8
   40c10:	f800283a 	ret

00040c14 <set_network>:

void set_network(void)                                                                                                          // 配置初始化IP信息并打印，初始化8个Socket
{
   40c14:	defffd04 	addi	sp,sp,-12
   40c18:	dfc00215 	stw	ra,8(sp)
   40c1c:	df000115 	stw	fp,4(sp)
   40c20:	df000104 	addi	fp,sp,4
    uint8 ip[4];
    setSHAR(ConfigMsg.mac);
   40c24:	010001b4 	movhi	r4,6
   40c28:	21368404 	addi	r4,r4,-9712
   40c2c:	00489880 	call	48988 <setSHAR>
    setSUBR(ConfigMsg.sub);
   40c30:	010001b4 	movhi	r4,6
   40c34:	21368704 	addi	r4,r4,-9700
   40c38:	004894c0 	call	4894c <setSUBR>
    setGAR(ConfigMsg.gw);
   40c3c:	010001b4 	movhi	r4,6
   40c40:	21368804 	addi	r4,r4,-9696
   40c44:	00488d40 	call	488d4 <setGAR>
    setSIPR(ConfigMsg.lip);
   40c48:	010001b4 	movhi	r4,6
   40c4c:	21368604 	addi	r4,r4,-9704
   40c50:	00489c40 	call	489c4 <setSIPR>

    sysinit(txsize, rxsize);                                                                                              // 初始化8个socket
   40c54:	d1600204 	addi	r5,gp,-32760
   40c58:	d1200004 	addi	r4,gp,-32768
   40c5c:	004851c0 	call	4851c <sysinit>

    setRTR(5000);                                                                                                                                         // 设置超时时间
   40c60:	0104e204 	movi	r4,5000
   40c64:	0048ba40 	call	48ba4 <setRTR>
    setRCR(3);                                                                                                                                                    // 设置最大重新发送次数
   40c68:	010000c4 	movi	r4,3
   40c6c:	0048c000 	call	48c00 <setRCR>

    getSIPR (ip);
   40c70:	e13fff04 	addi	r4,fp,-4
   40c74:	0048afc0 	call	48afc <getSIPR>
    getSUBR(ip);
   40c78:	e13fff04 	addi	r4,fp,-4
   40c7c:	0048a840 	call	48a84 <getSUBR>
    getGAR(ip);
   40c80:	e13fff04 	addi	r4,fp,-4
   40c84:	0048a480 	call	48a48 <getGAR>
}
   40c88:	0001883a 	nop
   40c8c:	e037883a 	mov	sp,fp
   40c90:	dfc00117 	ldw	ra,4(sp)
   40c94:	df000017 	ldw	fp,0(sp)
   40c98:	dec00204 	addi	sp,sp,8
   40c9c:	f800283a 	ret

00040ca0 <set_default>:

void set_default(void)                                                                                                          // 设置默认MAC、IP、GW、SUB、DNS
{
   40ca0:	defff904 	addi	sp,sp,-28
   40ca4:	df000615 	stw	fp,24(sp)
   40ca8:	df000604 	addi	fp,sp,24
    uint8 mac[6]={0x00,0x06,0x77,0x25,0x3D,0x28};
   40cac:	e03ffa05 	stb	zero,-24(fp)
   40cb0:	00800184 	movi	r2,6
   40cb4:	e0bffa45 	stb	r2,-23(fp)
   40cb8:	00801dc4 	movi	r2,119
   40cbc:	e0bffa85 	stb	r2,-22(fp)
   40cc0:	00800944 	movi	r2,37
   40cc4:	e0bffac5 	stb	r2,-21(fp)
   40cc8:	00800f44 	movi	r2,61
   40ccc:	e0bffb05 	stb	r2,-20(fp)
   40cd0:	00800a04 	movi	r2,40
   40cd4:	e0bffb45 	stb	r2,-19(fp)
    uint8 lip[4]={192,168,0,1};
   40cd8:	00bff004 	movi	r2,-64
   40cdc:	e0bffb85 	stb	r2,-18(fp)
   40ce0:	00bfea04 	movi	r2,-88
   40ce4:	e0bffbc5 	stb	r2,-17(fp)
   40ce8:	e03ffc05 	stb	zero,-16(fp)
   40cec:	00800044 	movi	r2,1
   40cf0:	e0bffc45 	stb	r2,-15(fp)
    uint8 sub[4]={255,255,255,0};
   40cf4:	00bfffc4 	movi	r2,-1
   40cf8:	e0bffc85 	stb	r2,-14(fp)
   40cfc:	00bfffc4 	movi	r2,-1
   40d00:	e0bffcc5 	stb	r2,-13(fp)
   40d04:	00bfffc4 	movi	r2,-1
   40d08:	e0bffd05 	stb	r2,-12(fp)
   40d0c:	e03ffd45 	stb	zero,-11(fp)
    uint8 gw[4]={192,168,0,1};
   40d10:	00bff004 	movi	r2,-64
   40d14:	e0bffd85 	stb	r2,-10(fp)
   40d18:	00bfea04 	movi	r2,-88
   40d1c:	e0bffdc5 	stb	r2,-9(fp)
   40d20:	e03ffe05 	stb	zero,-8(fp)
   40d24:	00800044 	movi	r2,1
   40d28:	e0bffe45 	stb	r2,-7(fp)
    uint8 dns[4]={8,8,8,8};
   40d2c:	00800204 	movi	r2,8
   40d30:	e0bffe85 	stb	r2,-6(fp)
   40d34:	00800204 	movi	r2,8
   40d38:	e0bffec5 	stb	r2,-5(fp)
   40d3c:	00800204 	movi	r2,8
   40d40:	e0bfff05 	stb	r2,-4(fp)
   40d44:	00800204 	movi	r2,8
   40d48:	e0bfff45 	stb	r2,-3(fp)
    memcpy(ConfigMsg.lip, lip, 4);
   40d4c:	008001b4 	movhi	r2,6
   40d50:	10b68304 	addi	r2,r2,-9716
   40d54:	e0fffb83 	ldbu	r3,-18(fp)
   40d58:	10c00305 	stb	r3,12(r2)
   40d5c:	e0fffbc3 	ldbu	r3,-17(fp)
   40d60:	10c00345 	stb	r3,13(r2)
   40d64:	e0fffc03 	ldbu	r3,-16(fp)
   40d68:	10c00385 	stb	r3,14(r2)
   40d6c:	e0fffc43 	ldbu	r3,-15(fp)
   40d70:	10c003c5 	stb	r3,15(r2)
    memcpy(ConfigMsg.sub, sub, 4);
   40d74:	008001b4 	movhi	r2,6
   40d78:	10b68304 	addi	r2,r2,-9716
   40d7c:	e0fffc83 	ldbu	r3,-14(fp)
   40d80:	10c00405 	stb	r3,16(r2)
   40d84:	e0fffcc3 	ldbu	r3,-13(fp)
   40d88:	10c00445 	stb	r3,17(r2)
   40d8c:	e0fffd03 	ldbu	r3,-12(fp)
   40d90:	10c00485 	stb	r3,18(r2)
   40d94:	e0fffd43 	ldbu	r3,-11(fp)
   40d98:	10c004c5 	stb	r3,19(r2)
    memcpy(ConfigMsg.gw,  gw, 4);
   40d9c:	008001b4 	movhi	r2,6
   40da0:	10b68304 	addi	r2,r2,-9716
   40da4:	e0fffd83 	ldbu	r3,-10(fp)
   40da8:	10c00505 	stb	r3,20(r2)
   40dac:	e0fffdc3 	ldbu	r3,-9(fp)
   40db0:	10c00545 	stb	r3,21(r2)
   40db4:	e0fffe03 	ldbu	r3,-8(fp)
   40db8:	10c00585 	stb	r3,22(r2)
   40dbc:	e0fffe43 	ldbu	r3,-7(fp)
   40dc0:	10c005c5 	stb	r3,23(r2)
    memcpy(ConfigMsg.mac, mac,6);
   40dc4:	008001b4 	movhi	r2,6
   40dc8:	10b68304 	addi	r2,r2,-9716
   40dcc:	e0fffa03 	ldbu	r3,-24(fp)
   40dd0:	10c00105 	stb	r3,4(r2)
   40dd4:	e0fffa43 	ldbu	r3,-23(fp)
   40dd8:	10c00145 	stb	r3,5(r2)
   40ddc:	e0fffa83 	ldbu	r3,-22(fp)
   40de0:	10c00185 	stb	r3,6(r2)
   40de4:	e0fffac3 	ldbu	r3,-21(fp)
   40de8:	10c001c5 	stb	r3,7(r2)
   40dec:	e0fffb03 	ldbu	r3,-20(fp)
   40df0:	10c00205 	stb	r3,8(r2)
   40df4:	e0fffb43 	ldbu	r3,-19(fp)
   40df8:	10c00245 	stb	r3,9(r2)
    memcpy(ConfigMsg.dns,dns,4);
   40dfc:	008001b4 	movhi	r2,6
   40e00:	10b68304 	addi	r2,r2,-9716
   40e04:	e0fffe83 	ldbu	r3,-6(fp)
   40e08:	10c00605 	stb	r3,24(r2)
   40e0c:	e0fffec3 	ldbu	r3,-5(fp)
   40e10:	10c00645 	stb	r3,25(r2)
   40e14:	e0ffff03 	ldbu	r3,-4(fp)
   40e18:	10c00685 	stb	r3,26(r2)
   40e1c:	e0ffff43 	ldbu	r3,-3(fp)
   40e20:	10c006c5 	stb	r3,27(r2)

    ConfigMsg.dhcp=0;
   40e24:	008001b4 	movhi	r2,6
   40e28:	10b68304 	addi	r2,r2,-9716
   40e2c:	10000705 	stb	zero,28(r2)
    ConfigMsg.debug=1;
   40e30:	008001b4 	movhi	r2,6
   40e34:	10b68304 	addi	r2,r2,-9716
   40e38:	00c00044 	movi	r3,1
   40e3c:	10c00745 	stb	r3,29(r2)
    ConfigMsg.fw_len=0;
   40e40:	008001b4 	movhi	r2,6
   40e44:	10b68304 	addi	r2,r2,-9716
   40e48:	10c00783 	ldbu	r3,30(r2)
   40e4c:	1806703a 	and	r3,r3,zero
   40e50:	10c00785 	stb	r3,30(r2)
   40e54:	10c007c3 	ldbu	r3,31(r2)
   40e58:	1806703a 	and	r3,r3,zero
   40e5c:	10c007c5 	stb	r3,31(r2)

    ConfigMsg.state=NORMAL_STATE;
   40e60:	008001b4 	movhi	r2,6
   40e64:	10b68304 	addi	r2,r2,-9716
   40e68:	10000805 	stb	zero,32(r2)
    ConfigMsg.sw_ver[0]=FW_VER_HIGH;
   40e6c:	008001b4 	movhi	r2,6
   40e70:	10b68304 	addi	r2,r2,-9716
   40e74:	00c00044 	movi	r3,1
   40e78:	10c00285 	stb	r3,10(r2)
    ConfigMsg.sw_ver[1]=FW_VER_LOW;
   40e7c:	008001b4 	movhi	r2,6
   40e80:	10b68304 	addi	r2,r2,-9716
   40e84:	100002c5 	stb	zero,11(r2)

}
   40e88:	0001883a 	nop
   40e8c:	e037883a 	mov	sp,fp
   40e90:	df000017 	ldw	fp,0(sp)
   40e94:	dec00104 	addi	sp,sp,4
   40e98:	f800283a 	ret

00040e9c <hex2ascii>:
queue_item_t LaserData[2048];
Queue LaserDataQueue;


static inline unsigned int hex2ascii(unsigned int data)
{
   40e9c:	defffa04 	addi	sp,sp,-24
   40ea0:	df000515 	stw	fp,20(sp)
   40ea4:	df000504 	addi	fp,sp,20
   40ea8:	e13fff15 	stw	r4,-4(fp)
    int tmp31_24 = ((data>>12)&0x0f);
   40eac:	e0bfff17 	ldw	r2,-4(fp)
   40eb0:	1004d33a 	srli	r2,r2,12
   40eb4:	108003cc 	andi	r2,r2,15
   40eb8:	e0bffb15 	stw	r2,-20(fp)
    int tmp23_16 = ((data>> 8)&0x0f);
   40ebc:	e0bfff17 	ldw	r2,-4(fp)
   40ec0:	1004d23a 	srli	r2,r2,8
   40ec4:	108003cc 	andi	r2,r2,15
   40ec8:	e0bffc15 	stw	r2,-16(fp)
    int tmp15_08 = ((data>> 4)&0x0f);
   40ecc:	e0bfff17 	ldw	r2,-4(fp)
   40ed0:	1004d13a 	srli	r2,r2,4
   40ed4:	108003cc 	andi	r2,r2,15
   40ed8:	e0bffd15 	stw	r2,-12(fp)
    int tmp07_00 = ((data>> 0)&0x0f);
   40edc:	e0bfff17 	ldw	r2,-4(fp)
   40ee0:	108003cc 	andi	r2,r2,15
   40ee4:	e0bffe15 	stw	r2,-8(fp)

    tmp31_24 =  ( (tmp31_24 >= 0) && (tmp31_24 <= 9) ) ? tmp31_24 + 0x30 : tmp31_24 + 0x37;
   40ee8:	e0bffb17 	ldw	r2,-20(fp)
   40eec:	10000616 	blt	r2,zero,40f08 <hex2ascii+0x6c>
   40ef0:	e0bffb17 	ldw	r2,-20(fp)
   40ef4:	10800288 	cmpgei	r2,r2,10
   40ef8:	1000031e 	bne	r2,zero,40f08 <hex2ascii+0x6c>
   40efc:	e0bffb17 	ldw	r2,-20(fp)
   40f00:	10800c04 	addi	r2,r2,48
   40f04:	00000206 	br	40f10 <hex2ascii+0x74>
   40f08:	e0bffb17 	ldw	r2,-20(fp)
   40f0c:	10800dc4 	addi	r2,r2,55
   40f10:	e0bffb15 	stw	r2,-20(fp)
    tmp23_16 =  ( (tmp23_16 >= 0) && (tmp23_16 <= 9) ) ? tmp23_16 + 0x30 : tmp23_16 + 0x37;
   40f14:	e0bffc17 	ldw	r2,-16(fp)
   40f18:	10000616 	blt	r2,zero,40f34 <hex2ascii+0x98>
   40f1c:	e0bffc17 	ldw	r2,-16(fp)
   40f20:	10800288 	cmpgei	r2,r2,10
   40f24:	1000031e 	bne	r2,zero,40f34 <hex2ascii+0x98>
   40f28:	e0bffc17 	ldw	r2,-16(fp)
   40f2c:	10800c04 	addi	r2,r2,48
   40f30:	00000206 	br	40f3c <hex2ascii+0xa0>
   40f34:	e0bffc17 	ldw	r2,-16(fp)
   40f38:	10800dc4 	addi	r2,r2,55
   40f3c:	e0bffc15 	stw	r2,-16(fp)
    tmp15_08 =  ( (tmp15_08 >= 0) && (tmp15_08 <= 9) ) ? tmp15_08 + 0x30 : tmp15_08 + 0x37;
   40f40:	e0bffd17 	ldw	r2,-12(fp)
   40f44:	10000616 	blt	r2,zero,40f60 <hex2ascii+0xc4>
   40f48:	e0bffd17 	ldw	r2,-12(fp)
   40f4c:	10800288 	cmpgei	r2,r2,10
   40f50:	1000031e 	bne	r2,zero,40f60 <hex2ascii+0xc4>
   40f54:	e0bffd17 	ldw	r2,-12(fp)
   40f58:	10800c04 	addi	r2,r2,48
   40f5c:	00000206 	br	40f68 <hex2ascii+0xcc>
   40f60:	e0bffd17 	ldw	r2,-12(fp)
   40f64:	10800dc4 	addi	r2,r2,55
   40f68:	e0bffd15 	stw	r2,-12(fp)
    tmp07_00 =  ( (tmp07_00 >= 0) && (tmp07_00 <= 9) ) ? tmp07_00 + 0x30 : tmp07_00 + 0x37;
   40f6c:	e0bffe17 	ldw	r2,-8(fp)
   40f70:	10000616 	blt	r2,zero,40f8c <hex2ascii+0xf0>
   40f74:	e0bffe17 	ldw	r2,-8(fp)
   40f78:	10800288 	cmpgei	r2,r2,10
   40f7c:	1000031e 	bne	r2,zero,40f8c <hex2ascii+0xf0>
   40f80:	e0bffe17 	ldw	r2,-8(fp)
   40f84:	10800c04 	addi	r2,r2,48
   40f88:	00000206 	br	40f94 <hex2ascii+0xf8>
   40f8c:	e0bffe17 	ldw	r2,-8(fp)
   40f90:	10800dc4 	addi	r2,r2,55
   40f94:	e0bffe15 	stw	r2,-8(fp)

    return (tmp31_24<<24) + (tmp23_16<<16) + (tmp15_08<<8) + (tmp07_00<<0);
   40f98:	e0bffb17 	ldw	r2,-20(fp)
   40f9c:	1006963a 	slli	r3,r2,24
   40fa0:	e0bffc17 	ldw	r2,-16(fp)
   40fa4:	1004943a 	slli	r2,r2,16
   40fa8:	1887883a 	add	r3,r3,r2
   40fac:	e0bffd17 	ldw	r2,-12(fp)
   40fb0:	1004923a 	slli	r2,r2,8
   40fb4:	1887883a 	add	r3,r3,r2
   40fb8:	e0bffe17 	ldw	r2,-8(fp)
   40fbc:	1885883a 	add	r2,r3,r2
}
   40fc0:	e037883a 	mov	sp,fp
   40fc4:	df000017 	ldw	fp,0(sp)
   40fc8:	dec00104 	addi	sp,sp,4
   40fcc:	f800283a 	ret

00040fd0 <big_swap_little>:

unsigned int big_swap_little(unsigned int data)
{
   40fd0:	defffe04 	addi	sp,sp,-8
   40fd4:	df000115 	stw	fp,4(sp)
   40fd8:	df000104 	addi	fp,sp,4
   40fdc:	e13fff15 	stw	r4,-4(fp)
    data = ((data & 0xff) << 24) | ((data & 0xff00) << 8) | ((data & 0xff0000) >> 8) | ((data & 0xff000000) >> 24);
   40fe0:	e0bfff17 	ldw	r2,-4(fp)
   40fe4:	1006963a 	slli	r3,r2,24
   40fe8:	e0bfff17 	ldw	r2,-4(fp)
   40fec:	10bfc00c 	andi	r2,r2,65280
   40ff0:	1004923a 	slli	r2,r2,8
   40ff4:	1886b03a 	or	r3,r3,r2
   40ff8:	e0bfff17 	ldw	r2,-4(fp)
   40ffc:	10803fec 	andhi	r2,r2,255
   41000:	1004d23a 	srli	r2,r2,8
   41004:	1886b03a 	or	r3,r3,r2
   41008:	e0bfff17 	ldw	r2,-4(fp)
   4100c:	1004d63a 	srli	r2,r2,24
   41010:	1884b03a 	or	r2,r3,r2
   41014:	e0bfff15 	stw	r2,-4(fp)
    return data;
   41018:	e0bfff17 	ldw	r2,-4(fp)
}
   4101c:	e037883a 	mov	sp,fp
   41020:	df000017 	ldw	fp,0(sp)
   41024:	dec00104 	addi	sp,sp,4
   41028:	f800283a 	ret

0004102c <fpga_is_has_data>:

bool fpga_is_has_data()
{
   4102c:	defffd04 	addi	sp,sp,-12
   41030:	dfc00215 	stw	ra,8(sp)
   41034:	df000115 	stw	fp,4(sp)
   41038:	df000104 	addi	fp,sp,4
    int num = altera_avalon_fifo_read_level(LASER_FIFO_IN_CSR_BASE);
   4103c:	01000234 	movhi	r4,8
   41040:	21084804 	addi	r4,r4,8480
   41044:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   41048:	e0bfff15 	stw	r2,-4(fp)

    // fifo 空， empty = 1
    if(num > 0)
   4104c:	e0bfff17 	ldw	r2,-4(fp)
   41050:	0080020e 	bge	zero,r2,4105c <fpga_is_has_data+0x30>
        return true;
   41054:	00800044 	movi	r2,1
   41058:	00000106 	br	41060 <fpga_is_has_data+0x34>
    else
        return false;
   4105c:	0005883a 	mov	r2,zero
}
   41060:	e037883a 	mov	sp,fp
   41064:	dfc00117 	ldw	ra,4(sp)
   41068:	df000017 	ldw	fp,0(sp)
   4106c:	dec00204 	addi	sp,sp,8
   41070:	f800283a 	ret

00041074 <read_fpga_data>:

// 从FIFO中读出一个数据
inline unsigned int read_fpga_data()
{
   41074:	defffd04 	addi	sp,sp,-12
   41078:	dfc00215 	stw	ra,8(sp)
   4107c:	df000115 	stw	fp,4(sp)
   41080:	df000104 	addi	fp,sp,4
    unsigned int data = altera_avalon_fifo_read_fifo(LASER_FIFO_OUT_BASE, LASER_FIFO_IN_CSR_BASE);
   41084:	01400234 	movhi	r5,8
   41088:	29484804 	addi	r5,r5,8480
   4108c:	01000234 	movhi	r4,8
   41090:	21087404 	addi	r4,r4,8656
   41094:	004adc80 	call	4adc8 <altera_avalon_fifo_read_fifo>
   41098:	e0bfff15 	stw	r2,-4(fp)
    return (data >> 16) + (data << 16);
   4109c:	e0bfff17 	ldw	r2,-4(fp)
   410a0:	1004143a 	roli	r2,r2,16
}
   410a4:	e037883a 	mov	sp,fp
   410a8:	dfc00117 	ldw	ra,4(sp)
   410ac:	df000017 	ldw	fp,0(sp)
   410b0:	dec00204 	addi	sp,sp,8
   410b4:	f800283a 	ret

000410b8 <fpga2nios_parse>:

int fpga2nios_parse()
{
   410b8:	defff604 	addi	sp,sp,-40
   410bc:	dfc00915 	stw	ra,36(sp)
   410c0:	df000815 	stw	fp,32(sp)
   410c4:	df000804 	addi	fp,sp,32
    unsigned int i;
    unsigned int num = 0;
   410c8:	e03ffa15 	stw	zero,-24(fp)
    unsigned int distance;
    unsigned int gray;
    char buf[10];

    {
        while(!queue_is_empty(&LaserDataQueue))
   410cc:	00000f06 	br	4110c <fpga2nios_parse+0x54>
        {
        	recv_data = queue_pop(&LaserDataQueue);
   410d0:	010001b4 	movhi	r4,6
   410d4:	21380104 	addi	r4,r4,-8188
   410d8:	00457480 	call	45748 <queue_pop>
   410dc:	e0bff915 	stw	r2,-28(fp)
			if(recv_data >> 16 == FRAME_HEAD)
   410e0:	e0bff917 	ldw	r2,-28(fp)
   410e4:	1004d43a 	srli	r2,r2,16
   410e8:	10848d18 	cmpnei	r2,r2,4660
   410ec:	1000071e 	bne	r2,zero,4110c <fpga2nios_parse+0x54>
			{
				fpga2nios_data.frame_head = (recv_data >> 16) & 0xffff;
   410f0:	e0bff917 	ldw	r2,-28(fp)
   410f4:	1004d43a 	srli	r2,r2,16
   410f8:	1007883a 	mov	r3,r2
   410fc:	008001b4 	movhi	r2,6
   41100:	10b80604 	addi	r2,r2,-8168
   41104:	10c0000d 	sth	r3,0(r2)
				break;
   41108:	00000606 	br	41124 <fpga2nios_parse+0x6c>
    unsigned int distance;
    unsigned int gray;
    char buf[10];

    {
        while(!queue_is_empty(&LaserDataQueue))
   4110c:	010001b4 	movhi	r4,6
   41110:	21380104 	addi	r4,r4,-8188
   41114:	00458a40 	call	458a4 <queue_is_empty>
   41118:	1080005c 	xori	r2,r2,1
   4111c:	10803fcc 	andi	r2,r2,255
   41120:	103feb1e 	bne	r2,zero,410d0 <__alt_mem_epcs_flash+0xfffc00d0>
				fpga2nios_data.frame_head = (recv_data >> 16) & 0xffff;
				break;
			}
        }

        fpga2nios_data.command = recv_data & 0xffff;
   41124:	e0bff917 	ldw	r2,-28(fp)
   41128:	1007883a 	mov	r3,r2
   4112c:	008001b4 	movhi	r2,6
   41130:	10b80604 	addi	r2,r2,-8168
   41134:	10c0008d 	sth	r3,2(r2)
        fpga2nios_data.data_len = queue_pop(&LaserDataQueue);
   41138:	010001b4 	movhi	r4,6
   4113c:	21380104 	addi	r4,r4,-8188
   41140:	00457480 	call	45748 <queue_pop>
   41144:	1007883a 	mov	r3,r2
   41148:	008001b4 	movhi	r2,6
   4114c:	10b80604 	addi	r2,r2,-8168
   41150:	10c00115 	stw	r3,4(r2)
        if(fpga2nios_data.command == DISTANCE_DATA)
   41154:	008001b4 	movhi	r2,6
   41158:	10b80604 	addi	r2,r2,-8168
   4115c:	1080008b 	ldhu	r2,2(r2)
   41160:	10ffffcc 	andi	r3,r2,65535
   41164:	00a800d4 	movui	r2,40963
   41168:	1880951e 	bne	r3,r2,413c0 <fpga2nios_parse+0x308>
        {
            CycleData.distance_len = 0;
   4116c:	008001b4 	movhi	r2,6
   41170:	10802104 	addi	r2,r2,132
   41174:	10000115 	stw	zero,4(r2)
            CycleData.gray_len = 0;
   41178:	008001b4 	movhi	r2,6
   4117c:	10802104 	addi	r2,r2,132
   41180:	10000215 	stw	zero,8(r2)
            for(i = 0; i < fpga2nios_data.data_len; i++)
   41184:	e03ff815 	stw	zero,-32(fp)
   41188:	00004a06 	br	412b4 <fpga2nios_parse+0x1fc>
            {
                recv_data = queue_pop(&LaserDataQueue);
   4118c:	010001b4 	movhi	r4,6
   41190:	21380104 	addi	r4,r4,-8188
   41194:	00457480 	call	45748 <queue_pop>
   41198:	e0bff915 	stw	r2,-28(fp)
                distance = hex2ascii(recv_data);
   4119c:	e13ff917 	ldw	r4,-28(fp)
   411a0:	0040e9c0 	call	40e9c <hex2ascii>
   411a4:	e0bffb15 	stw	r2,-20(fp)

                buf[0] = 0x20;
   411a8:	00800804 	movi	r2,32
   411ac:	e0bffd05 	stb	r2,-12(fp)

                buf[1] = (distance >> 24) & 0xff;
   411b0:	e0bffb17 	ldw	r2,-20(fp)
   411b4:	1004d63a 	srli	r2,r2,24
   411b8:	e0bffd45 	stb	r2,-11(fp)
                buf[2] = (distance >> 16) & 0xff;
   411bc:	e0bffb17 	ldw	r2,-20(fp)
   411c0:	1004d43a 	srli	r2,r2,16
   411c4:	e0bffd85 	stb	r2,-10(fp)
                buf[3] = (distance >> 8) & 0xff;
   411c8:	e0bffb17 	ldw	r2,-20(fp)
   411cc:	1004d23a 	srli	r2,r2,8
   411d0:	e0bffdc5 	stb	r2,-9(fp)
                buf[4] = (distance >> 0) & 0xff;
   411d4:	e0bffb17 	ldw	r2,-20(fp)
   411d8:	e0bffe05 	stb	r2,-8(fp)
                num = 5;
   411dc:	00800144 	movi	r2,5
   411e0:	e0bffa15 	stw	r2,-24(fp)
                
                // num = hex2string(recv_data, buf);
                memcpy(CycleData.distance_data + CycleData.distance_len, buf, num);  // ascii码格式的  +距离数据              
   411e4:	008001b4 	movhi	r2,6
   411e8:	10802104 	addi	r2,r2,132
   411ec:	10c00117 	ldw	r3,4(r2)
   411f0:	008001b4 	movhi	r2,6
   411f4:	10802404 	addi	r2,r2,144
   411f8:	1885883a 	add	r2,r3,r2
   411fc:	e0fffd04 	addi	r3,fp,-12
   41200:	e1bffa17 	ldw	r6,-24(fp)
   41204:	180b883a 	mov	r5,r3
   41208:	1009883a 	mov	r4,r2
   4120c:	00493d40 	call	493d4 <memcpy>
                CycleData.distance_len += num;
   41210:	008001b4 	movhi	r2,6
   41214:	10802104 	addi	r2,r2,132
   41218:	10c00117 	ldw	r3,4(r2)
   4121c:	e0bffa17 	ldw	r2,-24(fp)
   41220:	1887883a 	add	r3,r3,r2
   41224:	008001b4 	movhi	r2,6
   41228:	10802104 	addi	r2,r2,132
   4122c:	10c00115 	stw	r3,4(r2)

                gray = hex2ascii((recv_data>>16) & 0xffff);
   41230:	e0bff917 	ldw	r2,-28(fp)
   41234:	1004d43a 	srli	r2,r2,16
   41238:	1009883a 	mov	r4,r2
   4123c:	0040e9c0 	call	40e9c <hex2ascii>
   41240:	e0bffc15 	stw	r2,-16(fp)
                buf[0] = 0x20;
   41244:	00800804 	movi	r2,32
   41248:	e0bffd05 	stb	r2,-12(fp)
                buf[1] = (gray >> 8) & 0xff;
   4124c:	e0bffc17 	ldw	r2,-16(fp)
   41250:	1004d23a 	srli	r2,r2,8
   41254:	e0bffd45 	stb	r2,-11(fp)
                buf[2] = (gray >> 0) & 0xff;
   41258:	e0bffc17 	ldw	r2,-16(fp)
   4125c:	e0bffd85 	stb	r2,-10(fp)
                memcpy(CycleData.gray_data + CycleData.gray_len, buf, 3);  
   41260:	008001b4 	movhi	r2,6
   41264:	10802104 	addi	r2,r2,132
   41268:	10c00217 	ldw	r3,8(r2)
   4126c:	008001b4 	movhi	r2,6
   41270:	108419c4 	addi	r2,r2,4199
   41274:	1885883a 	add	r2,r3,r2
   41278:	e0fffd04 	addi	r3,fp,-12
   4127c:	018000c4 	movi	r6,3
   41280:	180b883a 	mov	r5,r3
   41284:	1009883a 	mov	r4,r2
   41288:	00493d40 	call	493d4 <memcpy>
                CycleData.gray_len += 3;
   4128c:	008001b4 	movhi	r2,6
   41290:	10802104 	addi	r2,r2,132
   41294:	10800217 	ldw	r2,8(r2)
   41298:	10c000c4 	addi	r3,r2,3
   4129c:	008001b4 	movhi	r2,6
   412a0:	10802104 	addi	r2,r2,132
   412a4:	10c00215 	stw	r3,8(r2)
        fpga2nios_data.data_len = queue_pop(&LaserDataQueue);
        if(fpga2nios_data.command == DISTANCE_DATA)
        {
            CycleData.distance_len = 0;
            CycleData.gray_len = 0;
            for(i = 0; i < fpga2nios_data.data_len; i++)
   412a8:	e0bff817 	ldw	r2,-32(fp)
   412ac:	10800044 	addi	r2,r2,1
   412b0:	e0bff815 	stw	r2,-32(fp)
   412b4:	008001b4 	movhi	r2,6
   412b8:	10b80604 	addi	r2,r2,-8168
   412bc:	10800117 	ldw	r2,4(r2)
   412c0:	e0fff817 	ldw	r3,-32(fp)
   412c4:	18bfb136 	bltu	r3,r2,4118c <__alt_mem_epcs_flash+0xfffc018c>
                buf[1] = (gray >> 8) & 0xff;
                buf[2] = (gray >> 0) & 0xff;
                memcpy(CycleData.gray_data + CycleData.gray_len, buf, 3);  
                CycleData.gray_len += 3;
            }
            recv_data = queue_pop(&LaserDataQueue);
   412c8:	010001b4 	movhi	r4,6
   412cc:	21380104 	addi	r4,r4,-8188
   412d0:	00457480 	call	45748 <queue_pop>
   412d4:	e0bff915 	stw	r2,-28(fp)
            fpga2nios_data.checksum = recv_data;
   412d8:	008001b4 	movhi	r2,6
   412dc:	10b80604 	addi	r2,r2,-8168
   412e0:	e0fff917 	ldw	r3,-28(fp)
   412e4:	10c01615 	stw	r3,88(r2)

            if((fpga2nios_data.checksum & 0xfffffff) == 0xeeeeeee)  // bit[27:0], bit[31:28]作为FPGA上传的区域报警标志
   412e8:	008001b4 	movhi	r2,6
   412ec:	10b80604 	addi	r2,r2,-8168
   412f0:	10c01617 	ldw	r3,88(r2)
   412f4:	00840034 	movhi	r2,4096
   412f8:	10bfffc4 	addi	r2,r2,-1
   412fc:	1886703a 	and	r3,r3,r2
   41300:	0083bbf4 	movhi	r2,3823
   41304:	10bbbb84 	addi	r2,r2,-4370
   41308:	18801c1e 	bne	r3,r2,4137c <fpga2nios_parse+0x2c4>
            {
                if(SysPara.board_type == 1)       // NPN型, 报警时FPGA IO输出0, 外部才能输出为高
   4130c:	008001b4 	movhi	r2,6
   41310:	10a56c04 	addi	r2,r2,-27216
   41314:	10802c17 	ldw	r2,176(r2)
   41318:	10800058 	cmpnei	r2,r2,1
   4131c:	10000a1e 	bne	r2,zero,41348 <fpga2nios_parse+0x290>
                    sys_warn.region_alarm = ~(fpga2nios_data.checksum >> 28) & 0x07;
   41320:	008001b4 	movhi	r2,6
   41324:	10b80604 	addi	r2,r2,-8168
   41328:	10801617 	ldw	r2,88(r2)
   4132c:	1004d73a 	srli	r2,r2,28
   41330:	0084303a 	nor	r2,zero,r2
   41334:	10c001cc 	andi	r3,r2,7
   41338:	008001b4 	movhi	r2,6
   4133c:	10b46104 	addi	r2,r2,-11900
   41340:	10c00415 	stw	r3,16(r2)
   41344:	00000806 	br	41368 <fpga2nios_parse+0x2b0>
                else
                    sys_warn.region_alarm = (fpga2nios_data.checksum >> 28) & 0x07;
   41348:	008001b4 	movhi	r2,6
   4134c:	10b80604 	addi	r2,r2,-8168
   41350:	10801617 	ldw	r2,88(r2)
   41354:	1004d73a 	srli	r2,r2,28
   41358:	10c001cc 	andi	r3,r2,7
   4135c:	008001b4 	movhi	r2,6
   41360:	10b46104 	addi	r2,r2,-11900
   41364:	10c00415 	stw	r3,16(r2)

                CycleData.pos_finish = true;
   41368:	008001b4 	movhi	r2,6
   4136c:	10802104 	addi	r2,r2,132
   41370:	00c00044 	movi	r3,1
   41374:	10c00005 	stb	r3,0(r2)
   41378:	00000d06 	br	413b0 <fpga2nios_parse+0x2f8>
            }
            else
            {
                CycleData.pos_finish = false;
   4137c:	008001b4 	movhi	r2,6
   41380:	10802104 	addi	r2,r2,132
   41384:	10000005 	stb	zero,0(r2)
                memset(CycleData.distance_data, 0, sizeof(CycleData.distance_data));
   41388:	0183f5c4 	movi	r6,4055
   4138c:	000b883a 	mov	r5,zero
   41390:	010001b4 	movhi	r4,6
   41394:	21002404 	addi	r4,r4,144
   41398:	004951c0 	call	4951c <memset>
                memset(CycleData.gray_data, 0, sizeof(CycleData.gray_data));
   4139c:	0183f5c4 	movi	r6,4055
   413a0:	000b883a 	mov	r5,zero
   413a4:	010001b4 	movhi	r4,6
   413a8:	210419c4 	addi	r4,r4,4199
   413ac:	004951c0 	call	4951c <memset>
            }
            queue_clear(&LaserDataQueue);
   413b0:	010001b4 	movhi	r4,6
   413b4:	21380104 	addi	r4,r4,-8188
   413b8:	004568c0 	call	4568c <queue_clear>
   413bc:	0000fa06 	br	417a8 <fpga2nios_parse+0x6f0>
        }
        else if(fpga2nios_data.command == UP_FPGA_STATUS)
   413c0:	008001b4 	movhi	r2,6
   413c4:	10b80604 	addi	r2,r2,-8168
   413c8:	1080008b 	ldhu	r2,2(r2)
   413cc:	10ffffcc 	andi	r3,r2,65535
   413d0:	00b04014 	movui	r2,49408
   413d4:	1880f41e 	bne	r3,r2,417a8 <fpga2nios_parse+0x6f0>
        {
            sys_warn.len %= 5;
   413d8:	008001b4 	movhi	r2,6
   413dc:	10b46104 	addi	r2,r2,-11900
   413e0:	10800517 	ldw	r2,20(r2)
   413e4:	01400144 	movi	r5,5
   413e8:	1009883a 	mov	r4,r2
   413ec:	004937c0 	call	4937c <__umodsi3>
   413f0:	1007883a 	mov	r3,r2
   413f4:	008001b4 	movhi	r2,6
   413f8:	10b46104 	addi	r2,r2,-11900
   413fc:	10c00515 	stw	r3,20(r2)
            // for(i = 0; i < fpga_data.data_len; i++)
            {
                recv_data = queue_pop(&LaserDataQueue);
   41400:	010001b4 	movhi	r4,6
   41404:	21380104 	addi	r4,r4,-8188
   41408:	00457480 	call	45748 <queue_pop>
   4140c:	e0bff915 	stw	r2,-28(fp)
                // CycleData.fpga_status[i] = recv_data;
                if(sys_warn.motor_low_speed_alarm == 0x00)
   41410:	008001b4 	movhi	r2,6
   41414:	10b46104 	addi	r2,r2,-11900
   41418:	10800017 	ldw	r2,0(r2)
   4141c:	10000b1e 	bne	r2,zero,4144c <fpga2nios_parse+0x394>
                    sys_warn.motor_cycle_cnt[sys_warn.len] = recv_data;
   41420:	008001b4 	movhi	r2,6
   41424:	10b46104 	addi	r2,r2,-11900
   41428:	10c00517 	ldw	r3,20(r2)
   4142c:	008001b4 	movhi	r2,6
   41430:	10b46104 	addi	r2,r2,-11900
   41434:	18c00184 	addi	r3,r3,6
   41438:	18c7883a 	add	r3,r3,r3
   4143c:	18c7883a 	add	r3,r3,r3
   41440:	10c5883a 	add	r2,r2,r3
   41444:	e0fff917 	ldw	r3,-28(fp)
   41448:	10c00015 	stw	r3,0(r2)
                SysPara.motor_real_speed = recv_data;
   4144c:	008001b4 	movhi	r2,6
   41450:	10a56c04 	addi	r2,r2,-27216
   41454:	e0fff917 	ldw	r3,-28(fp)
   41458:	10c02115 	stw	r3,132(r2)

                recv_data = queue_pop(&LaserDataQueue);
   4145c:	010001b4 	movhi	r4,6
   41460:	21380104 	addi	r4,r4,-8188
   41464:	00457480 	call	45748 <queue_pop>
   41468:	e0bff915 	stw	r2,-28(fp)
                SysPara.zero_value = recv_data & 0xffff;
   4146c:	e0bff917 	ldw	r2,-28(fp)
   41470:	10ffffcc 	andi	r3,r2,65535
   41474:	008001b4 	movhi	r2,6
   41478:	10a56c04 	addi	r2,r2,-27216
   4147c:	10c01d15 	stw	r3,116(r2)

                recv_data = queue_pop(&LaserDataQueue);
   41480:	010001b4 	movhi	r4,6
   41484:	21380104 	addi	r4,r4,-8188
   41488:	00457480 	call	45748 <queue_pop>
   4148c:	e0bff915 	stw	r2,-28(fp)
                if(sys_warn.window_dust_alarm == 0x00)
   41490:	008001b4 	movhi	r2,6
   41494:	10b46104 	addi	r2,r2,-11900
   41498:	10800217 	ldw	r2,8(r2)
   4149c:	10000b1e 	bne	r2,zero,414cc <fpga2nios_parse+0x414>
                    sys_warn.dust_cnt[sys_warn.len] = recv_data;
   414a0:	008001b4 	movhi	r2,6
   414a4:	10b46104 	addi	r2,r2,-11900
   414a8:	10c00517 	ldw	r3,20(r2)
   414ac:	008001b4 	movhi	r2,6
   414b0:	10b46104 	addi	r2,r2,-11900
   414b4:	18c00404 	addi	r3,r3,16
   414b8:	18c7883a 	add	r3,r3,r3
   414bc:	18c7883a 	add	r3,r3,r3
   414c0:	10c5883a 	add	r2,r2,r3
   414c4:	e0fff917 	ldw	r3,-28(fp)
   414c8:	10c00015 	stw	r3,0(r2)
                SysPara.placeholer1 = recv_data;
   414cc:	008001b4 	movhi	r2,6
   414d0:	10a56c04 	addi	r2,r2,-27216
   414d4:	e0fff917 	ldw	r3,-28(fp)
   414d8:	10c01315 	stw	r3,76(r2)

                recv_data = queue_pop(&LaserDataQueue); // 最高位作为上传状态
   414dc:	010001b4 	movhi	r4,6
   414e0:	21380104 	addi	r4,r4,-8188
   414e4:	00457480 	call	45748 <queue_pop>
   414e8:	e0bff915 	stw	r2,-28(fp)
                if(sys_warn.temp_out_alarm == 0x00)
   414ec:	008001b4 	movhi	r2,6
   414f0:	10b46104 	addi	r2,r2,-11900
   414f4:	10800317 	ldw	r2,12(r2)
   414f8:	10000c1e 	bne	r2,zero,4152c <fpga2nios_parse+0x474>
                    sys_warn.temp_value[sys_warn.len] = recv_data & 0xffff;
   414fc:	008001b4 	movhi	r2,6
   41500:	10b46104 	addi	r2,r2,-11900
   41504:	10c00517 	ldw	r3,20(r2)
   41508:	e0bff917 	ldw	r2,-28(fp)
   4150c:	113fffcc 	andi	r4,r2,65535
   41510:	008001b4 	movhi	r2,6
   41514:	10b46104 	addi	r2,r2,-11900
   41518:	18c00544 	addi	r3,r3,21
   4151c:	18c7883a 	add	r3,r3,r3
   41520:	18c7883a 	add	r3,r3,r3
   41524:	10c5883a 	add	r2,r2,r3
   41528:	11000015 	stw	r4,0(r2)
                SysPara.sys_temp = recv_data & 0xffff;
   4152c:	e0bff917 	ldw	r2,-28(fp)
   41530:	10ffffcc 	andi	r3,r2,65535
   41534:	008001b4 	movhi	r2,6
   41538:	10a56c04 	addi	r2,r2,-27216
   4153c:	10c01e15 	stw	r3,120(r2)
                SysPara.update_pos_flag = ((recv_data >> 31) & 0x01) ? true : false;
   41540:	e0bff917 	ldw	r2,-28(fp)
   41544:	1004d7fa 	srli	r2,r2,31
   41548:	1007883a 	mov	r3,r2
   4154c:	008001b4 	movhi	r2,6
   41550:	10a56c04 	addi	r2,r2,-27216
   41554:	10c00005 	stb	r3,0(r2)
                

                SysPara.zero_pulse_width = queue_pop(&LaserDataQueue);
   41558:	010001b4 	movhi	r4,6
   4155c:	21380104 	addi	r4,r4,-8188
   41560:	00457480 	call	45748 <queue_pop>
   41564:	1007883a 	mov	r3,r2
   41568:	008001b4 	movhi	r2,6
   4156c:	10a56c04 	addi	r2,r2,-27216
   41570:	10c02d15 	stw	r3,180(r2)
                if(sys_warn.ld_not_work_alarm == 0x00)
   41574:	008001b4 	movhi	r2,6
   41578:	10b46104 	addi	r2,r2,-11900
   4157c:	10800117 	ldw	r2,4(r2)
   41580:	10000d1e 	bne	r2,zero,415b8 <fpga2nios_parse+0x500>
                    sys_warn.zero_value[sys_warn.len] = SysPara.zero_pulse_width;
   41584:	008001b4 	movhi	r2,6
   41588:	10b46104 	addi	r2,r2,-11900
   4158c:	10c00517 	ldw	r3,20(r2)
   41590:	008001b4 	movhi	r2,6
   41594:	10a56c04 	addi	r2,r2,-27216
   41598:	11002d17 	ldw	r4,180(r2)
   4159c:	008001b4 	movhi	r2,6
   415a0:	10b46104 	addi	r2,r2,-11900
   415a4:	18c002c4 	addi	r3,r3,11
   415a8:	18c7883a 	add	r3,r3,r3
   415ac:	18c7883a 	add	r3,r3,r3
   415b0:	10c5883a 	add	r2,r2,r3
   415b4:	11000015 	stw	r4,0(r2)
            }
            sys_warn.len++;
   415b8:	008001b4 	movhi	r2,6
   415bc:	10b46104 	addi	r2,r2,-11900
   415c0:	10800517 	ldw	r2,20(r2)
   415c4:	10c00044 	addi	r3,r2,1
   415c8:	008001b4 	movhi	r2,6
   415cc:	10b46104 	addi	r2,r2,-11900
   415d0:	10c00515 	stw	r3,20(r2)
            recv_data = queue_pop(&LaserDataQueue);
   415d4:	010001b4 	movhi	r4,6
   415d8:	21380104 	addi	r4,r4,-8188
   415dc:	00457480 	call	45748 <queue_pop>
   415e0:	e0bff915 	stw	r2,-28(fp)
            fpga2nios_data.checksum = recv_data;
   415e4:	008001b4 	movhi	r2,6
   415e8:	10b80604 	addi	r2,r2,-8168
   415ec:	e0fff917 	ldw	r3,-28(fp)
   415f0:	10c01615 	stw	r3,88(r2)
            if(fpga2nios_data.checksum == 0xeeeeeeee)
   415f4:	008001b4 	movhi	r2,6
   415f8:	10b80604 	addi	r2,r2,-8168
   415fc:	10c01617 	ldw	r3,88(r2)
   41600:	00bbbbf4 	movhi	r2,61167
   41604:	10bbbb84 	addi	r2,r2,-4370
   41608:	1880111e 	bne	r3,r2,41650 <fpga2nios_parse+0x598>
            {
                if(sys_warn.len == 5)
   4160c:	008001b4 	movhi	r2,6
   41610:	10b46104 	addi	r2,r2,-11900
   41614:	10800517 	ldw	r2,20(r2)
   41618:	10800158 	cmpnei	r2,r2,5
   4161c:	10000c1e 	bne	r2,zero,41650 <fpga2nios_parse+0x598>
                {
                    process_motor_waring(&sys_warn);
   41620:	010001b4 	movhi	r4,6
   41624:	21346104 	addi	r4,r4,-11900
   41628:	00417c00 	call	417c0 <process_motor_waring>
                    process_ld_waring(&sys_warn);
   4162c:	010001b4 	movhi	r4,6
   41630:	21346104 	addi	r4,r4,-11900
   41634:	00418840 	call	41884 <process_ld_waring>
                    process_window_dust_waring(&sys_warn);
   41638:	010001b4 	movhi	r4,6
   4163c:	21346104 	addi	r4,r4,-11900
   41640:	00419100 	call	41910 <process_window_dust_waring>
                    process_sys_temp_waring(&sys_warn);
   41644:	010001b4 	movhi	r4,6
   41648:	21346104 	addi	r4,r4,-11900
   4164c:	00419c40 	call	419c4 <process_sys_temp_waring>
                }
            }
            queue_clear(&LaserDataQueue);
   41650:	010001b4 	movhi	r4,6
   41654:	21380104 	addi	r4,r4,-8188
   41658:	004568c0 	call	4568c <queue_clear>
            if(sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm | sys_warn.window_dust_alarm | sys_warn.temp_out_alarm)
   4165c:	008001b4 	movhi	r2,6
   41660:	10b46104 	addi	r2,r2,-11900
   41664:	10c00017 	ldw	r3,0(r2)
   41668:	008001b4 	movhi	r2,6
   4166c:	10b46104 	addi	r2,r2,-11900
   41670:	10800117 	ldw	r2,4(r2)
   41674:	1886b03a 	or	r3,r3,r2
   41678:	008001b4 	movhi	r2,6
   4167c:	10b46104 	addi	r2,r2,-11900
   41680:	10800217 	ldw	r2,8(r2)
   41684:	1886b03a 	or	r3,r3,r2
   41688:	008001b4 	movhi	r2,6
   4168c:	10b46104 	addi	r2,r2,-11900
   41690:	10800317 	ldw	r2,12(r2)
   41694:	1884b03a 	or	r2,r3,r2
   41698:	10004326 	beq	r2,zero,417a8 <fpga2nios_parse+0x6f0>
            {
                send_buffer[0] = 0x12;
   4169c:	008001b4 	movhi	r2,6
   416a0:	10881004 	addi	r2,r2,8256
   416a4:	00c00484 	movi	r3,18
   416a8:	10c00005 	stb	r3,0(r2)
                send_buffer[1] = 0x34;
   416ac:	008001b4 	movhi	r2,6
   416b0:	10881004 	addi	r2,r2,8256
   416b4:	00c00d04 	movi	r3,52
   416b8:	10c00045 	stb	r3,1(r2)
                send_buffer[2] = (UP_FPGA_STATUS >> 8) & 0xff;
   416bc:	008001b4 	movhi	r2,6
   416c0:	10881004 	addi	r2,r2,8256
   416c4:	00fff044 	movi	r3,-63
   416c8:	10c00085 	stb	r3,2(r2)
                send_buffer[3] = (UP_FPGA_STATUS >> 0) & 0xff;
   416cc:	008001b4 	movhi	r2,6
   416d0:	10881004 	addi	r2,r2,8256
   416d4:	100000c5 	stb	zero,3(r2)

                send_buffer[4] = 0;
   416d8:	008001b4 	movhi	r2,6
   416dc:	10881004 	addi	r2,r2,8256
   416e0:	10000105 	stb	zero,4(r2)
                send_buffer[5] = 0;
   416e4:	008001b4 	movhi	r2,6
   416e8:	10881004 	addi	r2,r2,8256
   416ec:	10000145 	stb	zero,5(r2)
                send_buffer[6] = 0;
   416f0:	008001b4 	movhi	r2,6
   416f4:	10881004 	addi	r2,r2,8256
   416f8:	10000185 	stb	zero,6(r2)
                send_buffer[7] = 16;
   416fc:	008001b4 	movhi	r2,6
   41700:	10881004 	addi	r2,r2,8256
   41704:	00c00404 	movi	r3,16
   41708:	10c001c5 	stb	r3,7(r2)
                memcpy(send_buffer + 8, (unsigned char *)&sys_warn, 16);
   4170c:	008001b4 	movhi	r2,6
   41710:	10881204 	addi	r2,r2,8264
   41714:	01800404 	movi	r6,16
   41718:	014001b4 	movhi	r5,6
   4171c:	29746104 	addi	r5,r5,-11900
   41720:	1009883a 	mov	r4,r2
   41724:	00493d40 	call	493d4 <memcpy>
                send_buffer[24] = send_buffer[25] = send_buffer[26] = send_buffer[27] = 0xee;
   41728:	008001b4 	movhi	r2,6
   4172c:	10881004 	addi	r2,r2,8256
   41730:	00fffb84 	movi	r3,-18
   41734:	10c006c5 	stb	r3,27(r2)
   41738:	008001b4 	movhi	r2,6
   4173c:	10881004 	addi	r2,r2,8256
   41740:	10c006c3 	ldbu	r3,27(r2)
   41744:	008001b4 	movhi	r2,6
   41748:	10881004 	addi	r2,r2,8256
   4174c:	10c00685 	stb	r3,26(r2)
   41750:	008001b4 	movhi	r2,6
   41754:	10881004 	addi	r2,r2,8256
   41758:	10c00683 	ldbu	r3,26(r2)
   4175c:	008001b4 	movhi	r2,6
   41760:	10881004 	addi	r2,r2,8256
   41764:	10c00645 	stb	r3,25(r2)
   41768:	008001b4 	movhi	r2,6
   4176c:	10881004 	addi	r2,r2,8256
   41770:	10c00643 	ldbu	r3,25(r2)
   41774:	008001b4 	movhi	r2,6
   41778:	10881004 	addi	r2,r2,8256
   4177c:	10c00605 	stb	r3,24(r2)

                send(SOCKET0, send_buffer, 28);
   41780:	01800704 	movi	r6,28
   41784:	014001b4 	movhi	r5,6
   41788:	29481004 	addi	r5,r5,8256
   4178c:	0009883a 	mov	r4,zero
   41790:	004709c0 	call	4709c <send>
                send(SOCKET1, send_buffer, 28);
   41794:	01800704 	movi	r6,28
   41798:	014001b4 	movhi	r5,6
   4179c:	29481004 	addi	r5,r5,8256
   417a0:	01000044 	movi	r4,1
   417a4:	004709c0 	call	4709c <send>
            }
        }
    }
    return -1;
   417a8:	00bfffc4 	movi	r2,-1
}
   417ac:	e037883a 	mov	sp,fp
   417b0:	dfc00117 	ldw	ra,4(sp)
   417b4:	df000017 	ldw	fp,0(sp)
   417b8:	dec00204 	addi	sp,sp,8
   417bc:	f800283a 	ret

000417c0 <process_motor_waring>:
 * @brief 连续5次检测电机计数值
 * 
 * @param data 
 */
void process_motor_waring(Sys_warn *data)
{
   417c0:	defffe04 	addi	sp,sp,-8
   417c4:	df000115 	stw	fp,4(sp)
   417c8:	df000104 	addi	fp,sp,4
   417cc:	e13fff15 	stw	r4,-4(fp)
    if(SysPara.motor_enable == ENABLE)
   417d0:	008001b4 	movhi	r2,6
   417d4:	10a56c04 	addi	r2,r2,-27216
   417d8:	10c00417 	ldw	r3,16(r2)
   417dc:	00844474 	movhi	r2,4369
   417e0:	10844444 	addi	r2,r2,4369
   417e4:	1880201e 	bne	r3,r2,41868 <process_motor_waring+0xa8>
    {
        if( 
                (data->motor_cycle_cnt[0] >= MOTOR_LOW_SPEED_VALUE) && 
   417e8:	e0bfff17 	ldw	r2,-4(fp)
   417ec:	10c00617 	ldw	r3,24(r2)
 */
void process_motor_waring(Sys_warn *data)
{
    if(SysPara.motor_enable == ENABLE)
    {
        if( 
   417f0:	00817db4 	movhi	r2,1526
   417f4:	10b83fc4 	addi	r2,r2,-7937
   417f8:	10c0182e 	bgeu	r2,r3,4185c <process_motor_waring+0x9c>
                (data->motor_cycle_cnt[0] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[1] >= MOTOR_LOW_SPEED_VALUE) && 
   417fc:	e0bfff17 	ldw	r2,-4(fp)
   41800:	10c00717 	ldw	r3,28(r2)
void process_motor_waring(Sys_warn *data)
{
    if(SysPara.motor_enable == ENABLE)
    {
        if( 
                (data->motor_cycle_cnt[0] >= MOTOR_LOW_SPEED_VALUE) && 
   41804:	00817db4 	movhi	r2,1526
   41808:	10b83fc4 	addi	r2,r2,-7937
   4180c:	10c0132e 	bgeu	r2,r3,4185c <process_motor_waring+0x9c>
                (data->motor_cycle_cnt[1] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[2] >= MOTOR_LOW_SPEED_VALUE) && 
   41810:	e0bfff17 	ldw	r2,-4(fp)
   41814:	10c00817 	ldw	r3,32(r2)
{
    if(SysPara.motor_enable == ENABLE)
    {
        if( 
                (data->motor_cycle_cnt[0] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[1] >= MOTOR_LOW_SPEED_VALUE) && 
   41818:	00817db4 	movhi	r2,1526
   4181c:	10b83fc4 	addi	r2,r2,-7937
   41820:	10c00e2e 	bgeu	r2,r3,4185c <process_motor_waring+0x9c>
                (data->motor_cycle_cnt[2] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[3] >= MOTOR_LOW_SPEED_VALUE) && 
   41824:	e0bfff17 	ldw	r2,-4(fp)
   41828:	10c00917 	ldw	r3,36(r2)
    if(SysPara.motor_enable == ENABLE)
    {
        if( 
                (data->motor_cycle_cnt[0] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[1] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[2] >= MOTOR_LOW_SPEED_VALUE) && 
   4182c:	00817db4 	movhi	r2,1526
   41830:	10b83fc4 	addi	r2,r2,-7937
   41834:	10c0092e 	bgeu	r2,r3,4185c <process_motor_waring+0x9c>
                (data->motor_cycle_cnt[3] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[4] >= MOTOR_LOW_SPEED_VALUE)
   41838:	e0bfff17 	ldw	r2,-4(fp)
   4183c:	10c00a17 	ldw	r3,40(r2)
    {
        if( 
                (data->motor_cycle_cnt[0] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[1] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[2] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[3] >= MOTOR_LOW_SPEED_VALUE) && 
   41840:	00817db4 	movhi	r2,1526
   41844:	10b83fc4 	addi	r2,r2,-7937
   41848:	10c0042e 	bgeu	r2,r3,4185c <process_motor_waring+0x9c>
                (data->motor_cycle_cnt[4] >= MOTOR_LOW_SPEED_VALUE)
        )
            data->motor_low_speed_alarm = 0x01;
   4184c:	e0bfff17 	ldw	r2,-4(fp)
   41850:	00c00044 	movi	r3,1
   41854:	10c00015 	stw	r3,0(r2)
        else
            data->motor_low_speed_alarm = 0x00;
        }
    else
        data->motor_low_speed_alarm = 0x00;
}
   41858:	00000506 	br	41870 <process_motor_waring+0xb0>
                (data->motor_cycle_cnt[3] >= MOTOR_LOW_SPEED_VALUE) && 
                (data->motor_cycle_cnt[4] >= MOTOR_LOW_SPEED_VALUE)
        )
            data->motor_low_speed_alarm = 0x01;
        else
            data->motor_low_speed_alarm = 0x00;
   4185c:	e0bfff17 	ldw	r2,-4(fp)
   41860:	10000015 	stw	zero,0(r2)
        }
    else
        data->motor_low_speed_alarm = 0x00;
}
   41864:	00000206 	br	41870 <process_motor_waring+0xb0>
            data->motor_low_speed_alarm = 0x01;
        else
            data->motor_low_speed_alarm = 0x00;
        }
    else
        data->motor_low_speed_alarm = 0x00;
   41868:	e0bfff17 	ldw	r2,-4(fp)
   4186c:	10000015 	stw	zero,0(r2)
}
   41870:	0001883a 	nop
   41874:	e037883a 	mov	sp,fp
   41878:	df000017 	ldw	fp,0(sp)
   4187c:	dec00104 	addi	sp,sp,4
   41880:	f800283a 	ret

00041884 <process_ld_waring>:
 * @brief 连续5次获得的零位距离值大于设定值，报警
 * 
 * @param data 
 */
void process_ld_waring(Sys_warn *data)
{
   41884:	defffe04 	addi	sp,sp,-8
   41888:	df000115 	stw	fp,4(sp)
   4188c:	df000104 	addi	fp,sp,4
   41890:	e13fff15 	stw	r4,-4(fp)
    if( 
            (data->zero_value[0] < LD_NO_WORK_VALUE) && 
   41894:	e0bfff17 	ldw	r2,-4(fp)
   41898:	10800b17 	ldw	r2,44(r2)
 * 
 * @param data 
 */
void process_ld_waring(Sys_warn *data)
{
    if( 
   4189c:	108001e8 	cmpgeui	r2,r2,7
   418a0:	1000141e 	bne	r2,zero,418f4 <process_ld_waring+0x70>
            (data->zero_value[0] < LD_NO_WORK_VALUE) && 
            (data->zero_value[1] < LD_NO_WORK_VALUE) && 
   418a4:	e0bfff17 	ldw	r2,-4(fp)
   418a8:	10800c17 	ldw	r2,48(r2)
 * @param data 
 */
void process_ld_waring(Sys_warn *data)
{
    if( 
            (data->zero_value[0] < LD_NO_WORK_VALUE) && 
   418ac:	108001e8 	cmpgeui	r2,r2,7
   418b0:	1000101e 	bne	r2,zero,418f4 <process_ld_waring+0x70>
            (data->zero_value[1] < LD_NO_WORK_VALUE) && 
            (data->zero_value[2] < LD_NO_WORK_VALUE) && 
   418b4:	e0bfff17 	ldw	r2,-4(fp)
   418b8:	10800d17 	ldw	r2,52(r2)
 */
void process_ld_waring(Sys_warn *data)
{
    if( 
            (data->zero_value[0] < LD_NO_WORK_VALUE) && 
            (data->zero_value[1] < LD_NO_WORK_VALUE) && 
   418bc:	108001e8 	cmpgeui	r2,r2,7
   418c0:	10000c1e 	bne	r2,zero,418f4 <process_ld_waring+0x70>
            (data->zero_value[2] < LD_NO_WORK_VALUE) && 
            (data->zero_value[3] < LD_NO_WORK_VALUE) && 
   418c4:	e0bfff17 	ldw	r2,-4(fp)
   418c8:	10800e17 	ldw	r2,56(r2)
void process_ld_waring(Sys_warn *data)
{
    if( 
            (data->zero_value[0] < LD_NO_WORK_VALUE) && 
            (data->zero_value[1] < LD_NO_WORK_VALUE) && 
            (data->zero_value[2] < LD_NO_WORK_VALUE) && 
   418cc:	108001e8 	cmpgeui	r2,r2,7
   418d0:	1000081e 	bne	r2,zero,418f4 <process_ld_waring+0x70>
            (data->zero_value[3] < LD_NO_WORK_VALUE) && 
            (data->zero_value[4] < LD_NO_WORK_VALUE)
   418d4:	e0bfff17 	ldw	r2,-4(fp)
   418d8:	10800f17 	ldw	r2,60(r2)
{
    if( 
            (data->zero_value[0] < LD_NO_WORK_VALUE) && 
            (data->zero_value[1] < LD_NO_WORK_VALUE) && 
            (data->zero_value[2] < LD_NO_WORK_VALUE) && 
            (data->zero_value[3] < LD_NO_WORK_VALUE) && 
   418dc:	108001e8 	cmpgeui	r2,r2,7
   418e0:	1000041e 	bne	r2,zero,418f4 <process_ld_waring+0x70>
            (data->zero_value[4] < LD_NO_WORK_VALUE)
      )
        data->ld_not_work_alarm = 0x01;
   418e4:	e0bfff17 	ldw	r2,-4(fp)
   418e8:	00c00044 	movi	r3,1
   418ec:	10c00115 	stw	r3,4(r2)
   418f0:	00000206 	br	418fc <process_ld_waring+0x78>
    else
        data->ld_not_work_alarm = 0x00;
   418f4:	e0bfff17 	ldw	r2,-4(fp)
   418f8:	10000115 	stw	zero,4(r2)
}
   418fc:	0001883a 	nop
   41900:	e037883a 	mov	sp,fp
   41904:	df000017 	ldw	fp,0(sp)
   41908:	dec00104 	addi	sp,sp,4
   4190c:	f800283a 	ret

00041910 <process_window_dust_waring>:
 * @brief 连续5次的灰尘计数值大于设定值，报警
 * 
 * @param data 
 */
void process_window_dust_waring(Sys_warn *data)
{
   41910:	defffe04 	addi	sp,sp,-8
   41914:	df000115 	stw	fp,4(sp)
   41918:	df000104 	addi	fp,sp,4
   4191c:	e13fff15 	stw	r4,-4(fp)
    if( 
            (data->dust_cnt[0] > SysPara.dust_threshold) && 
   41920:	e0bfff17 	ldw	r2,-4(fp)
   41924:	10c01017 	ldw	r3,64(r2)
   41928:	008001b4 	movhi	r2,6
   4192c:	10a56c04 	addi	r2,r2,-27216
   41930:	10804917 	ldw	r2,292(r2)
 * 
 * @param data 
 */
void process_window_dust_waring(Sys_warn *data)
{
    if( 
   41934:	10c01c2e 	bgeu	r2,r3,419a8 <process_window_dust_waring+0x98>
            (data->dust_cnt[0] > SysPara.dust_threshold) && 
            (data->dust_cnt[1] > SysPara.dust_threshold) && 
   41938:	e0bfff17 	ldw	r2,-4(fp)
   4193c:	10c01117 	ldw	r3,68(r2)
   41940:	008001b4 	movhi	r2,6
   41944:	10a56c04 	addi	r2,r2,-27216
   41948:	10804917 	ldw	r2,292(r2)
 * @param data 
 */
void process_window_dust_waring(Sys_warn *data)
{
    if( 
            (data->dust_cnt[0] > SysPara.dust_threshold) && 
   4194c:	10c0162e 	bgeu	r2,r3,419a8 <process_window_dust_waring+0x98>
            (data->dust_cnt[1] > SysPara.dust_threshold) && 
            (data->dust_cnt[2] > SysPara.dust_threshold) && 
   41950:	e0bfff17 	ldw	r2,-4(fp)
   41954:	10c01217 	ldw	r3,72(r2)
   41958:	008001b4 	movhi	r2,6
   4195c:	10a56c04 	addi	r2,r2,-27216
   41960:	10804917 	ldw	r2,292(r2)
 */
void process_window_dust_waring(Sys_warn *data)
{
    if( 
            (data->dust_cnt[0] > SysPara.dust_threshold) && 
            (data->dust_cnt[1] > SysPara.dust_threshold) && 
   41964:	10c0102e 	bgeu	r2,r3,419a8 <process_window_dust_waring+0x98>
            (data->dust_cnt[2] > SysPara.dust_threshold) && 
            (data->dust_cnt[3] > SysPara.dust_threshold) && 
   41968:	e0bfff17 	ldw	r2,-4(fp)
   4196c:	10c01317 	ldw	r3,76(r2)
   41970:	008001b4 	movhi	r2,6
   41974:	10a56c04 	addi	r2,r2,-27216
   41978:	10804917 	ldw	r2,292(r2)
void process_window_dust_waring(Sys_warn *data)
{
    if( 
            (data->dust_cnt[0] > SysPara.dust_threshold) && 
            (data->dust_cnt[1] > SysPara.dust_threshold) && 
            (data->dust_cnt[2] > SysPara.dust_threshold) && 
   4197c:	10c00a2e 	bgeu	r2,r3,419a8 <process_window_dust_waring+0x98>
            (data->dust_cnt[3] > SysPara.dust_threshold) && 
            (data->dust_cnt[4] > SysPara.dust_threshold)
   41980:	e0bfff17 	ldw	r2,-4(fp)
   41984:	10c01417 	ldw	r3,80(r2)
   41988:	008001b4 	movhi	r2,6
   4198c:	10a56c04 	addi	r2,r2,-27216
   41990:	10804917 	ldw	r2,292(r2)
{
    if( 
            (data->dust_cnt[0] > SysPara.dust_threshold) && 
            (data->dust_cnt[1] > SysPara.dust_threshold) && 
            (data->dust_cnt[2] > SysPara.dust_threshold) && 
            (data->dust_cnt[3] > SysPara.dust_threshold) && 
   41994:	10c0042e 	bgeu	r2,r3,419a8 <process_window_dust_waring+0x98>
            (data->dust_cnt[4] > SysPara.dust_threshold)
      )
        data->window_dust_alarm = 0x01;
   41998:	e0bfff17 	ldw	r2,-4(fp)
   4199c:	00c00044 	movi	r3,1
   419a0:	10c00215 	stw	r3,8(r2)
   419a4:	00000206 	br	419b0 <process_window_dust_waring+0xa0>
    else
        data->window_dust_alarm = 0x00;
   419a8:	e0bfff17 	ldw	r2,-4(fp)
   419ac:	10000215 	stw	zero,8(r2)
}
   419b0:	0001883a 	nop
   419b4:	e037883a 	mov	sp,fp
   419b8:	df000017 	ldw	fp,0(sp)
   419bc:	dec00104 	addi	sp,sp,4
   419c0:	f800283a 	ret

000419c4 <process_sys_temp_waring>:


void process_sys_temp_waring(Sys_warn *data)
{
   419c4:	defffc04 	addi	sp,sp,-16
   419c8:	df000315 	stw	fp,12(sp)
   419cc:	df000304 	addi	fp,sp,12
   419d0:	e13fff15 	stw	r4,-4(fp)
    int i;
    unsigned char sign_bit = 0;
   419d4:	e03ffe05 	stb	zero,-8(fp)

    for(i = 0; i < 5; i++)
   419d8:	e03ffd15 	stw	zero,-12(fp)
   419dc:	00003006 	br	41aa0 <process_sys_temp_waring+0xdc>
    {
        sign_bit = (data->temp_value[i] >> 13) & 0x01;
   419e0:	e0ffff17 	ldw	r3,-4(fp)
   419e4:	e0bffd17 	ldw	r2,-12(fp)
   419e8:	10800544 	addi	r2,r2,21
   419ec:	1085883a 	add	r2,r2,r2
   419f0:	1085883a 	add	r2,r2,r2
   419f4:	1885883a 	add	r2,r3,r2
   419f8:	10800017 	ldw	r2,0(r2)
   419fc:	1004d37a 	srli	r2,r2,13
   41a00:	1080004c 	andi	r2,r2,1
   41a04:	e0bffe05 	stb	r2,-8(fp)
        if(sign_bit == 0)  // 温度是正值
   41a08:	e0bffe03 	ldbu	r2,-8(fp)
   41a0c:	1000111e 	bne	r2,zero,41a54 <process_sys_temp_waring+0x90>
        {
            if((data->temp_value[i] & 0x00ff) > TEMP_OUT_VALUE)
   41a10:	e0ffff17 	ldw	r3,-4(fp)
   41a14:	e0bffd17 	ldw	r2,-12(fp)
   41a18:	10800544 	addi	r2,r2,21
   41a1c:	1085883a 	add	r2,r2,r2
   41a20:	1085883a 	add	r2,r2,r2
   41a24:	1885883a 	add	r2,r3,r2
   41a28:	10800017 	ldw	r2,0(r2)
   41a2c:	10803fcc 	andi	r2,r2,255
   41a30:	10801370 	cmpltui	r2,r2,77
   41a34:	1000041e 	bne	r2,zero,41a48 <process_sys_temp_waring+0x84>
                data->temp_out_alarm = 0x01;
   41a38:	e0bfff17 	ldw	r2,-4(fp)
   41a3c:	00c00044 	movi	r3,1
   41a40:	10c00315 	stw	r3,12(r2)
   41a44:	00001306 	br	41a94 <process_sys_temp_waring+0xd0>
            else
                data->temp_out_alarm = 0x00;
   41a48:	e0bfff17 	ldw	r2,-4(fp)
   41a4c:	10000315 	stw	zero,12(r2)
   41a50:	00001006 	br	41a94 <process_sys_temp_waring+0xd0>
        }
        else
        {
            if((data->temp_value[i] & 0x00ff) > 20)
   41a54:	e0ffff17 	ldw	r3,-4(fp)
   41a58:	e0bffd17 	ldw	r2,-12(fp)
   41a5c:	10800544 	addi	r2,r2,21
   41a60:	1085883a 	add	r2,r2,r2
   41a64:	1085883a 	add	r2,r2,r2
   41a68:	1885883a 	add	r2,r3,r2
   41a6c:	10800017 	ldw	r2,0(r2)
   41a70:	10803fcc 	andi	r2,r2,255
   41a74:	10800570 	cmpltui	r2,r2,21
   41a78:	1000041e 	bne	r2,zero,41a8c <process_sys_temp_waring+0xc8>
                data->temp_out_alarm = 0x01;
   41a7c:	e0bfff17 	ldw	r2,-4(fp)
   41a80:	00c00044 	movi	r3,1
   41a84:	10c00315 	stw	r3,12(r2)
   41a88:	00000206 	br	41a94 <process_sys_temp_waring+0xd0>
            else
                data->temp_out_alarm = 0x00;
   41a8c:	e0bfff17 	ldw	r2,-4(fp)
   41a90:	10000315 	stw	zero,12(r2)
void process_sys_temp_waring(Sys_warn *data)
{
    int i;
    unsigned char sign_bit = 0;

    for(i = 0; i < 5; i++)
   41a94:	e0bffd17 	ldw	r2,-12(fp)
   41a98:	10800044 	addi	r2,r2,1
   41a9c:	e0bffd15 	stw	r2,-12(fp)
   41aa0:	e0bffd17 	ldw	r2,-12(fp)
   41aa4:	10800150 	cmplti	r2,r2,5
   41aa8:	103fcd1e 	bne	r2,zero,419e0 <__alt_mem_epcs_flash+0xfffc09e0>
                data->temp_out_alarm = 0x01;
            else
                data->temp_out_alarm = 0x00;
        }
    }
}
   41aac:	0001883a 	nop
   41ab0:	e037883a 	mov	sp,fp
   41ab4:	df000017 	ldw	fp,0(sp)
   41ab8:	dec00104 	addi	sp,sp,4
   41abc:	f800283a 	ret

00041ac0 <start>:
 * Name: start
 * Description: IIC启动
 * =================================================================
 */
static void start(void)
{
   41ac0:	defffe04 	addi	sp,sp,-8
   41ac4:	dfc00115 	stw	ra,4(sp)
   41ac8:	df000015 	stw	fp,0(sp)
   41acc:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, OUT);
   41ad0:	00c00044 	movi	r3,1
   41ad4:	00800234 	movhi	r2,8
   41ad8:	10885d04 	addi	r2,r2,8564
   41adc:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, 1);
   41ae0:	00c00044 	movi	r3,1
   41ae4:	00800234 	movhi	r2,8
   41ae8:	10885c04 	addi	r2,r2,8560
   41aec:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41af0:	00c00044 	movi	r3,1
   41af4:	00800234 	movhi	r2,8
   41af8:	10886004 	addi	r2,r2,8576
   41afc:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41b00:	01000084 	movi	r4,2
   41b04:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, 0);
   41b08:	0007883a 	mov	r3,zero
   41b0c:	00800234 	movhi	r2,8
   41b10:	10885c04 	addi	r2,r2,8560
   41b14:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41b18:	01000044 	movi	r4,1
   41b1c:	00402c80 	call	402c8 <delay_us>
}
   41b20:	0001883a 	nop
   41b24:	e037883a 	mov	sp,fp
   41b28:	dfc00117 	ldw	ra,4(sp)
   41b2c:	df000017 	ldw	fp,0(sp)
   41b30:	dec00204 	addi	sp,sp,8
   41b34:	f800283a 	ret

00041b38 <stop>:
 * Name: uart_send_byte
 * Description: IIC停止
 * ==================================================================
 */
static void stop(void)
{
   41b38:	defffe04 	addi	sp,sp,-8
   41b3c:	dfc00115 	stw	ra,4(sp)
   41b40:	df000015 	stw	fp,0(sp)
   41b44:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, OUT);
   41b48:	00c00044 	movi	r3,1
   41b4c:	00800234 	movhi	r2,8
   41b50:	10885d04 	addi	r2,r2,8564
   41b54:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, 0);
   41b58:	0007883a 	mov	r3,zero
   41b5c:	00800234 	movhi	r2,8
   41b60:	10885c04 	addi	r2,r2,8560
   41b64:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41b68:	0007883a 	mov	r3,zero
   41b6c:	00800234 	movhi	r2,8
   41b70:	10886004 	addi	r2,r2,8576
   41b74:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41b78:	01000084 	movi	r4,2
   41b7c:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41b80:	00c00044 	movi	r3,1
   41b84:	00800234 	movhi	r2,8
   41b88:	10886004 	addi	r2,r2,8576
   41b8c:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41b90:	01000044 	movi	r4,1
   41b94:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, 1);
   41b98:	00c00044 	movi	r3,1
   41b9c:	00800234 	movhi	r2,8
   41ba0:	10885c04 	addi	r2,r2,8560
   41ba4:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41ba8:	01000084 	movi	r4,2
   41bac:	00402c80 	call	402c8 <delay_us>
}
   41bb0:	0001883a 	nop
   41bb4:	e037883a 	mov	sp,fp
   41bb8:	dfc00117 	ldw	ra,4(sp)
   41bbc:	df000017 	ldw	fp,0(sp)
   41bc0:	dec00204 	addi	sp,sp,8
   41bc4:	f800283a 	ret

00041bc8 <wait_slave_ack>:
 * Name: ack
 * Description: IIC应答
 * =================================================================
 */
static void wait_slave_ack(void)
{
   41bc8:	defffd04 	addi	sp,sp,-12
   41bcc:	dfc00215 	stw	ra,8(sp)
   41bd0:	df000115 	stw	fp,4(sp)
   41bd4:	df000104 	addi	fp,sp,4
    alt_u8 tmp;
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41bd8:	0007883a 	mov	r3,zero
   41bdc:	00800234 	movhi	r2,8
   41be0:	10886004 	addi	r2,r2,8576
   41be4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, IN);
   41be8:	0007883a 	mov	r3,zero
   41bec:	00800234 	movhi	r2,8
   41bf0:	10885d04 	addi	r2,r2,8564
   41bf4:	10c00035 	stwio	r3,0(r2)

    delay_us(2);
   41bf8:	01000084 	movi	r4,2
   41bfc:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41c00:	00c00044 	movi	r3,1
   41c04:	00800234 	movhi	r2,8
   41c08:	10886004 	addi	r2,r2,8576
   41c0c:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41c10:	01000044 	movi	r4,1
   41c14:	00402c80 	call	402c8 <delay_us>
    tmp = IORD_ALTERA_AVALON_PIO_DATA(SDA_BASE);
   41c18:	00800234 	movhi	r2,8
   41c1c:	10885c04 	addi	r2,r2,8560
   41c20:	10800037 	ldwio	r2,0(r2)
   41c24:	e0bfff05 	stb	r2,-4(fp)

    delay_us(1);
   41c28:	01000044 	movi	r4,1
   41c2c:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41c30:	0007883a 	mov	r3,zero
   41c34:	00800234 	movhi	r2,8
   41c38:	10886004 	addi	r2,r2,8576
   41c3c:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41c40:	01000084 	movi	r4,2
   41c44:	00402c80 	call	402c8 <delay_us>
    if(tmp == 1)  // 不正确应答
   41c48:	e0bfff03 	ldbu	r2,-4(fp)
   41c4c:	10800058 	cmpnei	r2,r2,1
   41c50:	1000011e 	bne	r2,zero,41c58 <wait_slave_ack+0x90>
        stop();
   41c54:	0041b380 	call	41b38 <stop>
}
   41c58:	0001883a 	nop
   41c5c:	e037883a 	mov	sp,fp
   41c60:	dfc00117 	ldw	ra,4(sp)
   41c64:	df000017 	ldw	fp,0(sp)
   41c68:	dec00204 	addi	sp,sp,8
   41c6c:	f800283a 	ret

00041c70 <master_send_ack>:
/**
 * @brief 主机发送一个低电平的应答信号, 继续读取数据
 * 
 */
static void master_send_ack(void)
{
   41c70:	defffe04 	addi	sp,sp,-8
   41c74:	dfc00115 	stw	ra,4(sp)
   41c78:	df000015 	stw	fp,0(sp)
   41c7c:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41c80:	0007883a 	mov	r3,zero
   41c84:	00800234 	movhi	r2,8
   41c88:	10886004 	addi	r2,r2,8576
   41c8c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, OUT);
   41c90:	00c00044 	movi	r3,1
   41c94:	00800234 	movhi	r2,8
   41c98:	10885d04 	addi	r2,r2,8564
   41c9c:	10c00035 	stwio	r3,0(r2)

    delay_us(2);
   41ca0:	01000084 	movi	r4,2
   41ca4:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, 0);
   41ca8:	0007883a 	mov	r3,zero
   41cac:	00800234 	movhi	r2,8
   41cb0:	10885c04 	addi	r2,r2,8560
   41cb4:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41cb8:	01000044 	movi	r4,1
   41cbc:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41cc0:	00c00044 	movi	r3,1
   41cc4:	00800234 	movhi	r2,8
   41cc8:	10886004 	addi	r2,r2,8576
   41ccc:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41cd0:	01000044 	movi	r4,1
   41cd4:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41cd8:	0007883a 	mov	r3,zero
   41cdc:	00800234 	movhi	r2,8
   41ce0:	10886004 	addi	r2,r2,8576
   41ce4:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41ce8:	01000084 	movi	r4,2
   41cec:	00402c80 	call	402c8 <delay_us>
}
   41cf0:	0001883a 	nop
   41cf4:	e037883a 	mov	sp,fp
   41cf8:	dfc00117 	ldw	ra,4(sp)
   41cfc:	df000017 	ldw	fp,0(sp)
   41d00:	dec00204 	addi	sp,sp,8
   41d04:	f800283a 	ret

00041d08 <no_ack>:
/**
 * @brief 
 * 
 */
static void no_ack(void)
{
   41d08:	defffe04 	addi	sp,sp,-8
   41d0c:	dfc00115 	stw	ra,4(sp)
   41d10:	df000015 	stw	fp,0(sp)
   41d14:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41d18:	0007883a 	mov	r3,zero
   41d1c:	00800234 	movhi	r2,8
   41d20:	10886004 	addi	r2,r2,8576
   41d24:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, OUT);
   41d28:	00c00044 	movi	r3,1
   41d2c:	00800234 	movhi	r2,8
   41d30:	10885d04 	addi	r2,r2,8564
   41d34:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41d38:	01000084 	movi	r4,2
   41d3c:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, 1);
   41d40:	00c00044 	movi	r3,1
   41d44:	00800234 	movhi	r2,8
   41d48:	10885c04 	addi	r2,r2,8560
   41d4c:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41d50:	01000044 	movi	r4,1
   41d54:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41d58:	00c00044 	movi	r3,1
   41d5c:	00800234 	movhi	r2,8
   41d60:	10886004 	addi	r2,r2,8576
   41d64:	10c00035 	stwio	r3,0(r2)
    delay_us(1);
   41d68:	01000044 	movi	r4,1
   41d6c:	00402c80 	call	402c8 <delay_us>
    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41d70:	0007883a 	mov	r3,zero
   41d74:	00800234 	movhi	r2,8
   41d78:	10886004 	addi	r2,r2,8576
   41d7c:	10c00035 	stwio	r3,0(r2)
    delay_us(2);
   41d80:	01000084 	movi	r4,2
   41d84:	00402c80 	call	402c8 <delay_us>
}
   41d88:	0001883a 	nop
   41d8c:	e037883a 	mov	sp,fp
   41d90:	dfc00117 	ldw	ra,4(sp)
   41d94:	df000017 	ldw	fp,0(sp)
   41d98:	dec00204 	addi	sp,sp,8
   41d9c:	f800283a 	ret

00041da0 <iic_write>:
 * Name: iic_write
 * Description: IIC写一个字节
 * =================================================================
 */
void iic_write(alt_u8 dat)
{
   41da0:	defffc04 	addi	sp,sp,-16
   41da4:	dfc00315 	stw	ra,12(sp)
   41da8:	df000215 	stw	fp,8(sp)
   41dac:	df000204 	addi	fp,sp,8
   41db0:	2005883a 	mov	r2,r4
   41db4:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 i, tmp;
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, OUT);
   41db8:	00c00044 	movi	r3,1
   41dbc:	00800234 	movhi	r2,8
   41dc0:	10885d04 	addi	r2,r2,8564
   41dc4:	10c00035 	stwio	r3,0(r2)
    for(i = 0; i < 8; i++)
   41dc8:	e03ffe05 	stb	zero,-8(fp)
   41dcc:	00001c06 	br	41e40 <iic_write+0xa0>
    {
        IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41dd0:	0007883a 	mov	r3,zero
   41dd4:	00800234 	movhi	r2,8
   41dd8:	10886004 	addi	r2,r2,8576
   41ddc:	10c00035 	stwio	r3,0(r2)
        delay_us(2);
   41de0:	01000084 	movi	r4,2
   41de4:	00402c80 	call	402c8 <delay_us>
        tmp = (dat & 0x80) ? 1 : 0;
   41de8:	e0bfff03 	ldbu	r2,-4(fp)
   41dec:	10803fcc 	andi	r2,r2,255
   41df0:	1004d1fa 	srli	r2,r2,7
   41df4:	e0bffe45 	stb	r2,-7(fp)
        dat <<= 1;
   41df8:	e0bfff03 	ldbu	r2,-4(fp)
   41dfc:	1085883a 	add	r2,r2,r2
   41e00:	e0bfff05 	stb	r2,-4(fp)
        IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, tmp);
   41e04:	e0fffe43 	ldbu	r3,-7(fp)
   41e08:	00800234 	movhi	r2,8
   41e0c:	10885c04 	addi	r2,r2,8560
   41e10:	10c00035 	stwio	r3,0(r2)
        delay_us(1);
   41e14:	01000044 	movi	r4,1
   41e18:	00402c80 	call	402c8 <delay_us>
        IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41e1c:	00c00044 	movi	r3,1
   41e20:	00800234 	movhi	r2,8
   41e24:	10886004 	addi	r2,r2,8576
   41e28:	10c00035 	stwio	r3,0(r2)
        delay_us(2);
   41e2c:	01000084 	movi	r4,2
   41e30:	00402c80 	call	402c8 <delay_us>
 */
void iic_write(alt_u8 dat)
{
    alt_u8 i, tmp;
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, OUT);
    for(i = 0; i < 8; i++)
   41e34:	e0bffe03 	ldbu	r2,-8(fp)
   41e38:	10800044 	addi	r2,r2,1
   41e3c:	e0bffe05 	stb	r2,-8(fp)
   41e40:	e0bffe03 	ldbu	r2,-8(fp)
   41e44:	10800230 	cmpltui	r2,r2,8
   41e48:	103fe11e 	bne	r2,zero,41dd0 <__alt_mem_epcs_flash+0xfffc0dd0>
        IOWR_ALTERA_AVALON_PIO_DATA(SDA_BASE, tmp);
        delay_us(1);
        IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
        delay_us(2);
    }
}
   41e4c:	0001883a 	nop
   41e50:	e037883a 	mov	sp,fp
   41e54:	dfc00117 	ldw	ra,4(sp)
   41e58:	df000017 	ldw	fp,0(sp)
   41e5c:	dec00204 	addi	sp,sp,8
   41e60:	f800283a 	ret

00041e64 <iic_read>:
 * Name: read
 * Description: IIC读一个字节
 * ==================================================================
 */
static alt_u8 iic_read(void)
{
   41e64:	defffd04 	addi	sp,sp,-12
   41e68:	dfc00215 	stw	ra,8(sp)
   41e6c:	df000115 	stw	fp,4(sp)
   41e70:	df000104 	addi	fp,sp,4
    alt_u8 i, dat = 0;
   41e74:	e03fff45 	stb	zero,-3(fp)
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, IN);
   41e78:	0007883a 	mov	r3,zero
   41e7c:	00800234 	movhi	r2,8
   41e80:	10885d04 	addi	r2,r2,8564
   41e84:	10c00035 	stwio	r3,0(r2)
    for(i = 0; i < 8; i++)
   41e88:	e03fff05 	stb	zero,-4(fp)
   41e8c:	00001b06 	br	41efc <iic_read+0x98>
    {
        IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
   41e90:	0007883a 	mov	r3,zero
   41e94:	00800234 	movhi	r2,8
   41e98:	10886004 	addi	r2,r2,8576
   41e9c:	10c00035 	stwio	r3,0(r2)
        delay_us(2);
   41ea0:	01000084 	movi	r4,2
   41ea4:	00402c80 	call	402c8 <delay_us>
        IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
   41ea8:	00c00044 	movi	r3,1
   41eac:	00800234 	movhi	r2,8
   41eb0:	10886004 	addi	r2,r2,8576
   41eb4:	10c00035 	stwio	r3,0(r2)
        delay_us(1);
   41eb8:	01000044 	movi	r4,1
   41ebc:	00402c80 	call	402c8 <delay_us>
        dat <<= 1;
   41ec0:	e0bfff43 	ldbu	r2,-3(fp)
   41ec4:	1085883a 	add	r2,r2,r2
   41ec8:	e0bfff45 	stb	r2,-3(fp)
        dat |= IORD_ALTERA_AVALON_PIO_DATA(SDA_BASE);
   41ecc:	00800234 	movhi	r2,8
   41ed0:	10885c04 	addi	r2,r2,8560
   41ed4:	10800037 	ldwio	r2,0(r2)
   41ed8:	1007883a 	mov	r3,r2
   41edc:	e0bfff43 	ldbu	r2,-3(fp)
   41ee0:	1884b03a 	or	r2,r3,r2
   41ee4:	e0bfff45 	stb	r2,-3(fp)
        delay_us(1);
   41ee8:	01000044 	movi	r4,1
   41eec:	00402c80 	call	402c8 <delay_us>
 */
static alt_u8 iic_read(void)
{
    alt_u8 i, dat = 0;
    IOWR_ALTERA_AVALON_PIO_DIRECTION(SDA_BASE, IN);
    for(i = 0; i < 8; i++)
   41ef0:	e0bfff03 	ldbu	r2,-4(fp)
   41ef4:	10800044 	addi	r2,r2,1
   41ef8:	e0bfff05 	stb	r2,-4(fp)
   41efc:	e0bfff03 	ldbu	r2,-4(fp)
   41f00:	10800230 	cmpltui	r2,r2,8
   41f04:	103fe21e 	bne	r2,zero,41e90 <__alt_mem_epcs_flash+0xfffc0e90>
        delay_us(1);
        dat <<= 1;
        dat |= IORD_ALTERA_AVALON_PIO_DATA(SDA_BASE);
        delay_us(1);
    }
    delay_us(1);
   41f08:	01000044 	movi	r4,1
   41f0c:	00402c80 	call	402c8 <delay_us>
    //    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
    //    delay_us(1);
    //    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 1);
    //    delay_us(1);
    //    IOWR_ALTERA_AVALON_PIO_DATA(SCL_BASE, 0);
    return dat;
   41f10:	e0bfff43 	ldbu	r2,-3(fp)
}
   41f14:	e037883a 	mov	sp,fp
   41f18:	dfc00117 	ldw	ra,4(sp)
   41f1c:	df000017 	ldw	fp,0(sp)
   41f20:	dec00204 	addi	sp,sp,8
   41f24:	f800283a 	ret

00041f28 <eeprom_write_byte>:
 * @brief 向EEPROM写一个字节. 注意E2PROM的固有写入时间
 * @param addr
 * @param dat
 */
void eeprom_write_byte(alt_u32 addr, alt_u8 dat)
{
   41f28:	defffb04 	addi	sp,sp,-20
   41f2c:	dfc00415 	stw	ra,16(sp)
   41f30:	df000315 	stw	fp,12(sp)
   41f34:	df000304 	addi	fp,sp,12
   41f38:	e13ffe15 	stw	r4,-8(fp)
   41f3c:	2805883a 	mov	r2,r5
   41f40:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 cmd;
    cmd = 0xa0 | ((addr >> 15) & 0x02);
   41f44:	e0bffe17 	ldw	r2,-8(fp)
   41f48:	1004d3fa 	srli	r2,r2,15
   41f4c:	1080008c 	andi	r2,r2,2
   41f50:	1007883a 	mov	r3,r2
   41f54:	00bfe804 	movi	r2,-96
   41f58:	1884b03a 	or	r2,r3,r2
   41f5c:	e0bffd05 	stb	r2,-12(fp)
    start();
   41f60:	0041ac00 	call	41ac0 <start>
    iic_write(cmd);
   41f64:	e0bffd03 	ldbu	r2,-12(fp)
   41f68:	1009883a 	mov	r4,r2
   41f6c:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   41f70:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write((addr >> 8) & 0xff);
   41f74:	e0bffe17 	ldw	r2,-8(fp)
   41f78:	1004d23a 	srli	r2,r2,8
   41f7c:	10803fcc 	andi	r2,r2,255
   41f80:	1009883a 	mov	r4,r2
   41f84:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   41f88:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write((addr >> 0) & 0xff);
   41f8c:	e0bffe17 	ldw	r2,-8(fp)
   41f90:	10803fcc 	andi	r2,r2,255
   41f94:	1009883a 	mov	r4,r2
   41f98:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   41f9c:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write(dat);
   41fa0:	e0bfff03 	ldbu	r2,-4(fp)
   41fa4:	1009883a 	mov	r4,r2
   41fa8:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   41fac:	0041bc80 	call	41bc8 <wait_slave_ack>
    stop();
   41fb0:	0041b380 	call	41b38 <stop>
    delay_us(2500);
   41fb4:	01027104 	movi	r4,2500
   41fb8:	00402c80 	call	402c8 <delay_us>
}
   41fbc:	0001883a 	nop
   41fc0:	e037883a 	mov	sp,fp
   41fc4:	dfc00117 	ldw	ra,4(sp)
   41fc8:	df000017 	ldw	fp,0(sp)
   41fcc:	dec00204 	addi	sp,sp,8
   41fd0:	f800283a 	ret

00041fd4 <eeprom_write_page>:
 * @param addr, 要写入E2PROM的起始地址
 * @param dat, 地址指针
 * @param len, 写入数据长度
 */
void eeprom_write_page(alt_u32 addr, alt_u8 *dat, alt_u16 len)
{
   41fd4:	defff804 	addi	sp,sp,-32
   41fd8:	dfc00715 	stw	ra,28(sp)
   41fdc:	df000615 	stw	fp,24(sp)
   41fe0:	df000604 	addi	fp,sp,24
   41fe4:	e13ffd15 	stw	r4,-12(fp)
   41fe8:	e17ffe15 	stw	r5,-8(fp)
   41fec:	3005883a 	mov	r2,r6
   41ff0:	e0bfff0d 	sth	r2,-4(fp)
    alt_u16 i, j;
    alt_u8  number, remain;
    alt_32  i2c_addr;

    // 最高位地址放到bit6上
    cmd = 0xa0 | ((addr >> 15) & 0x02);
   41ff4:	e0bffd17 	ldw	r2,-12(fp)
   41ff8:	1004d3fa 	srli	r2,r2,15
   41ffc:	1080008c 	andi	r2,r2,2
   42000:	1007883a 	mov	r3,r2
   42004:	00bfe804 	movi	r2,-96
   42008:	1884b03a 	or	r2,r3,r2
   4200c:	e0bffb05 	stb	r2,-20(fp)

    number = len / EEPROM_PAGE_SIZE;
   42010:	e0bfff0b 	ldhu	r2,-4(fp)
   42014:	1004d23a 	srli	r2,r2,8
   42018:	e0bffb45 	stb	r2,-19(fp)
    remain = len % EEPROM_PAGE_SIZE;
   4201c:	e0bfff0b 	ldhu	r2,-4(fp)
   42020:	e0bffb85 	stb	r2,-18(fp)

    for(i = 0; i < number; i++)
   42024:	e03ffa0d 	sth	zero,-24(fp)
   42028:	00003006 	br	420ec <eeprom_write_page+0x118>
    {
        i2c_addr = addr + i * EEPROM_PAGE_SIZE;
   4202c:	e0bffa0b 	ldhu	r2,-24(fp)
   42030:	1004923a 	slli	r2,r2,8
   42034:	1007883a 	mov	r3,r2
   42038:	e0bffd17 	ldw	r2,-12(fp)
   4203c:	1885883a 	add	r2,r3,r2
   42040:	e0bffc15 	stw	r2,-16(fp)
        start();
   42044:	0041ac00 	call	41ac0 <start>
        iic_write(cmd);
   42048:	e0bffb03 	ldbu	r2,-20(fp)
   4204c:	1009883a 	mov	r4,r2
   42050:	0041da00 	call	41da0 <iic_write>
        wait_slave_ack();
   42054:	0041bc80 	call	41bc8 <wait_slave_ack>
        iic_write((i2c_addr >> 8) & 0xff);
   42058:	e0bffc17 	ldw	r2,-16(fp)
   4205c:	1005d23a 	srai	r2,r2,8
   42060:	10803fcc 	andi	r2,r2,255
   42064:	1009883a 	mov	r4,r2
   42068:	0041da00 	call	41da0 <iic_write>
        wait_slave_ack();
   4206c:	0041bc80 	call	41bc8 <wait_slave_ack>
        iic_write((i2c_addr >> 0) & 0xff);
   42070:	e0bffc17 	ldw	r2,-16(fp)
   42074:	10803fcc 	andi	r2,r2,255
   42078:	1009883a 	mov	r4,r2
   4207c:	0041da00 	call	41da0 <iic_write>
        wait_slave_ack();
   42080:	0041bc80 	call	41bc8 <wait_slave_ack>
        for(j = 0; j < EEPROM_PAGE_SIZE; j++)
   42084:	e03ffa8d 	sth	zero,-22(fp)
   42088:	00000f06 	br	420c8 <eeprom_write_page+0xf4>
        {
            iic_write(dat[i * EEPROM_PAGE_SIZE + j]);
   4208c:	e0bffa0b 	ldhu	r2,-24(fp)
   42090:	1006923a 	slli	r3,r2,8
   42094:	e0bffa8b 	ldhu	r2,-22(fp)
   42098:	1885883a 	add	r2,r3,r2
   4209c:	1007883a 	mov	r3,r2
   420a0:	e0bffe17 	ldw	r2,-8(fp)
   420a4:	10c5883a 	add	r2,r2,r3
   420a8:	10800003 	ldbu	r2,0(r2)
   420ac:	10803fcc 	andi	r2,r2,255
   420b0:	1009883a 	mov	r4,r2
   420b4:	0041da00 	call	41da0 <iic_write>
            wait_slave_ack();
   420b8:	0041bc80 	call	41bc8 <wait_slave_ack>
        wait_slave_ack();
        iic_write((i2c_addr >> 8) & 0xff);
        wait_slave_ack();
        iic_write((i2c_addr >> 0) & 0xff);
        wait_slave_ack();
        for(j = 0; j < EEPROM_PAGE_SIZE; j++)
   420bc:	e0bffa8b 	ldhu	r2,-22(fp)
   420c0:	10800044 	addi	r2,r2,1
   420c4:	e0bffa8d 	sth	r2,-22(fp)
   420c8:	e0bffa8b 	ldhu	r2,-22(fp)
   420cc:	10804030 	cmpltui	r2,r2,256
   420d0:	103fee1e 	bne	r2,zero,4208c <__alt_mem_epcs_flash+0xfffc108c>
        {
            iic_write(dat[i * EEPROM_PAGE_SIZE + j]);
            wait_slave_ack();
        }
        stop();
   420d4:	0041b380 	call	41b38 <stop>
        delay_us(10000);
   420d8:	0109c404 	movi	r4,10000
   420dc:	00402c80 	call	402c8 <delay_us>
    cmd = 0xa0 | ((addr >> 15) & 0x02);

    number = len / EEPROM_PAGE_SIZE;
    remain = len % EEPROM_PAGE_SIZE;

    for(i = 0; i < number; i++)
   420e0:	e0bffa0b 	ldhu	r2,-24(fp)
   420e4:	10800044 	addi	r2,r2,1
   420e8:	e0bffa0d 	sth	r2,-24(fp)
   420ec:	e0bffb43 	ldbu	r2,-19(fp)
   420f0:	10bfffcc 	andi	r2,r2,65535
   420f4:	e0fffa0b 	ldhu	r3,-24(fp)
   420f8:	18bfcc36 	bltu	r3,r2,4202c <__alt_mem_epcs_flash+0xfffc102c>
        }
        stop();
        delay_us(10000);
        //        usleep(5000);
    }
    if(remain != 0)
   420fc:	e0bffb83 	ldbu	r2,-18(fp)
   42100:	10002e26 	beq	r2,zero,421bc <eeprom_write_page+0x1e8>
    {
        i2c_addr = addr + number * EEPROM_PAGE_SIZE;
   42104:	e0bffb43 	ldbu	r2,-19(fp)
   42108:	1004923a 	slli	r2,r2,8
   4210c:	1007883a 	mov	r3,r2
   42110:	e0bffd17 	ldw	r2,-12(fp)
   42114:	1885883a 	add	r2,r3,r2
   42118:	e0bffc15 	stw	r2,-16(fp)
        start();
   4211c:	0041ac00 	call	41ac0 <start>
        iic_write(cmd);
   42120:	e0bffb03 	ldbu	r2,-20(fp)
   42124:	1009883a 	mov	r4,r2
   42128:	0041da00 	call	41da0 <iic_write>
        wait_slave_ack();
   4212c:	0041bc80 	call	41bc8 <wait_slave_ack>
        iic_write((i2c_addr >> 8) & 0xff);
   42130:	e0bffc17 	ldw	r2,-16(fp)
   42134:	1005d23a 	srai	r2,r2,8
   42138:	10803fcc 	andi	r2,r2,255
   4213c:	1009883a 	mov	r4,r2
   42140:	0041da00 	call	41da0 <iic_write>
        wait_slave_ack();
   42144:	0041bc80 	call	41bc8 <wait_slave_ack>
        iic_write((i2c_addr >> 0) & 0xff);
   42148:	e0bffc17 	ldw	r2,-16(fp)
   4214c:	10803fcc 	andi	r2,r2,255
   42150:	1009883a 	mov	r4,r2
   42154:	0041da00 	call	41da0 <iic_write>
        wait_slave_ack();
   42158:	0041bc80 	call	41bc8 <wait_slave_ack>
        for(j = 0; j < remain; j++)
   4215c:	e03ffa8d 	sth	zero,-22(fp)
   42160:	00000f06 	br	421a0 <eeprom_write_page+0x1cc>
        {
            iic_write(dat[number * EEPROM_PAGE_SIZE + j]);
   42164:	e0bffb43 	ldbu	r2,-19(fp)
   42168:	1006923a 	slli	r3,r2,8
   4216c:	e0bffa8b 	ldhu	r2,-22(fp)
   42170:	1885883a 	add	r2,r3,r2
   42174:	1007883a 	mov	r3,r2
   42178:	e0bffe17 	ldw	r2,-8(fp)
   4217c:	10c5883a 	add	r2,r2,r3
   42180:	10800003 	ldbu	r2,0(r2)
   42184:	10803fcc 	andi	r2,r2,255
   42188:	1009883a 	mov	r4,r2
   4218c:	0041da00 	call	41da0 <iic_write>
            wait_slave_ack();
   42190:	0041bc80 	call	41bc8 <wait_slave_ack>
        wait_slave_ack();
        iic_write((i2c_addr >> 8) & 0xff);
        wait_slave_ack();
        iic_write((i2c_addr >> 0) & 0xff);
        wait_slave_ack();
        for(j = 0; j < remain; j++)
   42194:	e0bffa8b 	ldhu	r2,-22(fp)
   42198:	10800044 	addi	r2,r2,1
   4219c:	e0bffa8d 	sth	r2,-22(fp)
   421a0:	e0bffb83 	ldbu	r2,-18(fp)
   421a4:	10bfffcc 	andi	r2,r2,65535
   421a8:	e0fffa8b 	ldhu	r3,-22(fp)
   421ac:	18bfed36 	bltu	r3,r2,42164 <__alt_mem_epcs_flash+0xfffc1164>
        {
            iic_write(dat[number * EEPROM_PAGE_SIZE + j]);
            wait_slave_ack();
        }
        stop();
   421b0:	0041b380 	call	41b38 <stop>
        delay_us(10000);
   421b4:	0109c404 	movi	r4,10000
   421b8:	00402c80 	call	402c8 <delay_us>
        //        usleep(5000);
    }
}
   421bc:	0001883a 	nop
   421c0:	e037883a 	mov	sp,fp
   421c4:	dfc00117 	ldw	ra,4(sp)
   421c8:	df000017 	ldw	fp,0(sp)
   421cc:	dec00204 	addi	sp,sp,8
   421d0:	f800283a 	ret

000421d4 <eeprom_read_byte>:
 * Name: read_byte
 * Description: 从EEPROM读一个字节
 * =================================================================
 */
alt_u8 eeprom_read_byte(alt_u32 addr)
{
   421d4:	defffc04 	addi	sp,sp,-16
   421d8:	dfc00315 	stw	ra,12(sp)
   421dc:	df000215 	stw	fp,8(sp)
   421e0:	df000204 	addi	fp,sp,8
   421e4:	e13fff15 	stw	r4,-4(fp)
    alt_u8 cmd, dat;

    if(addr > AT24C1024_MAX_ADDR)
   421e8:	e0ffff17 	ldw	r3,-4(fp)
   421ec:	008000b4 	movhi	r2,2
   421f0:	10b53004 	addi	r2,r2,-11072
   421f4:	10c0022e 	bgeu	r2,r3,42200 <eeprom_read_byte+0x2c>
        return 0xff;
   421f8:	00bfffc4 	movi	r2,-1
   421fc:	00002406 	br	42290 <eeprom_read_byte+0xbc>

    cmd = 0xa0 | ((addr >> 15) & 0x02);
   42200:	e0bfff17 	ldw	r2,-4(fp)
   42204:	1004d3fa 	srli	r2,r2,15
   42208:	1080008c 	andi	r2,r2,2
   4220c:	1007883a 	mov	r3,r2
   42210:	00bfe804 	movi	r2,-96
   42214:	1884b03a 	or	r2,r3,r2
   42218:	e0bffe05 	stb	r2,-8(fp)
    start();
   4221c:	0041ac00 	call	41ac0 <start>
    iic_write(cmd);
   42220:	e0bffe03 	ldbu	r2,-8(fp)
   42224:	1009883a 	mov	r4,r2
   42228:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   4222c:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write((addr >> 8) & 0xff);
   42230:	e0bfff17 	ldw	r2,-4(fp)
   42234:	1004d23a 	srli	r2,r2,8
   42238:	10803fcc 	andi	r2,r2,255
   4223c:	1009883a 	mov	r4,r2
   42240:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   42244:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write((addr >> 0) & 0xff);
   42248:	e0bfff17 	ldw	r2,-4(fp)
   4224c:	10803fcc 	andi	r2,r2,255
   42250:	1009883a 	mov	r4,r2
   42254:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   42258:	0041bc80 	call	41bc8 <wait_slave_ack>
    cmd |= 0x01;
   4225c:	e0bffe03 	ldbu	r2,-8(fp)
   42260:	10800054 	ori	r2,r2,1
   42264:	e0bffe05 	stb	r2,-8(fp)
    start();
   42268:	0041ac00 	call	41ac0 <start>
    iic_write(cmd);
   4226c:	e0bffe03 	ldbu	r2,-8(fp)
   42270:	1009883a 	mov	r4,r2
   42274:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   42278:	0041bc80 	call	41bc8 <wait_slave_ack>
    dat = iic_read();
   4227c:	0041e640 	call	41e64 <iic_read>
   42280:	e0bffe45 	stb	r2,-7(fp)
    no_ack();
   42284:	0041d080 	call	41d08 <no_ack>
    stop();
   42288:	0041b380 	call	41b38 <stop>
    return dat;
   4228c:	e0bffe43 	ldbu	r2,-7(fp)
}
   42290:	e037883a 	mov	sp,fp
   42294:	dfc00117 	ldw	ra,4(sp)
   42298:	df000017 	ldw	fp,0(sp)
   4229c:	dec00204 	addi	sp,sp,8
   422a0:	f800283a 	ret

000422a4 <eeprom_sequential_read>:

void eeprom_sequential_read(alt_u32 addr, alt_u8 *dat, alt_u16 len)
{
   422a4:	defffa04 	addi	sp,sp,-24
   422a8:	dfc00515 	stw	ra,20(sp)
   422ac:	df000415 	stw	fp,16(sp)
   422b0:	df000404 	addi	fp,sp,16
   422b4:	e13ffd15 	stw	r4,-12(fp)
   422b8:	e17ffe15 	stw	r5,-8(fp)
   422bc:	3005883a 	mov	r2,r6
   422c0:	e0bfff0d 	sth	r2,-4(fp)
    alt_u16 i;
    alt_u8  cmd;
    if(addr > AT24C1024_MAX_ADDR)
   422c4:	e0fffd17 	ldw	r3,-12(fp)
   422c8:	008000b4 	movhi	r2,2
   422cc:	10b53004 	addi	r2,r2,-11072
   422d0:	10c03436 	bltu	r2,r3,423a4 <eeprom_sequential_read+0x100>
        return;
    cmd = 0xa0 | ((addr >> 15) & 0x02);
   422d4:	e0bffd17 	ldw	r2,-12(fp)
   422d8:	1004d3fa 	srli	r2,r2,15
   422dc:	1080008c 	andi	r2,r2,2
   422e0:	1007883a 	mov	r3,r2
   422e4:	00bfe804 	movi	r2,-96
   422e8:	1884b03a 	or	r2,r3,r2
   422ec:	e0bffc85 	stb	r2,-14(fp)
    start();
   422f0:	0041ac00 	call	41ac0 <start>
    iic_write(cmd);
   422f4:	e0bffc83 	ldbu	r2,-14(fp)
   422f8:	1009883a 	mov	r4,r2
   422fc:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   42300:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write((addr >> 8) & 0xff);
   42304:	e0bffd17 	ldw	r2,-12(fp)
   42308:	1004d23a 	srli	r2,r2,8
   4230c:	10803fcc 	andi	r2,r2,255
   42310:	1009883a 	mov	r4,r2
   42314:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   42318:	0041bc80 	call	41bc8 <wait_slave_ack>
    iic_write((addr >> 0) & 0xff);
   4231c:	e0bffd17 	ldw	r2,-12(fp)
   42320:	10803fcc 	andi	r2,r2,255
   42324:	1009883a 	mov	r4,r2
   42328:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   4232c:	0041bc80 	call	41bc8 <wait_slave_ack>
    cmd |= 0x01;
   42330:	e0bffc83 	ldbu	r2,-14(fp)
   42334:	10800054 	ori	r2,r2,1
   42338:	e0bffc85 	stb	r2,-14(fp)
    start();
   4233c:	0041ac00 	call	41ac0 <start>
    iic_write(cmd);
   42340:	e0bffc83 	ldbu	r2,-14(fp)
   42344:	1009883a 	mov	r4,r2
   42348:	0041da00 	call	41da0 <iic_write>
    wait_slave_ack();
   4234c:	0041bc80 	call	41bc8 <wait_slave_ack>
    //    dat = iic_read();

    for(i = 0; i < len; i++)
   42350:	e03ffc0d 	sth	zero,-16(fp)
   42354:	00000b06 	br	42384 <eeprom_sequential_read+0xe0>
    {
        *dat = iic_read();
   42358:	0041e640 	call	41e64 <iic_read>
   4235c:	1007883a 	mov	r3,r2
   42360:	e0bffe17 	ldw	r2,-8(fp)
   42364:	10c00005 	stb	r3,0(r2)
        master_send_ack();
   42368:	0041c700 	call	41c70 <master_send_ack>
        dat++;
   4236c:	e0bffe17 	ldw	r2,-8(fp)
   42370:	10800044 	addi	r2,r2,1
   42374:	e0bffe15 	stw	r2,-8(fp)
    start();
    iic_write(cmd);
    wait_slave_ack();
    //    dat = iic_read();

    for(i = 0; i < len; i++)
   42378:	e0bffc0b 	ldhu	r2,-16(fp)
   4237c:	10800044 	addi	r2,r2,1
   42380:	e0bffc0d 	sth	r2,-16(fp)
   42384:	e0fffc0b 	ldhu	r3,-16(fp)
   42388:	e0bfff0b 	ldhu	r2,-4(fp)
   4238c:	18bff236 	bltu	r3,r2,42358 <__alt_mem_epcs_flash+0xfffc1358>
    {
        *dat = iic_read();
        master_send_ack();
        dat++;
    }
    no_ack();
   42390:	0041d080 	call	41d08 <no_ack>
    stop();
   42394:	0041b380 	call	41b38 <stop>
    eeprom_read_byte(addr);
   42398:	e13ffd17 	ldw	r4,-12(fp)
   4239c:	00421d40 	call	421d4 <eeprom_read_byte>
   423a0:	00000106 	br	423a8 <eeprom_sequential_read+0x104>
void eeprom_sequential_read(alt_u32 addr, alt_u8 *dat, alt_u16 len)
{
    alt_u16 i;
    alt_u8  cmd;
    if(addr > AT24C1024_MAX_ADDR)
        return;
   423a4:	0001883a 	nop
        dat++;
    }
    no_ack();
    stop();
    eeprom_read_byte(addr);
}
   423a8:	e037883a 	mov	sp,fp
   423ac:	dfc00117 	ldw	ra,4(sp)
   423b0:	df000017 	ldw	fp,0(sp)
   423b4:	dec00204 	addi	sp,sp,8
   423b8:	f800283a 	ret

000423bc <led_power_light>:

led_time_flag_t led_time_flag;

// 电源指示灯 绿色
void led_power_light(unsigned char status)
{
   423bc:	defffe04 	addi	sp,sp,-8
   423c0:	df000115 	stw	fp,4(sp)
   423c4:	df000104 	addi	fp,sp,4
   423c8:	2005883a 	mov	r2,r4
   423cc:	e0bfff05 	stb	r2,-4(fp)
    IOWR_ALTERA_AVALON_PIO_DATA(POWER_LED_BASE, status);
   423d0:	e0ffff03 	ldbu	r3,-4(fp)
   423d4:	00800234 	movhi	r2,8
   423d8:	10885804 	addi	r2,r2,8544
   423dc:	10c00035 	stwio	r3,0(r2)
}
   423e0:	0001883a 	nop
   423e4:	e037883a 	mov	sp,fp
   423e8:	df000017 	ldw	fp,0(sp)
   423ec:	dec00104 	addi	sp,sp,4
   423f0:	f800283a 	ret

000423f4 <led_status_light>:

// 状态指示灯 红色
void led_status_light(unsigned char status)
{
   423f4:	defffe04 	addi	sp,sp,-8
   423f8:	df000115 	stw	fp,4(sp)
   423fc:	df000104 	addi	fp,sp,4
   42400:	2005883a 	mov	r2,r4
   42404:	e0bfff05 	stb	r2,-4(fp)
    IOWR_ALTERA_AVALON_PIO_DATA(STATUS_LED_BASE, status);
   42408:	e0ffff03 	ldbu	r3,-4(fp)
   4240c:	00800234 	movhi	r2,8
   42410:	10885404 	addi	r2,r2,8528
   42414:	10c00035 	stwio	r3,0(r2)
}
   42418:	0001883a 	nop
   4241c:	e037883a 	mov	sp,fp
   42420:	df000017 	ldw	fp,0(sp)
   42424:	dec00104 	addi	sp,sp,4
   42428:	f800283a 	ret

0004242c <init_avalon_fifo>:
#include "socket.h"
#include "user_interrupt.h"
#include "w5500.h"

void init_avalon_fifo(void)
{
   4242c:	defffe04 	addi	sp,sp,-8
   42430:	dfc00115 	stw	ra,4(sp)
   42434:	df000015 	stw	fp,0(sp)
   42438:	d839883a 	mov	fp,sp
    altera_avalon_fifo_init(PROTOCOL_FIFO_IN_CSR_BASE, 0, 2, PROTOCOL_FIFO_IN_FIFO_DEPTH - 2);
   4243c:	01c0ff84 	movi	r7,1022
   42440:	01800084 	movi	r6,2
   42444:	000b883a 	mov	r5,zero
   42448:	01000234 	movhi	r4,8
   4244c:	21084004 	addi	r4,r4,8448
   42450:	004a9c40 	call	4a9c4 <altera_avalon_fifo_init>
    altera_avalon_fifo_init(LASER_FIFO_IN_CSR_BASE, 0, 2, LASER_FIFO_OUT_FIFO_DEPTH - 2);
   42454:	01c1ff84 	movi	r7,2046
   42458:	01800084 	movi	r6,2
   4245c:	000b883a 	mov	r5,zero
   42460:	01000234 	movhi	r4,8
   42464:	21084804 	addi	r4,r4,8480
   42468:	004a9c40 	call	4a9c4 <altera_avalon_fifo_init>
    altera_avalon_fifo_init(SPIWR_FIFO_IN_CSR_BASE, 0, 2, 120);
   4246c:	01c01e04 	movi	r7,120
   42470:	01800084 	movi	r6,2
   42474:	000b883a 	mov	r5,zero
   42478:	01000234 	movhi	r4,8
   4247c:	21083804 	addi	r4,r4,8416
   42480:	004a9c40 	call	4a9c4 <altera_avalon_fifo_init>
    altera_avalon_fifo_init(SPIRD_FIFO_IN_CSR_BASE, 0, 2, 120);
   42484:	01c01e04 	movi	r7,120
   42488:	01800084 	movi	r6,2
   4248c:	000b883a 	mov	r5,zero
   42490:	01000234 	movhi	r4,8
   42494:	21083004 	addi	r4,r4,8384
   42498:	004a9c40 	call	4a9c4 <altera_avalon_fifo_init>
}
   4249c:	0001883a 	nop
   424a0:	e037883a 	mov	sp,fp
   424a4:	dfc00117 	ldw	ra,4(sp)
   424a8:	df000017 	ldw	fp,0(sp)
   424ac:	dec00204 	addi	sp,sp,8
   424b0:	f800283a 	ret

000424b4 <main>:

int main()
{
   424b4:	defffb04 	addi	sp,sp,-20
   424b8:	dfc00415 	stw	ra,16(sp)
   424bc:	df000315 	stw	fp,12(sp)
   424c0:	df000304 	addi	fp,sp,12
#if 0
    test();
#else
    unsigned int len, offset, recv_data;
    init_avalon_fifo();
   424c4:	004242c0 	call	4242c <init_avalon_fifo>
    IINCHIP_CSon();
   424c8:	00480080 	call	48008 <IINCHIP_CSon>

    /***** 硬重启W5500 *****/
    Reset_W5500();
   424cc:	0040b780 	call	40b78 <Reset_W5500>
    IOWR_ALTERA_AVALON_PIO_DATA(POWER_LED_BASE, LED_ON);
   424d0:	0007883a 	mov	r3,zero
   424d4:	00800234 	movhi	r2,8
   424d8:	10885804 	addi	r2,r2,8544
   424dc:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_PIO_DATA(STATUS_LED_BASE, LED_OFF);
   424e0:	00c00044 	movi	r3,1
   424e4:	00800234 	movhi	r2,8
   424e8:	10885404 	addi	r2,r2,8528
   424ec:	10c00035 	stwio	r3,0(r2)

    /***** W5500的IP信息初始化 *****/
    delay_ms(500);
   424f0:	01007d04 	movi	r4,500
   424f4:	00402800 	call	40280 <delay_ms>
    set_default();  // 设置默认MAC、IP、GW、SUB、DNS
   424f8:	0040ca00 	call	40ca0 <set_default>
    set_network();  // 配置初始化IP信息并打印，初始化8个Socket
   424fc:	0040c140 	call	40c14 <set_network>
    /***** 打开W5500的Keepalive功能 *****/
    //     setkeepalive(0);

    alarm_region.change_region_value = rd_switch_io_value();
   42500:	0045d3c0 	call	45d3c <rd_switch_io_value>
   42504:	1007883a 	mov	r3,r2
   42508:	008001b4 	movhi	r2,6
   4250c:	10a5c204 	addi	r2,r2,-26872
   42510:	10c000c5 	stb	r3,3(r2)
    alarm_region.change_region_flag  = 0x01;
   42514:	008001b4 	movhi	r2,6
   42518:	10a5c204 	addi	r2,r2,-26872
   4251c:	00c00044 	movi	r3,1
   42520:	10c00085 	stb	r3,2(r2)
    isPowerUp                        = 0x01;
   42524:	00800044 	movi	r2,1
   42528:	d0a01505 	stb	r2,-32684(gp)
    // 从默认地址读取数据作为默认报警区域
    region_read_from_rom(&alarm_region, alarm_region.change_region_value * 3);
   4252c:	008001b4 	movhi	r2,6
   42530:	10a5c204 	addi	r2,r2,-26872
   42534:	108000c3 	ldbu	r2,3(r2)
   42538:	10c03fcc 	andi	r3,r2,255
   4253c:	1805883a 	mov	r2,r3
   42540:	1085883a 	add	r2,r2,r2
   42544:	10c5883a 	add	r2,r2,r3
   42548:	100b883a 	mov	r5,r2
   4254c:	010001b4 	movhi	r4,6
   42550:	2125c204 	addi	r4,r4,-26872
   42554:	0045ad40 	call	45ad4 <region_read_from_rom>
    region_read_from_rom(&alarm_region, alarm_region.change_region_value * 3 + 1);
   42558:	008001b4 	movhi	r2,6
   4255c:	10a5c204 	addi	r2,r2,-26872
   42560:	108000c3 	ldbu	r2,3(r2)
   42564:	10c03fcc 	andi	r3,r2,255
   42568:	1805883a 	mov	r2,r3
   4256c:	1085883a 	add	r2,r2,r2
   42570:	10c5883a 	add	r2,r2,r3
   42574:	10800044 	addi	r2,r2,1
   42578:	100b883a 	mov	r5,r2
   4257c:	010001b4 	movhi	r4,6
   42580:	2125c204 	addi	r4,r4,-26872
   42584:	0045ad40 	call	45ad4 <region_read_from_rom>
    region_read_from_rom(&alarm_region, alarm_region.change_region_value * 3 + 2);
   42588:	008001b4 	movhi	r2,6
   4258c:	10a5c204 	addi	r2,r2,-26872
   42590:	108000c3 	ldbu	r2,3(r2)
   42594:	10c03fcc 	andi	r3,r2,255
   42598:	1805883a 	mov	r2,r3
   4259c:	1085883a 	add	r2,r2,r2
   425a0:	10c5883a 	add	r2,r2,r3
   425a4:	10800084 	addi	r2,r2,2
   425a8:	100b883a 	mov	r5,r2
   425ac:	010001b4 	movhi	r4,6
   425b0:	2125c204 	addi	r4,r4,-26872
   425b4:	0045ad40 	call	45ad4 <region_read_from_rom>
    read_sys_para(&SysPara);
   425b8:	010001b4 	movhi	r4,6
   425bc:	21256c04 	addi	r4,r4,-27216
   425c0:	0045ba80 	call	45ba8 <read_sys_para>
    init_fpga_sys();
   425c4:	00430100 	call	43010 <init_fpga_sys>
    timer_initial();
   425c8:	0047aa40 	call	47aa4 <timer_initial>
    //    alarm_select_pio_initial();
        watchdog_init();
   425cc:	0047f780 	call	47f78 <watchdog_init>
    queue_init(&LaserDataQueue, &LaserData[0], 2048);
   425d0:	01820004 	movi	r6,2048
   425d4:	014001b4 	movhi	r5,6
   425d8:	29781d04 	addi	r5,r5,-8076
   425dc:	010001b4 	movhi	r4,6
   425e0:	21380104 	addi	r4,r4,-8188
   425e4:	00456000 	call	45600 <queue_init>
    while(1)
    {
        tim561_run();
   425e8:	00403340 	call	40334 <tim561_run>
        while(fpga_is_has_data())
   425ec:	00001c06 	br	42660 <main+0x1ac>
        {
            if(queue_is_full(&LaserDataQueue))
   425f0:	010001b4 	movhi	r4,6
   425f4:	21380104 	addi	r4,r4,-8188
   425f8:	004583c0 	call	4583c <queue_is_full>
   425fc:	10803fcc 	andi	r2,r2,255
   42600:	10000326 	beq	r2,zero,42610 <main+0x15c>
                queue_clear(&LaserDataQueue);
   42604:	010001b4 	movhi	r4,6
   42608:	21380104 	addi	r4,r4,-8188
   4260c:	004568c0 	call	4568c <queue_clear>
            recv_data = read_fpga_data();
   42610:	00410740 	call	41074 <read_fpga_data>
   42614:	e0bffe15 	stw	r2,-8(fp)
            if(recv_data >> 16 == FRAME_HEAD)
   42618:	e0bffe17 	ldw	r2,-8(fp)
   4261c:	1004d43a 	srli	r2,r2,16
   42620:	10848d18 	cmpnei	r2,r2,4660
   42624:	1000011e 	bne	r2,zero,4262c <main+0x178>
                len = 0;
   42628:	e03fff15 	stw	zero,-4(fp)

            queue_push(&LaserDataQueue, recv_data);
   4262c:	e17ffe17 	ldw	r5,-8(fp)
   42630:	010001b4 	movhi	r4,6
   42634:	21380104 	addi	r4,r4,-8188
   42638:	00456c80 	call	456c8 <queue_push>
            if((recv_data & 0xffff) == 0xeeee)
   4263c:	e0bffe17 	ldw	r2,-8(fp)
   42640:	10ffffcc 	andi	r3,r2,65535
   42644:	00bbbb94 	movui	r2,61166
   42648:	1880051e 	bne	r3,r2,42660 <main+0x1ac>
            {
                LaserDataQueue.frame_over_flag = 0x01;
   4264c:	008001b4 	movhi	r2,6
   42650:	10b80104 	addi	r2,r2,-8188
   42654:	00c00044 	movi	r3,1
   42658:	10c00315 	stw	r3,12(r2)
                break;
   4265c:	00000306 	br	4266c <main+0x1b8>
        watchdog_init();
    queue_init(&LaserDataQueue, &LaserData[0], 2048);
    while(1)
    {
        tim561_run();
        while(fpga_is_has_data())
   42660:	004102c0 	call	4102c <fpga_is_has_data>
   42664:	10803fcc 	andi	r2,r2,255
   42668:	103fe11e 	bne	r2,zero,425f0 <__alt_mem_epcs_flash+0xfffc15f0>
            {
                LaserDataQueue.frame_over_flag = 0x01;
                break;
            }
        }
        if(LaserDataQueue.frame_over_flag == 0x01)
   4266c:	008001b4 	movhi	r2,6
   42670:	10b80104 	addi	r2,r2,-8188
   42674:	10800317 	ldw	r2,12(r2)
   42678:	10800058 	cmpnei	r2,r2,1
   4267c:	1000041e 	bne	r2,zero,42690 <main+0x1dc>
        {
            fpga2nios_parse();
   42680:	00410b80 	call	410b8 <fpga2nios_parse>
            LaserDataQueue.frame_over_flag = 0x00;
   42684:	008001b4 	movhi	r2,6
   42688:	10b80104 	addi	r2,r2,-8188
   4268c:	10000315 	stw	zero,12(r2)
            //            if(queue_is_empty(&LaserDataQueue))
            //            	LaserDataQueue.frame_over_flag = 0x00;
        }
        // 打包 获得数据到(sick数据协议) send_buffer;
        if(CycleData.pos_finish)
   42690:	008001b4 	movhi	r2,6
   42694:	10802104 	addi	r2,r2,132
   42698:	10800003 	ldbu	r2,0(r2)
   4269c:	10803fcc 	andi	r2,r2,255
   426a0:	10009926 	beq	r2,zero,42908 <main+0x454>
        {
            CycleData.pos_finish = false;
   426a4:	008001b4 	movhi	r2,6
   426a8:	10802104 	addi	r2,r2,132
   426ac:	10000005 	stb	zero,0(r2)
            sick_pos_packet();
   426b0:	00468d40 	call	468d4 <sick_pos_packet>
            offset = 0;
   426b4:	e03ffd15 	stw	zero,-12(fp)

            while(1)  // 分包发送
            {
                IOWR_ALTERA_AVALON_PIO_DATA(W5500_INT_BASE, 0x01);
   426b8:	00c00044 	movi	r3,1
   426bc:	00800234 	movhi	r2,8
   426c0:	10886804 	addi	r2,r2,8608
   426c4:	10c00035 	stwio	r3,0(r2)
                len = strlen((char *)send_buffer);
   426c8:	010001b4 	movhi	r4,6
   426cc:	21081004 	addi	r4,r4,8256
   426d0:	00497200 	call	49720 <strlen>
   426d4:	e0bfff15 	stw	r2,-4(fp)
                if(len - offset >= 1460)
   426d8:	e0ffff17 	ldw	r3,-4(fp)
   426dc:	e0bffd17 	ldw	r2,-12(fp)
   426e0:	1885c83a 	sub	r2,r3,r2
   426e4:	10816d30 	cmpltui	r2,r2,1460
   426e8:	1000141e 	bne	r2,zero,4273c <main+0x288>
                {
                    send(SOCKET0, send_buffer + offset, 1460);
   426ec:	e0fffd17 	ldw	r3,-12(fp)
   426f0:	008001b4 	movhi	r2,6
   426f4:	10881004 	addi	r2,r2,8256
   426f8:	1885883a 	add	r2,r3,r2
   426fc:	01816d04 	movi	r6,1460
   42700:	100b883a 	mov	r5,r2
   42704:	0009883a 	mov	r4,zero
   42708:	004709c0 	call	4709c <send>
                    send(SOCKET1, send_buffer + offset, 1460);
   4270c:	e0fffd17 	ldw	r3,-12(fp)
   42710:	008001b4 	movhi	r2,6
   42714:	10881004 	addi	r2,r2,8256
   42718:	1885883a 	add	r2,r3,r2
   4271c:	01816d04 	movi	r6,1460
   42720:	100b883a 	mov	r5,r2
   42724:	01000044 	movi	r4,1
   42728:	004709c0 	call	4709c <send>
                    offset += 1460;
   4272c:	e0bffd17 	ldw	r2,-12(fp)
   42730:	10816d04 	addi	r2,r2,1460
   42734:	e0bffd15 	stw	r2,-12(fp)
   42738:	003fdf06 	br	426b8 <__alt_mem_epcs_flash+0xfffc16b8>
                }
                else if((len - offset < 1460) && (len - offset > 0))
   4273c:	e0ffff17 	ldw	r3,-4(fp)
   42740:	e0bffd17 	ldw	r2,-12(fp)
   42744:	1885c83a 	sub	r2,r3,r2
   42748:	10816d28 	cmpgeui	r2,r2,1460
   4274c:	10006e1e 	bne	r2,zero,42908 <main+0x454>
   42750:	e0ffff17 	ldw	r3,-4(fp)
   42754:	e0bffd17 	ldw	r2,-12(fp)
   42758:	18806b26 	beq	r3,r2,42908 <main+0x454>
                {
                    send(SOCKET0, send_buffer + offset, len - offset);
   4275c:	e0fffd17 	ldw	r3,-12(fp)
   42760:	008001b4 	movhi	r2,6
   42764:	10881004 	addi	r2,r2,8256
   42768:	1885883a 	add	r2,r3,r2
   4276c:	e0ffff17 	ldw	r3,-4(fp)
   42770:	1809883a 	mov	r4,r3
   42774:	e0fffd17 	ldw	r3,-12(fp)
   42778:	20c7c83a 	sub	r3,r4,r3
   4277c:	18ffffcc 	andi	r3,r3,65535
   42780:	180d883a 	mov	r6,r3
   42784:	100b883a 	mov	r5,r2
   42788:	0009883a 	mov	r4,zero
   4278c:	004709c0 	call	4709c <send>
                    send(SOCKET1, send_buffer + offset, len - offset);
   42790:	e0fffd17 	ldw	r3,-12(fp)
   42794:	008001b4 	movhi	r2,6
   42798:	10881004 	addi	r2,r2,8256
   4279c:	1885883a 	add	r2,r3,r2
   427a0:	e0ffff17 	ldw	r3,-4(fp)
   427a4:	1809883a 	mov	r4,r3
   427a8:	e0fffd17 	ldw	r3,-12(fp)
   427ac:	20c7c83a 	sub	r3,r4,r3
   427b0:	18ffffcc 	andi	r3,r3,65535
   427b4:	180d883a 	mov	r6,r3
   427b8:	100b883a 	mov	r5,r2
   427bc:	01000044 	movi	r4,1
   427c0:	004709c0 	call	4709c <send>
                    IOWR_ALTERA_AVALON_PIO_DATA(W5500_INT_BASE, 0x00);
   427c4:	0007883a 	mov	r3,zero
   427c8:	00800234 	movhi	r2,8
   427cc:	10886804 	addi	r2,r2,8608
   427d0:	10c00035 	stwio	r3,0(r2)

                    // if(sys_warn.region_alarm != 0)
                    {
                        send_buffer[0]  = 0x12;
   427d4:	008001b4 	movhi	r2,6
   427d8:	10881004 	addi	r2,r2,8256
   427dc:	00c00484 	movi	r3,18
   427e0:	10c00005 	stb	r3,0(r2)
                        send_buffer[1]  = 0x34;
   427e4:	008001b4 	movhi	r2,6
   427e8:	10881004 	addi	r2,r2,8256
   427ec:	00c00d04 	movi	r3,52
   427f0:	10c00045 	stb	r3,1(r2)
                        send_buffer[2]  = (UP_ALARM_REGION_STATUS >> 8) & 0xff;
   427f4:	008001b4 	movhi	r2,6
   427f8:	10881004 	addi	r2,r2,8256
   427fc:	00fff044 	movi	r3,-63
   42800:	10c00085 	stb	r3,2(r2)
                        send_buffer[3]  = (UP_ALARM_REGION_STATUS >> 0) & 0xff;
   42804:	008001b4 	movhi	r2,6
   42808:	10881004 	addi	r2,r2,8256
   4280c:	00c00044 	movi	r3,1
   42810:	10c000c5 	stb	r3,3(r2)
                        send_buffer[4]  = 0;
   42814:	008001b4 	movhi	r2,6
   42818:	10881004 	addi	r2,r2,8256
   4281c:	10000105 	stb	zero,4(r2)
                        send_buffer[5]  = 0;
   42820:	008001b4 	movhi	r2,6
   42824:	10881004 	addi	r2,r2,8256
   42828:	10000145 	stb	zero,5(r2)
                        send_buffer[6]  = 0;
   4282c:	008001b4 	movhi	r2,6
   42830:	10881004 	addi	r2,r2,8256
   42834:	10000185 	stb	zero,6(r2)
                        send_buffer[7]  = 4;
   42838:	008001b4 	movhi	r2,6
   4283c:	10881004 	addi	r2,r2,8256
   42840:	00c00104 	movi	r3,4
   42844:	10c001c5 	stb	r3,7(r2)
                        send_buffer[8]  = 0;
   42848:	008001b4 	movhi	r2,6
   4284c:	10881004 	addi	r2,r2,8256
   42850:	10000205 	stb	zero,8(r2)
                        send_buffer[9]  = 0;
   42854:	008001b4 	movhi	r2,6
   42858:	10881004 	addi	r2,r2,8256
   4285c:	10000245 	stb	zero,9(r2)
                        send_buffer[10] = 0;
   42860:	008001b4 	movhi	r2,6
   42864:	10881004 	addi	r2,r2,8256
   42868:	10000285 	stb	zero,10(r2)
                        send_buffer[11] = (unsigned char)sys_warn.region_alarm;
   4286c:	008001b4 	movhi	r2,6
   42870:	10b46104 	addi	r2,r2,-11900
   42874:	10800417 	ldw	r2,16(r2)
   42878:	1007883a 	mov	r3,r2
   4287c:	008001b4 	movhi	r2,6
   42880:	10881004 	addi	r2,r2,8256
   42884:	10c002c5 	stb	r3,11(r2)
                        send_buffer[12] = send_buffer[13] = send_buffer[14] = send_buffer[15] = 0xee;  // 当做校验码
   42888:	008001b4 	movhi	r2,6
   4288c:	10881004 	addi	r2,r2,8256
   42890:	00fffb84 	movi	r3,-18
   42894:	10c003c5 	stb	r3,15(r2)
   42898:	008001b4 	movhi	r2,6
   4289c:	10881004 	addi	r2,r2,8256
   428a0:	10c003c3 	ldbu	r3,15(r2)
   428a4:	008001b4 	movhi	r2,6
   428a8:	10881004 	addi	r2,r2,8256
   428ac:	10c00385 	stb	r3,14(r2)
   428b0:	008001b4 	movhi	r2,6
   428b4:	10881004 	addi	r2,r2,8256
   428b8:	10c00383 	ldbu	r3,14(r2)
   428bc:	008001b4 	movhi	r2,6
   428c0:	10881004 	addi	r2,r2,8256
   428c4:	10c00345 	stb	r3,13(r2)
   428c8:	008001b4 	movhi	r2,6
   428cc:	10881004 	addi	r2,r2,8256
   428d0:	10c00343 	ldbu	r3,13(r2)
   428d4:	008001b4 	movhi	r2,6
   428d8:	10881004 	addi	r2,r2,8256
   428dc:	10c00305 	stb	r3,12(r2)
                        send(SOCKET0, send_buffer, 16);
   428e0:	01800404 	movi	r6,16
   428e4:	014001b4 	movhi	r5,6
   428e8:	29481004 	addi	r5,r5,8256
   428ec:	0009883a 	mov	r4,zero
   428f0:	004709c0 	call	4709c <send>
                        send(SOCKET1, send_buffer, 16);
   428f4:	01800404 	movi	r6,16
   428f8:	014001b4 	movhi	r5,6
   428fc:	29481004 	addi	r5,r5,8256
   42900:	01000044 	movi	r4,1
   42904:	004709c0 	call	4709c <send>
                else
                    break;
            }
        }

        if(sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm)
   42908:	008001b4 	movhi	r2,6
   4290c:	10b46104 	addi	r2,r2,-11900
   42910:	10c00017 	ldw	r3,0(r2)
   42914:	008001b4 	movhi	r2,6
   42918:	10b46104 	addi	r2,r2,-11900
   4291c:	10800117 	ldw	r2,4(r2)
   42920:	1884b03a 	or	r2,r3,r2
   42924:	10001626 	beq	r2,zero,42980 <main+0x4cc>
        {
             led_status_light(LED_ON);
   42928:	0009883a 	mov	r4,zero
   4292c:	00423f40 	call	423f4 <led_status_light>
             set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ,
            		 sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm | sys_warn.temp_out_alarm | sys_warn.window_dust_alarm);
   42930:	008001b4 	movhi	r2,6
   42934:	10b46104 	addi	r2,r2,-11900
   42938:	10c00017 	ldw	r3,0(r2)
   4293c:	008001b4 	movhi	r2,6
   42940:	10b46104 	addi	r2,r2,-11900
   42944:	10800117 	ldw	r2,4(r2)
   42948:	1886b03a 	or	r3,r3,r2
   4294c:	008001b4 	movhi	r2,6
   42950:	10b46104 	addi	r2,r2,-11900
   42954:	10800317 	ldw	r2,12(r2)
   42958:	1886b03a 	or	r3,r3,r2
   4295c:	008001b4 	movhi	r2,6
   42960:	10b46104 	addi	r2,r2,-11900
   42964:	10800217 	ldw	r2,8(r2)
        }

        if(sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm)
        {
             led_status_light(LED_ON);
             set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ,
   42968:	1884b03a 	or	r2,r3,r2
   4296c:	100d883a 	mov	r6,r2
   42970:	01684054 	movui	r5,41217
   42974:	d1201604 	addi	r4,gp,-32680
   42978:	0042fa00 	call	42fa0 <set_laser_paramter>
   4297c:	00005f06 	br	42afc <main+0x648>
            		 sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm | sys_warn.temp_out_alarm | sys_warn.window_dust_alarm);
        }
        else if(sys_warn.window_dust_alarm)
   42980:	008001b4 	movhi	r2,6
   42984:	10b46104 	addi	r2,r2,-11900
   42988:	10800217 	ldw	r2,8(r2)
   4298c:	10002c26 	beq	r2,zero,42a40 <main+0x58c>
        {
              if(led_time_flag.status_led_1s_flag)
   42990:	008001b4 	movhi	r2,6
   42994:	10801d04 	addi	r2,r2,116
   42998:	108001c3 	ldbu	r2,7(r2)
   4299c:	10803fcc 	andi	r2,r2,255
   429a0:	10001326 	beq	r2,zero,429f0 <main+0x53c>
                   {
                         led_time_flag.status_led_1s_flag = 0x00;
   429a4:	008001b4 	movhi	r2,6
   429a8:	10801d04 	addi	r2,r2,116
   429ac:	100001c5 	stb	zero,7(r2)
                         led_time_flag.status_led_value   = (~led_time_flag.status_led_value) & 0x01;
   429b0:	008001b4 	movhi	r2,6
   429b4:	10801d04 	addi	r2,r2,116
   429b8:	10800043 	ldbu	r2,1(r2)
   429bc:	10803fcc 	andi	r2,r2,255
   429c0:	1080004c 	andi	r2,r2,1
   429c4:	1005003a 	cmpeq	r2,r2,zero
   429c8:	1007883a 	mov	r3,r2
   429cc:	008001b4 	movhi	r2,6
   429d0:	10801d04 	addi	r2,r2,116
   429d4:	10c00045 	stb	r3,1(r2)
                         led_status_light(led_time_flag.status_led_value);
   429d8:	008001b4 	movhi	r2,6
   429dc:	10801d04 	addi	r2,r2,116
   429e0:	10800043 	ldbu	r2,1(r2)
   429e4:	10803fcc 	andi	r2,r2,255
   429e8:	1009883a 	mov	r4,r2
   429ec:	00423f40 	call	423f4 <led_status_light>
                   }
                         set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ,
                                              sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm | sys_warn.temp_out_alarm | sys_warn.window_dust_alarm);
   429f0:	008001b4 	movhi	r2,6
   429f4:	10b46104 	addi	r2,r2,-11900
   429f8:	10c00017 	ldw	r3,0(r2)
   429fc:	008001b4 	movhi	r2,6
   42a00:	10b46104 	addi	r2,r2,-11900
   42a04:	10800117 	ldw	r2,4(r2)
   42a08:	1886b03a 	or	r3,r3,r2
   42a0c:	008001b4 	movhi	r2,6
   42a10:	10b46104 	addi	r2,r2,-11900
   42a14:	10800317 	ldw	r2,12(r2)
   42a18:	1886b03a 	or	r3,r3,r2
   42a1c:	008001b4 	movhi	r2,6
   42a20:	10b46104 	addi	r2,r2,-11900
   42a24:	10800217 	ldw	r2,8(r2)
                   {
                         led_time_flag.status_led_1s_flag = 0x00;
                         led_time_flag.status_led_value   = (~led_time_flag.status_led_value) & 0x01;
                         led_status_light(led_time_flag.status_led_value);
                   }
                         set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ,
   42a28:	1884b03a 	or	r2,r3,r2
   42a2c:	100d883a 	mov	r6,r2
   42a30:	01684054 	movui	r5,41217
   42a34:	d1201604 	addi	r4,gp,-32680
   42a38:	0042fa00 	call	42fa0 <set_laser_paramter>
   42a3c:	00002f06 	br	42afc <main+0x648>
                                              sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm | sys_warn.temp_out_alarm | sys_warn.window_dust_alarm);
         }
         else if(sys_warn.temp_out_alarm)
   42a40:	008001b4 	movhi	r2,6
   42a44:	10b46104 	addi	r2,r2,-11900
   42a48:	10800317 	ldw	r2,12(r2)
   42a4c:	10002b26 	beq	r2,zero,42afc <main+0x648>
         {
              if(led_time_flag.status_led_300ms_flag)
   42a50:	008001b4 	movhi	r2,6
   42a54:	10801d04 	addi	r2,r2,116
   42a58:	10800283 	ldbu	r2,10(r2)
   42a5c:	10803fcc 	andi	r2,r2,255
   42a60:	10001326 	beq	r2,zero,42ab0 <main+0x5fc>
                   {
                         led_time_flag.status_led_300ms_flag = 0x00;
   42a64:	008001b4 	movhi	r2,6
   42a68:	10801d04 	addi	r2,r2,116
   42a6c:	10000285 	stb	zero,10(r2)
                         led_time_flag.status_led_value      = (~led_time_flag.status_led_value) & 0x01;
   42a70:	008001b4 	movhi	r2,6
   42a74:	10801d04 	addi	r2,r2,116
   42a78:	10800043 	ldbu	r2,1(r2)
   42a7c:	10803fcc 	andi	r2,r2,255
   42a80:	1080004c 	andi	r2,r2,1
   42a84:	1005003a 	cmpeq	r2,r2,zero
   42a88:	1007883a 	mov	r3,r2
   42a8c:	008001b4 	movhi	r2,6
   42a90:	10801d04 	addi	r2,r2,116
   42a94:	10c00045 	stb	r3,1(r2)
                         led_status_light(led_time_flag.status_led_value);
   42a98:	008001b4 	movhi	r2,6
   42a9c:	10801d04 	addi	r2,r2,116
   42aa0:	10800043 	ldbu	r2,1(r2)
   42aa4:	10803fcc 	andi	r2,r2,255
   42aa8:	1009883a 	mov	r4,r2
   42aac:	00423f40 	call	423f4 <led_status_light>
                   }
                         set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ,
                                              sys_warn.motor_low_speed_alarm | sys_warn.ld_not_work_alarm | sys_warn.temp_out_alarm | sys_warn.window_dust_alarm);
   42ab0:	008001b4 	movhi	r2,6
   42ab4:	10b46104 	addi	r2,r2,-11900
   42ab8:	10c00017 	ldw	r3,0(r2)
   42abc:	008001b4 	movhi	r2,6
   42ac0:	10b46104 	addi	r2,r2,-11900
   42ac4:	10800117 	ldw	r2,4(r2)
   42ac8:	1886b03a 	or	r3,r3,r2
   42acc:	008001b4 	movhi	r2,6
   42ad0:	10b46104 	addi	r2,r2,-11900
   42ad4:	10800317 	ldw	r2,12(r2)
   42ad8:	1886b03a 	or	r3,r3,r2
   42adc:	008001b4 	movhi	r2,6
   42ae0:	10b46104 	addi	r2,r2,-11900
   42ae4:	10800217 	ldw	r2,8(r2)
                   {
                         led_time_flag.status_led_300ms_flag = 0x00;
                         led_time_flag.status_led_value      = (~led_time_flag.status_led_value) & 0x01;
                         led_status_light(led_time_flag.status_led_value);
                   }
                         set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ,
   42ae8:	1884b03a 	or	r2,r3,r2
   42aec:	100d883a 	mov	r6,r2
   42af0:	01684054 	movui	r5,41217
   42af4:	d1201604 	addi	r4,gp,-32680
   42af8:	0042fa00 	call	42fa0 <set_laser_paramter>
          }




         alarm_region.last_io_value[0] = rd_switch_io_value();
   42afc:	0045d3c0 	call	45d3c <rd_switch_io_value>
   42b00:	1007883a 	mov	r3,r2
   42b04:	008001b4 	movhi	r2,6
   42b08:	10a5c204 	addi	r2,r2,-26872
   42b0c:	10c00005 	stb	r3,0(r2)
         if(alarm_region.last_io_value[0] != alarm_region.last_io_value[1])
   42b10:	008001b4 	movhi	r2,6
   42b14:	10a5c204 	addi	r2,r2,-26872
   42b18:	10c00003 	ldbu	r3,0(r2)
   42b1c:	008001b4 	movhi	r2,6
   42b20:	10a5c204 	addi	r2,r2,-26872
   42b24:	10800043 	ldbu	r2,1(r2)
   42b28:	18c03fcc 	andi	r3,r3,255
   42b2c:	10803fcc 	andi	r2,r2,255
   42b30:	18800a26 	beq	r3,r2,42b5c <main+0x6a8>
         {
             alarm_region.change_region_flag = 0x01;
   42b34:	008001b4 	movhi	r2,6
   42b38:	10a5c204 	addi	r2,r2,-26872
   42b3c:	00c00044 	movi	r3,1
   42b40:	10c00085 	stb	r3,2(r2)
             alarm_region.change_region_value = alarm_region.last_io_value[0];
   42b44:	008001b4 	movhi	r2,6
   42b48:	10a5c204 	addi	r2,r2,-26872
   42b4c:	10c00003 	ldbu	r3,0(r2)
   42b50:	008001b4 	movhi	r2,6
   42b54:	10a5c204 	addi	r2,r2,-26872
   42b58:	10c000c5 	stb	r3,3(r2)
         }
         alarm_region.last_io_value[1] = alarm_region.last_io_value[0];
   42b5c:	008001b4 	movhi	r2,6
   42b60:	10a5c204 	addi	r2,r2,-26872
   42b64:	10c00003 	ldbu	r3,0(r2)
   42b68:	008001b4 	movhi	r2,6
   42b6c:	10a5c204 	addi	r2,r2,-26872
   42b70:	10c00045 	stb	r3,1(r2)

        if(isTcpEstablished & isPowerUp)  // 刚上电且TCP连接建立时，发送一次
   42b74:	d0e01303 	ldbu	r3,-32692(gp)
   42b78:	d0a01503 	ldbu	r2,-32684(gp)
   42b7c:	1884703a 	and	r2,r3,r2
   42b80:	10803fcc 	andi	r2,r2,255
   42b84:	10002426 	beq	r2,zero,42c18 <main+0x764>
        {
            isPowerUp        = 0x00;
   42b88:	d0201505 	stb	zero,-32684(gp)
            nios2pc.command  = UP_ALARM_IO_VALUE;
   42b8c:	008001b4 	movhi	r2,6
   42b90:	10a5bd04 	addi	r2,r2,-26892
   42b94:	00f04094 	movui	r3,49410
   42b98:	10c00115 	stw	r3,4(r2)
            nios2pc.data_len = 4;
   42b9c:	008001b4 	movhi	r2,6
   42ba0:	10a5bd04 	addi	r2,r2,-26892
   42ba4:	00c00104 	movi	r3,4
   42ba8:	10c00215 	stw	r3,8(r2)
            nios2pc.value    = alarm_region.change_region_value;
   42bac:	008001b4 	movhi	r2,6
   42bb0:	10a5c204 	addi	r2,r2,-26872
   42bb4:	108000c3 	ldbu	r2,3(r2)
   42bb8:	10c03fcc 	andi	r3,r2,255
   42bbc:	008001b4 	movhi	r2,6
   42bc0:	10a5bd04 	addi	r2,r2,-26892
   42bc4:	10c00315 	stw	r3,12(r2)
            len              = pc2dev_packet(&nios2pc, send_buffer);
   42bc8:	014001b4 	movhi	r5,6
   42bcc:	29481004 	addi	r5,r5,8256
   42bd0:	010001b4 	movhi	r4,6
   42bd4:	2125bd04 	addi	r4,r4,-26892
   42bd8:	0044e840 	call	44e84 <pc2dev_packet>
   42bdc:	e0bfff15 	stw	r2,-4(fp)
            send(SOCKET0, send_buffer, len);
   42be0:	e0bfff17 	ldw	r2,-4(fp)
   42be4:	10bfffcc 	andi	r2,r2,65535
   42be8:	100d883a 	mov	r6,r2
   42bec:	014001b4 	movhi	r5,6
   42bf0:	29481004 	addi	r5,r5,8256
   42bf4:	0009883a 	mov	r4,zero
   42bf8:	004709c0 	call	4709c <send>
            send(SOCKET1, send_buffer, len);
   42bfc:	e0bfff17 	ldw	r2,-4(fp)
   42c00:	10bfffcc 	andi	r2,r2,65535
   42c04:	100d883a 	mov	r6,r2
   42c08:	014001b4 	movhi	r5,6
   42c0c:	29481004 	addi	r5,r5,8256
   42c10:	01000044 	movi	r4,1
   42c14:	004709c0 	call	4709c <send>
        }

        if(alarm_region.change_region_flag == 0x01)
   42c18:	008001b4 	movhi	r2,6
   42c1c:	10a5c204 	addi	r2,r2,-26872
   42c20:	10800083 	ldbu	r2,2(r2)
   42c24:	10803fcc 	andi	r2,r2,255
   42c28:	10800058 	cmpnei	r2,r2,1
   42c2c:	1000491e 	bne	r2,zero,42d54 <main+0x8a0>
        {
            alarm_region.change_region_flag = 0x00;
   42c30:	008001b4 	movhi	r2,6
   42c34:	10a5c204 	addi	r2,r2,-26872
   42c38:	10000085 	stb	zero,2(r2)
            region_read_from_rom(&alarm_region, alarm_region.change_region_value * 3);
   42c3c:	008001b4 	movhi	r2,6
   42c40:	10a5c204 	addi	r2,r2,-26872
   42c44:	108000c3 	ldbu	r2,3(r2)
   42c48:	10c03fcc 	andi	r3,r2,255
   42c4c:	1805883a 	mov	r2,r3
   42c50:	1085883a 	add	r2,r2,r2
   42c54:	10c5883a 	add	r2,r2,r3
   42c58:	100b883a 	mov	r5,r2
   42c5c:	010001b4 	movhi	r4,6
   42c60:	2125c204 	addi	r4,r4,-26872
   42c64:	0045ad40 	call	45ad4 <region_read_from_rom>
            region_read_from_rom(&alarm_region, alarm_region.change_region_value * 3 + 1);
   42c68:	008001b4 	movhi	r2,6
   42c6c:	10a5c204 	addi	r2,r2,-26872
   42c70:	108000c3 	ldbu	r2,3(r2)
   42c74:	10c03fcc 	andi	r3,r2,255
   42c78:	1805883a 	mov	r2,r3
   42c7c:	1085883a 	add	r2,r2,r2
   42c80:	10c5883a 	add	r2,r2,r3
   42c84:	10800044 	addi	r2,r2,1
   42c88:	100b883a 	mov	r5,r2
   42c8c:	010001b4 	movhi	r4,6
   42c90:	2125c204 	addi	r4,r4,-26872
   42c94:	0045ad40 	call	45ad4 <region_read_from_rom>
            region_read_from_rom(&alarm_region, alarm_region.change_region_value * 3 + 2);
   42c98:	008001b4 	movhi	r2,6
   42c9c:	10a5c204 	addi	r2,r2,-26872
   42ca0:	108000c3 	ldbu	r2,3(r2)
   42ca4:	10c03fcc 	andi	r3,r2,255
   42ca8:	1805883a 	mov	r2,r3
   42cac:	1085883a 	add	r2,r2,r2
   42cb0:	10c5883a 	add	r2,r2,r3
   42cb4:	10800084 	addi	r2,r2,2
   42cb8:	100b883a 	mov	r5,r2
   42cbc:	010001b4 	movhi	r4,6
   42cc0:	2125c204 	addi	r4,r4,-26872
   42cc4:	0045ad40 	call	45ad4 <region_read_from_rom>

            //            if(isTcpEstablished)
            {
                nios2pc.command  = UP_ALARM_IO_VALUE;
   42cc8:	008001b4 	movhi	r2,6
   42ccc:	10a5bd04 	addi	r2,r2,-26892
   42cd0:	00f04094 	movui	r3,49410
   42cd4:	10c00115 	stw	r3,4(r2)
                nios2pc.data_len = 4;
   42cd8:	008001b4 	movhi	r2,6
   42cdc:	10a5bd04 	addi	r2,r2,-26892
   42ce0:	00c00104 	movi	r3,4
   42ce4:	10c00215 	stw	r3,8(r2)
                nios2pc.value    = alarm_region.change_region_value;
   42ce8:	008001b4 	movhi	r2,6
   42cec:	10a5c204 	addi	r2,r2,-26872
   42cf0:	108000c3 	ldbu	r2,3(r2)
   42cf4:	10c03fcc 	andi	r3,r2,255
   42cf8:	008001b4 	movhi	r2,6
   42cfc:	10a5bd04 	addi	r2,r2,-26892
   42d00:	10c00315 	stw	r3,12(r2)
                len              = pc2dev_packet(&nios2pc, send_buffer);
   42d04:	014001b4 	movhi	r5,6
   42d08:	29481004 	addi	r5,r5,8256
   42d0c:	010001b4 	movhi	r4,6
   42d10:	2125bd04 	addi	r4,r4,-26892
   42d14:	0044e840 	call	44e84 <pc2dev_packet>
   42d18:	e0bfff15 	stw	r2,-4(fp)
                send(SOCKET0, send_buffer, len);
   42d1c:	e0bfff17 	ldw	r2,-4(fp)
   42d20:	10bfffcc 	andi	r2,r2,65535
   42d24:	100d883a 	mov	r6,r2
   42d28:	014001b4 	movhi	r5,6
   42d2c:	29481004 	addi	r5,r5,8256
   42d30:	0009883a 	mov	r4,zero
   42d34:	004709c0 	call	4709c <send>
                send(SOCKET1, send_buffer, len);
   42d38:	e0bfff17 	ldw	r2,-4(fp)
   42d3c:	10bfffcc 	andi	r2,r2,65535
   42d40:	100d883a 	mov	r6,r2
   42d44:	014001b4 	movhi	r5,6
   42d48:	29481004 	addi	r5,r5,8256
   42d4c:	01000044 	movi	r4,1
   42d50:	004709c0 	call	4709c <send>
            }
        }
        if(SysStatus.reset_nios != ENABLE)
   42d54:	d0e01417 	ldw	r3,-32688(gp)
   42d58:	00844474 	movhi	r2,4369
   42d5c:	10844444 	addi	r2,r2,4369
   42d60:	18be2126 	beq	r3,r2,425e8 <__alt_mem_epcs_flash+0xfffc15e8>
            watchdog_feed();
   42d64:	0047fa80 	call	47fa8 <watchdog_feed>
    }
   42d68:	003e1f06 	br	425e8 <__alt_mem_epcs_flash+0xfffc15e8>

00042d6c <check_sum>:

UpDataFrame     CycleData;
NIOS2FPGA_Pck_t Nios2FPGA_pck;

static unsigned int check_sum(unsigned int *data, unsigned char len)
{
   42d6c:	defffb04 	addi	sp,sp,-20
   42d70:	df000415 	stw	fp,16(sp)
   42d74:	df000404 	addi	fp,sp,16
   42d78:	e13ffe15 	stw	r4,-8(fp)
   42d7c:	2805883a 	mov	r2,r5
   42d80:	e0bfff05 	stb	r2,-4(fp)
    int          i;
    unsigned int checksum = 0;
   42d84:	e03ffd15 	stw	zero,-12(fp)
    for(i = 0; i < len; i++)
   42d88:	e03ffc15 	stw	zero,-16(fp)
   42d8c:	00000d06 	br	42dc4 <check_sum+0x58>
    {
        checksum ^= data[i];
   42d90:	e0bffc17 	ldw	r2,-16(fp)
   42d94:	1085883a 	add	r2,r2,r2
   42d98:	1085883a 	add	r2,r2,r2
   42d9c:	1007883a 	mov	r3,r2
   42da0:	e0bffe17 	ldw	r2,-8(fp)
   42da4:	10c5883a 	add	r2,r2,r3
   42da8:	10800017 	ldw	r2,0(r2)
   42dac:	e0fffd17 	ldw	r3,-12(fp)
   42db0:	1884f03a 	xor	r2,r3,r2
   42db4:	e0bffd15 	stw	r2,-12(fp)

static unsigned int check_sum(unsigned int *data, unsigned char len)
{
    int          i;
    unsigned int checksum = 0;
    for(i = 0; i < len; i++)
   42db8:	e0bffc17 	ldw	r2,-16(fp)
   42dbc:	10800044 	addi	r2,r2,1
   42dc0:	e0bffc15 	stw	r2,-16(fp)
   42dc4:	e0bfff03 	ldbu	r2,-4(fp)
   42dc8:	e0fffc17 	ldw	r3,-16(fp)
   42dcc:	18bff016 	blt	r3,r2,42d90 <__alt_mem_epcs_flash+0xfffc1d90>
    {
        checksum ^= data[i];
    }

    return checksum;
   42dd0:	e0bffd17 	ldw	r2,-12(fp)
}
   42dd4:	e037883a 	mov	sp,fp
   42dd8:	df000017 	ldw	fp,0(sp)
   42ddc:	dec00104 	addi	sp,sp,4
   42de0:	f800283a 	ret

00042de4 <motor_init>:

void motor_init()
{
   42de4:	deffff04 	addi	sp,sp,-4
   42de8:	df000015 	stw	fp,0(sp)
   42dec:	d839883a 	mov	fp,sp
}
   42df0:	0001883a 	nop
   42df4:	e037883a 	mov	sp,fp
   42df8:	df000017 	ldw	fp,0(sp)
   42dfc:	dec00104 	addi	sp,sp,4
   42e00:	f800283a 	ret

00042e04 <nios2fpga_data_packet>:

/*
 * 鎵撳寘鏁版嵁骞跺彂閫�
 */
void nios2fpga_data_packet(unsigned short command, unsigned char len, unsigned int *src)
{
   42e04:	deffdb04 	addi	sp,sp,-148
   42e08:	dfc02415 	stw	ra,144(sp)
   42e0c:	df002315 	stw	fp,140(sp)
   42e10:	dc002215 	stw	r16,136(sp)
   42e14:	df002304 	addi	fp,sp,140
   42e18:	2007883a 	mov	r3,r4
   42e1c:	2805883a 	mov	r2,r5
   42e20:	e1bffe15 	stw	r6,-8(fp)
   42e24:	e0fffc0d 	sth	r3,-16(fp)
   42e28:	e0bffd05 	stb	r2,-12(fp)
    int          i;
    unsigned int buf[30];
    buf[0] = (0x1234 << 16) + command;
   42e2c:	e0fffc0b 	ldhu	r3,-16(fp)
   42e30:	00848d34 	movhi	r2,4660
   42e34:	1885883a 	add	r2,r3,r2
   42e38:	e0bfde15 	stw	r2,-136(fp)
    buf[1] = len;
   42e3c:	e0bffd03 	ldbu	r2,-12(fp)
   42e40:	e0bfdf15 	stw	r2,-132(fp)

    for(i = 0; i < len; i++)
   42e44:	e03fdd15 	stw	zero,-140(fp)
   42e48:	00001206 	br	42e94 <nios2fpga_data_packet+0x90>
    {
        buf[i + 2] = src[i];
   42e4c:	e0bfdd17 	ldw	r2,-140(fp)
   42e50:	10800084 	addi	r2,r2,2
   42e54:	e0ffdd17 	ldw	r3,-140(fp)
   42e58:	18c7883a 	add	r3,r3,r3
   42e5c:	18c7883a 	add	r3,r3,r3
   42e60:	1809883a 	mov	r4,r3
   42e64:	e0fffe17 	ldw	r3,-8(fp)
   42e68:	1907883a 	add	r3,r3,r4
   42e6c:	18c00017 	ldw	r3,0(r3)
   42e70:	1085883a 	add	r2,r2,r2
   42e74:	1085883a 	add	r2,r2,r2
   42e78:	e13fdd04 	addi	r4,fp,-140
   42e7c:	2085883a 	add	r2,r4,r2
   42e80:	10800104 	addi	r2,r2,4
   42e84:	10c00015 	stw	r3,0(r2)
    int          i;
    unsigned int buf[30];
    buf[0] = (0x1234 << 16) + command;
    buf[1] = len;

    for(i = 0; i < len; i++)
   42e88:	e0bfdd17 	ldw	r2,-140(fp)
   42e8c:	10800044 	addi	r2,r2,1
   42e90:	e0bfdd15 	stw	r2,-140(fp)
   42e94:	e0bffd03 	ldbu	r2,-12(fp)
   42e98:	e0ffdd17 	ldw	r3,-140(fp)
   42e9c:	18bfeb16 	blt	r3,r2,42e4c <__alt_mem_epcs_flash+0xfffc1e4c>
    {
        buf[i + 2] = src[i];
    }
    buf[len + 2] = check_sum(buf, len + 2);
   42ea0:	e0bffd03 	ldbu	r2,-12(fp)
   42ea4:	14000084 	addi	r16,r2,2
   42ea8:	e0bffd03 	ldbu	r2,-12(fp)
   42eac:	10800084 	addi	r2,r2,2
   42eb0:	10c03fcc 	andi	r3,r2,255
   42eb4:	e0bfde04 	addi	r2,fp,-136
   42eb8:	180b883a 	mov	r5,r3
   42ebc:	1009883a 	mov	r4,r2
   42ec0:	0042d6c0 	call	42d6c <check_sum>
   42ec4:	1007883a 	mov	r3,r2
   42ec8:	8405883a 	add	r2,r16,r16
   42ecc:	1085883a 	add	r2,r2,r2
   42ed0:	e13fdd04 	addi	r4,fp,-140
   42ed4:	2085883a 	add	r2,r4,r2
   42ed8:	10800104 	addi	r2,r2,4
   42edc:	10c00015 	stw	r3,0(r2)

    nios2fpga_data_write(buf, len + 3);
   42ee0:	e0bffd03 	ldbu	r2,-12(fp)
   42ee4:	108000c4 	addi	r2,r2,3
   42ee8:	1007883a 	mov	r3,r2
   42eec:	e0bfde04 	addi	r2,fp,-136
   42ef0:	180b883a 	mov	r5,r3
   42ef4:	1009883a 	mov	r4,r2
   42ef8:	0042f180 	call	42f18 <nios2fpga_data_write>
}
   42efc:	0001883a 	nop
   42f00:	e6ffff04 	addi	sp,fp,-4
   42f04:	dfc00217 	ldw	ra,8(sp)
   42f08:	df000117 	ldw	fp,4(sp)
   42f0c:	dc000017 	ldw	r16,0(sp)
   42f10:	dec00304 	addi	sp,sp,12
   42f14:	f800283a 	ret

00042f18 <nios2fpga_data_write>:

/*
 * niso 鏁版嵁閫氳繃fifo鍐欏埌 FPGA
 */
bool nios2fpga_data_write(unsigned int *data, unsigned int len)
{
   42f18:	defffb04 	addi	sp,sp,-20
   42f1c:	dfc00415 	stw	ra,16(sp)
   42f20:	df000315 	stw	fp,12(sp)
   42f24:	df000304 	addi	fp,sp,12
   42f28:	e13ffe15 	stw	r4,-8(fp)
   42f2c:	e17fff15 	stw	r5,-4(fp)
    int i;
    for(i = 0; i < len; i++)
   42f30:	e03ffd15 	stw	zero,-12(fp)
   42f34:	00001106 	br	42f7c <nios2fpga_data_write+0x64>
    {
        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data[i] >> 16) + (data[i] << 16));
   42f38:	e0bffd17 	ldw	r2,-12(fp)
   42f3c:	1085883a 	add	r2,r2,r2
   42f40:	1085883a 	add	r2,r2,r2
   42f44:	1007883a 	mov	r3,r2
   42f48:	e0bffe17 	ldw	r2,-8(fp)
   42f4c:	10c5883a 	add	r2,r2,r3
   42f50:	10800017 	ldw	r2,0(r2)
   42f54:	1004143a 	roli	r2,r2,16
   42f58:	100d883a 	mov	r6,r2
   42f5c:	01400234 	movhi	r5,8
   42f60:	29484004 	addi	r5,r5,8448
   42f64:	01000234 	movhi	r4,8
   42f68:	21087a04 	addi	r4,r4,8680
   42f6c:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
 * niso 鏁版嵁閫氳繃fifo鍐欏埌 FPGA
 */
bool nios2fpga_data_write(unsigned int *data, unsigned int len)
{
    int i;
    for(i = 0; i < len; i++)
   42f70:	e0bffd17 	ldw	r2,-12(fp)
   42f74:	10800044 	addi	r2,r2,1
   42f78:	e0bffd15 	stw	r2,-12(fp)
   42f7c:	e0fffd17 	ldw	r3,-12(fp)
   42f80:	e0bfff17 	ldw	r2,-4(fp)
   42f84:	18bfec36 	bltu	r3,r2,42f38 <__alt_mem_epcs_flash+0xfffc1f38>
    {
        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data[i] >> 16) + (data[i] << 16));
        // usleep(1000);
    }
    return true;
   42f88:	00800044 	movi	r2,1
}
   42f8c:	e037883a 	mov	sp,fp
   42f90:	dfc00117 	ldw	ra,4(sp)
   42f94:	df000017 	ldw	fp,0(sp)
   42f98:	dec00204 	addi	sp,sp,8
   42f9c:	f800283a 	ret

00042fa0 <set_laser_paramter>:

void set_laser_paramter(NIOS2FPGA_Pck_t *pck, unsigned short command, unsigned int data)
{
   42fa0:	defffa04 	addi	sp,sp,-24
   42fa4:	dfc00515 	stw	ra,20(sp)
   42fa8:	df000415 	stw	fp,16(sp)
   42fac:	df000404 	addi	fp,sp,16
   42fb0:	e13ffd15 	stw	r4,-12(fp)
   42fb4:	2805883a 	mov	r2,r5
   42fb8:	e1bfff15 	stw	r6,-4(fp)
   42fbc:	e0bffe0d 	sth	r2,-8(fp)
    unsigned char len = 1;
   42fc0:	00800044 	movi	r2,1
   42fc4:	e0bffc05 	stb	r2,-16(fp)
    pck->command      = command;
   42fc8:	e0fffe0b 	ldhu	r3,-8(fp)
   42fcc:	e0bffd17 	ldw	r2,-12(fp)
   42fd0:	10c00015 	stw	r3,0(r2)
    nios2fpga_data_packet(pck->command, len, &data);
   42fd4:	e0bffd17 	ldw	r2,-12(fp)
   42fd8:	10800017 	ldw	r2,0(r2)
   42fdc:	10bfffcc 	andi	r2,r2,65535
   42fe0:	e0fffc03 	ldbu	r3,-16(fp)
   42fe4:	e13fff04 	addi	r4,fp,-4
   42fe8:	200d883a 	mov	r6,r4
   42fec:	180b883a 	mov	r5,r3
   42ff0:	1009883a 	mov	r4,r2
   42ff4:	0042e040 	call	42e04 <nios2fpga_data_packet>
}
   42ff8:	0001883a 	nop
   42ffc:	e037883a 	mov	sp,fp
   43000:	dfc00117 	ldw	ra,4(sp)
   43004:	df000017 	ldw	fp,0(sp)
   43008:	dec00204 	addi	sp,sp,8
   4300c:	f800283a 	ret

00043010 <init_fpga_sys>:

void init_fpga_sys(void)
{
   43010:	defffe04 	addi	sp,sp,-8
   43014:	dfc00115 	stw	ra,4(sp)
   43018:	df000015 	stw	fp,0(sp)
   4301c:	d839883a 	mov	fp,sp
    set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, ENABLE);
   43020:	01844474 	movhi	r6,4369
   43024:	31844444 	addi	r6,r6,4369
   43028:	016c0014 	movui	r5,45056
   4302c:	d1201604 	addi	r4,gp,-32680
   43030:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, LASER_ENABLE, SysPara.laser_enable);
   43034:	008001b4 	movhi	r2,6
   43038:	10a56c04 	addi	r2,r2,-27216
   4303c:	10800117 	ldw	r2,4(r2)
   43040:	100d883a 	mov	r6,r2
   43044:	01684014 	movui	r5,41216
   43048:	d1201604 	addi	r4,gp,-32680
   4304c:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, LASER_FREQ, SysPara.laser_freq);
   43050:	008001b4 	movhi	r2,6
   43054:	10a56c04 	addi	r2,r2,-27216
   43058:	10800217 	ldw	r2,8(r2)
   4305c:	100d883a 	mov	r6,r2
   43060:	01684054 	movui	r5,41217
   43064:	d1201604 	addi	r4,gp,-32680
   43068:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, LASER_PULSE_WIDTH, SysPara.laser_pulse_width);
   4306c:	008001b4 	movhi	r2,6
   43070:	10a56c04 	addi	r2,r2,-27216
   43074:	10800b17 	ldw	r2,44(r2)
   43078:	100d883a 	mov	r6,r2
   4307c:	01684094 	movui	r5,41218
   43080:	d1201604 	addi	r4,gp,-32680
   43084:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, LASER_RECV_DELAY, SysPara.laser_recv_delay);
   43088:	008001b4 	movhi	r2,6
   4308c:	10a56c04 	addi	r2,r2,-27216
   43090:	10800317 	ldw	r2,12(r2)
   43094:	100d883a 	mov	r6,r2
   43098:	016840d4 	movui	r5,41219
   4309c:	d1201604 	addi	r4,gp,-32680
   430a0:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, MOTOR_ENABLE, SysPara.motor_enable);
   430a4:	008001b4 	movhi	r2,6
   430a8:	10a56c04 	addi	r2,r2,-27216
   430ac:	10800417 	ldw	r2,16(r2)
   430b0:	100d883a 	mov	r6,r2
   430b4:	01688014 	movui	r5,41472
   430b8:	d1201604 	addi	r4,gp,-32680
   430bc:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, MOTOR_SPEED, SysPara.motor_expect_speed);
   430c0:	008001b4 	movhi	r2,6
   430c4:	10a56c04 	addi	r2,r2,-27216
   430c8:	10800517 	ldw	r2,20(r2)
   430cc:	100d883a 	mov	r6,r2
   430d0:	01688054 	movui	r5,41473
   430d4:	d1201604 	addi	r4,gp,-32680
   430d8:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, ZERO_DISTANCE_REVISE, SysPara.zero_distance_revise);
   430dc:	008001b4 	movhi	r2,6
   430e0:	10a56c04 	addi	r2,r2,-27216
   430e4:	10800617 	ldw	r2,24(r2)
   430e8:	100d883a 	mov	r6,r2
   430ec:	0168c054 	movui	r5,41729
   430f0:	d1201604 	addi	r4,gp,-32680
   430f4:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, ZERO_ANGLE_REVISE, SysPara.zero_angle_revise);
   430f8:	008001b4 	movhi	r2,6
   430fc:	10a56c04 	addi	r2,r2,-27216
   43100:	10800717 	ldw	r2,28(r2)
   43104:	100d883a 	mov	r6,r2
   43108:	0168c094 	movui	r5,41730
   4310c:	d1201604 	addi	r4,gp,-32680
   43110:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_DISTANCE_REVISE1, SysPara.gray_distance_revise1);
   43114:	008001b4 	movhi	r2,6
   43118:	10a56c04 	addi	r2,r2,-27216
   4311c:	10800817 	ldw	r2,32(r2)
   43120:	100d883a 	mov	r6,r2
   43124:	01690054 	movui	r5,41985
   43128:	d1201604 	addi	r4,gp,-32680
   4312c:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_DISTANCE_REVISE2, SysPara.gray_distance_revise2);
   43130:	008001b4 	movhi	r2,6
   43134:	10a56c04 	addi	r2,r2,-27216
   43138:	10800917 	ldw	r2,36(r2)
   4313c:	100d883a 	mov	r6,r2
   43140:	01690094 	movui	r5,41986
   43144:	d1201604 	addi	r4,gp,-32680
   43148:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_DISTANCE_REVISE3, SysPara.gray_distance_revise3);
   4314c:	008001b4 	movhi	r2,6
   43150:	10a56c04 	addi	r2,r2,-27216
   43154:	10800a17 	ldw	r2,40(r2)
   43158:	100d883a 	mov	r6,r2
   4315c:	016900d4 	movui	r5,41987
   43160:	d1201604 	addi	r4,gp,-32680
   43164:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_DISTANCE_REVISE4, SysPara.gray_distance_revise4);
   43168:	008001b4 	movhi	r2,6
   4316c:	10a56c04 	addi	r2,r2,-27216
   43170:	10804717 	ldw	r2,284(r2)
   43174:	100d883a 	mov	r6,r2
   43178:	01690114 	movui	r5,41988
   4317c:	d1201604 	addi	r4,gp,-32680
   43180:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_DISTANCE_REVISE5, SysPara.gray_distance_revise5);
   43184:	008001b4 	movhi	r2,6
   43188:	10a56c04 	addi	r2,r2,-27216
   4318c:	10804817 	ldw	r2,288(r2)
   43190:	100d883a 	mov	r6,r2
   43194:	01690154 	movui	r5,41989
   43198:	d1201604 	addi	r4,gp,-32680
   4319c:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_INFLECTION1, SysPara.gray_inflection1);
   431a0:	008001b4 	movhi	r2,6
   431a4:	10a56c04 	addi	r2,r2,-27216
   431a8:	10801017 	ldw	r2,64(r2)
   431ac:	100d883a 	mov	r6,r2
   431b0:	01698054 	movui	r5,42497
   431b4:	d1201604 	addi	r4,gp,-32680
   431b8:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_INFLECTION2, SysPara.gray_inflection2);
   431bc:	008001b4 	movhi	r2,6
   431c0:	10a56c04 	addi	r2,r2,-27216
   431c4:	10801117 	ldw	r2,68(r2)
   431c8:	100d883a 	mov	r6,r2
   431cc:	01698094 	movui	r5,42498
   431d0:	d1201604 	addi	r4,gp,-32680
   431d4:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_INFLECTION3, SysPara.gray_inflection3);
   431d8:	008001b4 	movhi	r2,6
   431dc:	10a56c04 	addi	r2,r2,-27216
   431e0:	10804517 	ldw	r2,276(r2)
   431e4:	100d883a 	mov	r6,r2
   431e8:	016980d4 	movui	r5,42499
   431ec:	d1201604 	addi	r4,gp,-32680
   431f0:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, GRAY_INFLECTION4, SysPara.gray_inflection4);
   431f4:	008001b4 	movhi	r2,6
   431f8:	10a56c04 	addi	r2,r2,-27216
   431fc:	10804617 	ldw	r2,280(r2)
   43200:	100d883a 	mov	r6,r2
   43204:	01698114 	movui	r5,42500
   43208:	d1201604 	addi	r4,gp,-32680
   4320c:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, NOISE_DIFF_SETTING1, SysPara.noise_diff_setting1);
   43210:	008001b4 	movhi	r2,6
   43214:	10a56c04 	addi	r2,r2,-27216
   43218:	10800d17 	ldw	r2,52(r2)
   4321c:	100d883a 	mov	r6,r2
   43220:	01694054 	movui	r5,42241
   43224:	d1201604 	addi	r4,gp,-32680
   43228:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, NOISE_DIFF_SETTING2, SysPara.noise_diff_setting2);
   4322c:	008001b4 	movhi	r2,6
   43230:	10a56c04 	addi	r2,r2,-27216
   43234:	10800e17 	ldw	r2,56(r2)
   43238:	100d883a 	mov	r6,r2
   4323c:	01694094 	movui	r5,42242
   43240:	d1201604 	addi	r4,gp,-32680
   43244:	0042fa00 	call	42fa0 <set_laser_paramter>

    set_laser_paramter(&Nios2FPGA_pck, APD_VOL_SETTING, SysPara.signal_thresold);
   43248:	008001b4 	movhi	r2,6
   4324c:	10a56c04 	addi	r2,r2,-27216
   43250:	10800c17 	ldw	r2,48(r2)
   43254:	100d883a 	mov	r6,r2
   43258:	0169c094 	movui	r5,42754
   4325c:	d1201604 	addi	r4,gp,-32680
   43260:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, APD_VOL_SETTING, SysPara.apd_vol_base);
   43264:	008001b4 	movhi	r2,6
   43268:	10a56c04 	addi	r2,r2,-27216
   4326c:	10800f17 	ldw	r2,60(r2)
   43270:	100d883a 	mov	r6,r2
   43274:	0169c094 	movui	r5,42754
   43278:	d1201604 	addi	r4,gp,-32680
   4327c:	0042fa00 	call	42fa0 <set_laser_paramter>

    set_laser_paramter(&Nios2FPGA_pck, TEMP_VOL_COF1, SysPara.temp_volt_cof1);
   43280:	008001b4 	movhi	r2,6
   43284:	10a56c04 	addi	r2,r2,-27216
   43288:	10801717 	ldw	r2,92(r2)
   4328c:	100d883a 	mov	r6,r2
   43290:	0169c0d4 	movui	r5,42755
   43294:	d1201604 	addi	r4,gp,-32680
   43298:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, TEMP_VOL_COF2, SysPara.temp_volt_cof2);
   4329c:	008001b4 	movhi	r2,6
   432a0:	10a56c04 	addi	r2,r2,-27216
   432a4:	10801817 	ldw	r2,96(r2)
   432a8:	100d883a 	mov	r6,r2
   432ac:	0169c114 	movui	r5,42756
   432b0:	d1201604 	addi	r4,gp,-32680
   432b4:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, TEMP_VOL_INFLECTION, SysPara.temp_volt_inflection);
   432b8:	008001b4 	movhi	r2,6
   432bc:	10a56c04 	addi	r2,r2,-27216
   432c0:	10801917 	ldw	r2,100(r2)
   432c4:	100d883a 	mov	r6,r2
   432c8:	0169c154 	movui	r5,42757
   432cc:	d1201604 	addi	r4,gp,-32680
   432d0:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, TEMP_DISTANCE_COF1, SysPara.temp_distance_cof1);
   432d4:	008001b4 	movhi	r2,6
   432d8:	10a56c04 	addi	r2,r2,-27216
   432dc:	10801a17 	ldw	r2,104(r2)
   432e0:	100d883a 	mov	r6,r2
   432e4:	0169c194 	movui	r5,42758
   432e8:	d1201604 	addi	r4,gp,-32680
   432ec:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, TEMP_DISTANCE_COF2, SysPara.temp_distance_cof2);
   432f0:	008001b4 	movhi	r2,6
   432f4:	10a56c04 	addi	r2,r2,-27216
   432f8:	10801b17 	ldw	r2,108(r2)
   432fc:	100d883a 	mov	r6,r2
   43300:	0169c1d4 	movui	r5,42759
   43304:	d1201604 	addi	r4,gp,-32680
   43308:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, TEMP_DISTANCE_INFLECTION, SysPara.temp_distance_inflection);
   4330c:	008001b4 	movhi	r2,6
   43310:	10a56c04 	addi	r2,r2,-27216
   43314:	10801c17 	ldw	r2,112(r2)
   43318:	100d883a 	mov	r6,r2
   4331c:	0169c214 	movui	r5,42760
   43320:	d1201604 	addi	r4,gp,-32680
   43324:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, MIN_DISTANCE_VALUE, SysPara.min_display_distance);
   43328:	008001b4 	movhi	r2,6
   4332c:	10a56c04 	addi	r2,r2,-27216
   43330:	10801217 	ldw	r2,72(r2)
   43334:	100d883a 	mov	r6,r2
   43338:	016a8054 	movui	r5,43521
   4333c:	d1201604 	addi	r4,gp,-32680
   43340:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, FIRST_NOISE_FILTER, SysPara.first_noise_filter);
   43344:	008001b4 	movhi	r2,6
   43348:	10a56c04 	addi	r2,r2,-27216
   4334c:	10801417 	ldw	r2,80(r2)
   43350:	100d883a 	mov	r6,r2
   43354:	016a80d4 	movui	r5,43523
   43358:	d1201604 	addi	r4,gp,-32680
   4335c:	0042fa00 	call	42fa0 <set_laser_paramter>

    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA1, SysPara.da_cycle_para1);
   43360:	008001b4 	movhi	r2,6
   43364:	10a56c04 	addi	r2,r2,-27216
   43368:	10802317 	ldw	r2,140(r2)
   4336c:	100d883a 	mov	r6,r2
   43370:	016b0054 	movui	r5,44033
   43374:	d1201604 	addi	r4,gp,-32680
   43378:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA2, SysPara.da_cycle_para2);
   4337c:	008001b4 	movhi	r2,6
   43380:	10a56c04 	addi	r2,r2,-27216
   43384:	10802417 	ldw	r2,144(r2)
   43388:	100d883a 	mov	r6,r2
   4338c:	016b0094 	movui	r5,44034
   43390:	d1201604 	addi	r4,gp,-32680
   43394:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA3, SysPara.da_cycle_para3);
   43398:	008001b4 	movhi	r2,6
   4339c:	10a56c04 	addi	r2,r2,-27216
   433a0:	10802517 	ldw	r2,148(r2)
   433a4:	100d883a 	mov	r6,r2
   433a8:	016b00d4 	movui	r5,44035
   433ac:	d1201604 	addi	r4,gp,-32680
   433b0:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA4, SysPara.da_cycle_para4);
   433b4:	008001b4 	movhi	r2,6
   433b8:	10a56c04 	addi	r2,r2,-27216
   433bc:	10802617 	ldw	r2,152(r2)
   433c0:	100d883a 	mov	r6,r2
   433c4:	016b0114 	movui	r5,44036
   433c8:	d1201604 	addi	r4,gp,-32680
   433cc:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA5, SysPara.da_cycle_para5);
   433d0:	008001b4 	movhi	r2,6
   433d4:	10a56c04 	addi	r2,r2,-27216
   433d8:	10802717 	ldw	r2,156(r2)
   433dc:	100d883a 	mov	r6,r2
   433e0:	016b0154 	movui	r5,44037
   433e4:	d1201604 	addi	r4,gp,-32680
   433e8:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA6, SysPara.da_cycle_para6);
   433ec:	008001b4 	movhi	r2,6
   433f0:	10a56c04 	addi	r2,r2,-27216
   433f4:	10802817 	ldw	r2,160(r2)
   433f8:	100d883a 	mov	r6,r2
   433fc:	016b0194 	movui	r5,44038
   43400:	d1201604 	addi	r4,gp,-32680
   43404:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA7, SysPara.da_cycle_para7);
   43408:	008001b4 	movhi	r2,6
   4340c:	10a56c04 	addi	r2,r2,-27216
   43410:	10802917 	ldw	r2,164(r2)
   43414:	100d883a 	mov	r6,r2
   43418:	016b01d4 	movui	r5,44039
   4341c:	d1201604 	addi	r4,gp,-32680
   43420:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA8, SysPara.da_cycle_para8);
   43424:	008001b4 	movhi	r2,6
   43428:	10a56c04 	addi	r2,r2,-27216
   4342c:	10802a17 	ldw	r2,168(r2)
   43430:	100d883a 	mov	r6,r2
   43434:	016b0214 	movui	r5,44040
   43438:	d1201604 	addi	r4,gp,-32680
   4343c:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, DA_CYCLE_PARA9, SysPara.da_cycle_para9);
   43440:	008001b4 	movhi	r2,6
   43444:	10a56c04 	addi	r2,r2,-27216
   43448:	10802b17 	ldw	r2,172(r2)
   4344c:	100d883a 	mov	r6,r2
   43450:	016b0254 	movui	r5,44041
   43454:	d1201604 	addi	r4,gp,-32680
   43458:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, MIN_TARGET_SIZE, SysPara.min_target_size);
   4345c:	008001b4 	movhi	r2,6
   43460:	10a56c04 	addi	r2,r2,-27216
   43464:	10804a17 	ldw	r2,296(r2)
   43468:	100d883a 	mov	r6,r2
   4346c:	016b4014 	movui	r5,44288
   43470:	d1201604 	addi	r4,gp,-32680
   43474:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, ALARM_OUTPUT_THRESHOLD, SysPara.alarm_output_threshold);
   43478:	008001b4 	movhi	r2,6
   4347c:	10a56c04 	addi	r2,r2,-27216
   43480:	10804b17 	ldw	r2,300(r2)
   43484:	100d883a 	mov	r6,r2
   43488:	016b4054 	movui	r5,44289
   4348c:	d1201604 	addi	r4,gp,-32680
   43490:	0042fa00 	call	42fa0 <set_laser_paramter>
    set_laser_paramter(&Nios2FPGA_pck, PC_SET_HW_TYPE, SysPara.board_type);
   43494:	008001b4 	movhi	r2,6
   43498:	10a56c04 	addi	r2,r2,-27216
   4349c:	10802c17 	ldw	r2,176(r2)
   434a0:	100d883a 	mov	r6,r2
   434a4:	01500184 	movi	r5,16390
   434a8:	d1201604 	addi	r4,gp,-32680
   434ac:	0042fa00 	call	42fa0 <set_laser_paramter>
    write_laser_presdo(SysPara.laser_presdo);
   434b0:	010001b4 	movhi	r4,6
   434b4:	2125a804 	addi	r4,r4,-26976
   434b8:	00434f40 	call	434f4 <write_laser_presdo>
}
   434bc:	0001883a 	nop
   434c0:	e037883a 	mov	sp,fp
   434c4:	dfc00117 	ldw	ra,4(sp)
   434c8:	df000017 	ldw	fp,0(sp)
   434cc:	dec00204 	addi	sp,sp,8
   434d0:	f800283a 	ret

000434d4 <close_peripheral_dev>:

void close_peripheral_dev(void)
{
   434d4:	deffff04 	addi	sp,sp,-4
   434d8:	df000015 	stw	fp,0(sp)
   434dc:	d839883a 	mov	fp,sp
    set_laser_paramter(&Nios2FPGA_pck, MOTOR_ENABLE, DISABLE);
    set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, DISABLE);
    // set_laser_paramter(&Nios2FPGA_pck, LASER_ENABLE, DISABLE);
    // set_laser_paramter(&Nios2FPGA_pck, APD_VOL_SETTING, 550);
#endif
}
   434e0:	0001883a 	nop
   434e4:	e037883a 	mov	sp,fp
   434e8:	df000017 	ldw	fp,0(sp)
   434ec:	dec00104 	addi	sp,sp,4
   434f0:	f800283a 	ret

000434f4 <write_laser_presdo>:

void write_laser_presdo(unsigned char *arr)
{
   434f4:	defffb04 	addi	sp,sp,-20
   434f8:	dfc00415 	stw	ra,16(sp)
   434fc:	df000315 	stw	fp,12(sp)
   43500:	df000304 	addi	fp,sp,12
   43504:	e13fff15 	stw	r4,-4(fp)
    int          i;
    unsigned int data;
    data = 0x1234a104;
   43508:	00848d74 	movhi	r2,4661
   4350c:	10a84104 	addi	r2,r2,-24316
   43510:	e0bffe15 	stw	r2,-8(fp)

    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   43514:	e0bffe17 	ldw	r2,-8(fp)
   43518:	1004143a 	roli	r2,r2,16
   4351c:	100d883a 	mov	r6,r2
   43520:	01400234 	movhi	r5,8
   43524:	29484004 	addi	r5,r5,8448
   43528:	01000234 	movhi	r4,8
   4352c:	21087a04 	addi	r4,r4,8680
   43530:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
    data = 30;
   43534:	00800784 	movi	r2,30
   43538:	e0bffe15 	stw	r2,-8(fp)
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   4353c:	e0bffe17 	ldw	r2,-8(fp)
   43540:	1004143a 	roli	r2,r2,16
   43544:	100d883a 	mov	r6,r2
   43548:	01400234 	movhi	r5,8
   4354c:	29484004 	addi	r5,r5,8448
   43550:	01000234 	movhi	r4,8
   43554:	21087a04 	addi	r4,r4,8680
   43558:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>

    //    data = 0x1000;
    for(i = 0; i < sizeof(SysPara.laser_presdo); i = i + 4)
   4355c:	e03ffd15 	stw	zero,-12(fp)
   43560:	00002906 	br	43608 <write_laser_presdo+0x114>
    {
        data = (arr[i] << 24) + (arr[i + 1] << 16) + (arr[i + 2] << 8) + (arr[i + 3] << 0);
   43564:	e0bffd17 	ldw	r2,-12(fp)
   43568:	e0ffff17 	ldw	r3,-4(fp)
   4356c:	1885883a 	add	r2,r3,r2
   43570:	10800003 	ldbu	r2,0(r2)
   43574:	10803fcc 	andi	r2,r2,255
   43578:	1006963a 	slli	r3,r2,24
   4357c:	e0bffd17 	ldw	r2,-12(fp)
   43580:	10800044 	addi	r2,r2,1
   43584:	e13fff17 	ldw	r4,-4(fp)
   43588:	2085883a 	add	r2,r4,r2
   4358c:	10800003 	ldbu	r2,0(r2)
   43590:	10803fcc 	andi	r2,r2,255
   43594:	1004943a 	slli	r2,r2,16
   43598:	1887883a 	add	r3,r3,r2
   4359c:	e0bffd17 	ldw	r2,-12(fp)
   435a0:	10800084 	addi	r2,r2,2
   435a4:	e13fff17 	ldw	r4,-4(fp)
   435a8:	2085883a 	add	r2,r4,r2
   435ac:	10800003 	ldbu	r2,0(r2)
   435b0:	10803fcc 	andi	r2,r2,255
   435b4:	1004923a 	slli	r2,r2,8
   435b8:	1887883a 	add	r3,r3,r2
   435bc:	e0bffd17 	ldw	r2,-12(fp)
   435c0:	108000c4 	addi	r2,r2,3
   435c4:	e13fff17 	ldw	r4,-4(fp)
   435c8:	2085883a 	add	r2,r4,r2
   435cc:	10800003 	ldbu	r2,0(r2)
   435d0:	10803fcc 	andi	r2,r2,255
   435d4:	1885883a 	add	r2,r3,r2
   435d8:	e0bffe15 	stw	r2,-8(fp)
        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   435dc:	e0bffe17 	ldw	r2,-8(fp)
   435e0:	1004143a 	roli	r2,r2,16
   435e4:	100d883a 	mov	r6,r2
   435e8:	01400234 	movhi	r5,8
   435ec:	29484004 	addi	r5,r5,8448
   435f0:	01000234 	movhi	r4,8
   435f4:	21087a04 	addi	r4,r4,8680
   435f8:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
    data = 30;
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));

    //    data = 0x1000;
    for(i = 0; i < sizeof(SysPara.laser_presdo); i = i + 4)
   435fc:	e0bffd17 	ldw	r2,-12(fp)
   43600:	10800104 	addi	r2,r2,4
   43604:	e0bffd15 	stw	r2,-12(fp)
   43608:	e0bffd17 	ldw	r2,-12(fp)
   4360c:	108007b0 	cmpltui	r2,r2,30
   43610:	103fd41e 	bne	r2,zero,43564 <__alt_mem_epcs_flash+0xfffc2564>
    {
        data = (arr[i] << 24) + (arr[i + 1] << 16) + (arr[i + 2] << 8) + (arr[i + 3] << 0);
        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
    }
    data = 0xccccdddd;
   43614:	00b33374 	movhi	r2,52429
   43618:	10b77744 	addi	r2,r2,-8739
   4361c:	e0bffe15 	stw	r2,-8(fp)
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   43620:	e0bffe17 	ldw	r2,-8(fp)
   43624:	1004143a 	roli	r2,r2,16
   43628:	100d883a 	mov	r6,r2
   4362c:	01400234 	movhi	r5,8
   43630:	29484004 	addi	r5,r5,8448
   43634:	01000234 	movhi	r4,8
   43638:	21087a04 	addi	r4,r4,8680
   4363c:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
}
   43640:	0001883a 	nop
   43644:	e037883a 	mov	sp,fp
   43648:	dfc00117 	ldw	ra,4(sp)
   4364c:	df000017 	ldw	fp,0(sp)
   43650:	dec00204 	addi	sp,sp,8
   43654:	f800283a 	ret

00043658 <pc_data_to_fpga>:
unsigned char send_buffer[8448];  // 定义一个2KB的数组，用来存放Socket的通信数据
/*
 *转发pc数据到fpga
 */
bool pc_data_to_fpga(unsigned int *data, unsigned int len)
{
   43658:	defffb04 	addi	sp,sp,-20
   4365c:	dfc00415 	stw	ra,16(sp)
   43660:	df000315 	stw	fp,12(sp)
   43664:	df000304 	addi	fp,sp,12
   43668:	e13ffe15 	stw	r4,-8(fp)
   4366c:	e17fff15 	stw	r5,-4(fp)
    int i;
    for(i = 0; i < len; i++)
   43670:	e03ffd15 	stw	zero,-12(fp)
   43674:	00003406 	br	43748 <pc_data_to_fpga+0xf0>
    {
        // nios 采用小端格式，char 数组 转 unsigned int 数组， 字节顺序会颠倒
        data[i] = ((data[i] & 0xff000000) >> 24) | ((data[i] & 0x00ff0000) >> 8) | ((data[i] & 0x0000ff00) << 8) | ((data[i] & 0x000000ff) << 32);
   43678:	e0bffd17 	ldw	r2,-12(fp)
   4367c:	1085883a 	add	r2,r2,r2
   43680:	1085883a 	add	r2,r2,r2
   43684:	1007883a 	mov	r3,r2
   43688:	e0bffe17 	ldw	r2,-8(fp)
   4368c:	10c7883a 	add	r3,r2,r3
   43690:	e0bffd17 	ldw	r2,-12(fp)
   43694:	1085883a 	add	r2,r2,r2
   43698:	1085883a 	add	r2,r2,r2
   4369c:	1009883a 	mov	r4,r2
   436a0:	e0bffe17 	ldw	r2,-8(fp)
   436a4:	1105883a 	add	r2,r2,r4
   436a8:	10800017 	ldw	r2,0(r2)
   436ac:	1008d63a 	srli	r4,r2,24
   436b0:	e0bffd17 	ldw	r2,-12(fp)
   436b4:	1085883a 	add	r2,r2,r2
   436b8:	1085883a 	add	r2,r2,r2
   436bc:	100b883a 	mov	r5,r2
   436c0:	e0bffe17 	ldw	r2,-8(fp)
   436c4:	1145883a 	add	r2,r2,r5
   436c8:	10800017 	ldw	r2,0(r2)
   436cc:	10803fec 	andhi	r2,r2,255
   436d0:	1004d23a 	srli	r2,r2,8
   436d4:	2088b03a 	or	r4,r4,r2
   436d8:	e0bffd17 	ldw	r2,-12(fp)
   436dc:	1085883a 	add	r2,r2,r2
   436e0:	1085883a 	add	r2,r2,r2
   436e4:	100b883a 	mov	r5,r2
   436e8:	e0bffe17 	ldw	r2,-8(fp)
   436ec:	1145883a 	add	r2,r2,r5
   436f0:	10800017 	ldw	r2,0(r2)
   436f4:	10bfc00c 	andi	r2,r2,65280
   436f8:	1004923a 	slli	r2,r2,8
   436fc:	2084b03a 	or	r2,r4,r2
   43700:	18800015 	stw	r2,0(r3)

        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data[i] >> 16) + (data[i] << 16));
   43704:	e0bffd17 	ldw	r2,-12(fp)
   43708:	1085883a 	add	r2,r2,r2
   4370c:	1085883a 	add	r2,r2,r2
   43710:	1007883a 	mov	r3,r2
   43714:	e0bffe17 	ldw	r2,-8(fp)
   43718:	10c5883a 	add	r2,r2,r3
   4371c:	10800017 	ldw	r2,0(r2)
   43720:	1004143a 	roli	r2,r2,16
   43724:	100d883a 	mov	r6,r2
   43728:	01400234 	movhi	r5,8
   4372c:	29484004 	addi	r5,r5,8448
   43730:	01000234 	movhi	r4,8
   43734:	21087a04 	addi	r4,r4,8680
   43738:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
 *转发pc数据到fpga
 */
bool pc_data_to_fpga(unsigned int *data, unsigned int len)
{
    int i;
    for(i = 0; i < len; i++)
   4373c:	e0bffd17 	ldw	r2,-12(fp)
   43740:	10800044 	addi	r2,r2,1
   43744:	e0bffd15 	stw	r2,-12(fp)
   43748:	e0fffd17 	ldw	r3,-12(fp)
   4374c:	e0bfff17 	ldw	r2,-4(fp)
   43750:	18bfc936 	bltu	r3,r2,43678 <__alt_mem_epcs_flash+0xfffc2678>
        // nios 采用小端格式，char 数组 转 unsigned int 数组， 字节顺序会颠倒
        data[i] = ((data[i] & 0xff000000) >> 24) | ((data[i] & 0x00ff0000) >> 8) | ((data[i] & 0x0000ff00) << 8) | ((data[i] & 0x000000ff) << 32);

        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data[i] >> 16) + (data[i] << 16));
    }
    return true;
   43754:	00800044 	movi	r2,1
}
   43758:	e037883a 	mov	sp,fp
   4375c:	dfc00117 	ldw	ra,4(sp)
   43760:	df000017 	ldw	fp,0(sp)
   43764:	dec00204 	addi	sp,sp,8
   43768:	f800283a 	ret

0004376c <pc2dev_parse>:

void pc2dev_parse(SOCKET s, unsigned char *buf, int len)
{
   4376c:	defff504 	addi	sp,sp,-44
   43770:	dfc00a15 	stw	ra,40(sp)
   43774:	df000915 	stw	fp,36(sp)
   43778:	dc000815 	stw	r16,32(sp)
   4377c:	df000904 	addi	fp,sp,36
   43780:	2005883a 	mov	r2,r4
   43784:	e17ffd15 	stw	r5,-12(fp)
   43788:	e1bffe15 	stw	r6,-8(fp)
   4378c:	e0bffc05 	stb	r2,-16(fp)
    int            send_len;
    unsigned short recv_pos;
    unsigned int   para;        // PC 传给 nios 的参数值
    int            packet_len;  // buf里可能有多包数据，本包数据长度

    while(len != 0)
   43790:	0005b206 	br	44e5c <pc2dev_parse+0x16f0>
    {
        if(buf[0] == 0x02)  // 命令属于tim561协议
   43794:	e0bffd17 	ldw	r2,-12(fp)
   43798:	10800003 	ldbu	r2,0(r2)
   4379c:	10803fcc 	andi	r2,r2,255
   437a0:	10800098 	cmpnei	r2,r2,2
   437a4:	1000071e 	bne	r2,zero,437c4 <pc2dev_parse+0x58>
        {
            sick_protocol_process(s, buf, len);
   437a8:	e0bffc03 	ldbu	r2,-16(fp)
   437ac:	e1bffe17 	ldw	r6,-8(fp)
   437b0:	e17ffd17 	ldw	r5,-12(fp)
   437b4:	1009883a 	mov	r4,r2
   437b8:	004610c0 	call	4610c <sick_protocol_process>
            len = 0;
   437bc:	e03ffe15 	stw	zero,-8(fp)
   437c0:	0005a606 	br	44e5c <pc2dev_parse+0x16f0>
        }
        else  // 自定义协议
        {
            para = (buf[8] << 24) + (buf[9] << 16) + (buf[10] << 8) + buf[11];
   437c4:	e0bffd17 	ldw	r2,-12(fp)
   437c8:	10800204 	addi	r2,r2,8
   437cc:	10800003 	ldbu	r2,0(r2)
   437d0:	10803fcc 	andi	r2,r2,255
   437d4:	1006963a 	slli	r3,r2,24
   437d8:	e0bffd17 	ldw	r2,-12(fp)
   437dc:	10800244 	addi	r2,r2,9
   437e0:	10800003 	ldbu	r2,0(r2)
   437e4:	10803fcc 	andi	r2,r2,255
   437e8:	1004943a 	slli	r2,r2,16
   437ec:	1887883a 	add	r3,r3,r2
   437f0:	e0bffd17 	ldw	r2,-12(fp)
   437f4:	10800284 	addi	r2,r2,10
   437f8:	10800003 	ldbu	r2,0(r2)
   437fc:	10803fcc 	andi	r2,r2,255
   43800:	1004923a 	slli	r2,r2,8
   43804:	1887883a 	add	r3,r3,r2
   43808:	e0bffd17 	ldw	r2,-12(fp)
   4380c:	108002c4 	addi	r2,r2,11
   43810:	10800003 	ldbu	r2,0(r2)
   43814:	10803fcc 	andi	r2,r2,255
   43818:	1885883a 	add	r2,r3,r2
   4381c:	e0bff815 	stw	r2,-32(fp)
            /*
             *
             */
            pc2nios.head     = (buf[0] << 8) + buf[1];
   43820:	e0bffd17 	ldw	r2,-12(fp)
   43824:	10800003 	ldbu	r2,0(r2)
   43828:	10803fcc 	andi	r2,r2,255
   4382c:	1006923a 	slli	r3,r2,8
   43830:	e0bffd17 	ldw	r2,-12(fp)
   43834:	10800044 	addi	r2,r2,1
   43838:	10800003 	ldbu	r2,0(r2)
   4383c:	10803fcc 	andi	r2,r2,255
   43840:	1885883a 	add	r2,r3,r2
   43844:	1007883a 	mov	r3,r2
   43848:	008001b4 	movhi	r2,6
   4384c:	10a5b904 	addi	r2,r2,-26908
   43850:	10c00015 	stw	r3,0(r2)
            pc2nios.command  = (buf[2] << 8) + buf[3];
   43854:	e0bffd17 	ldw	r2,-12(fp)
   43858:	10800084 	addi	r2,r2,2
   4385c:	10800003 	ldbu	r2,0(r2)
   43860:	10803fcc 	andi	r2,r2,255
   43864:	1006923a 	slli	r3,r2,8
   43868:	e0bffd17 	ldw	r2,-12(fp)
   4386c:	108000c4 	addi	r2,r2,3
   43870:	10800003 	ldbu	r2,0(r2)
   43874:	10803fcc 	andi	r2,r2,255
   43878:	1885883a 	add	r2,r3,r2
   4387c:	1007883a 	mov	r3,r2
   43880:	008001b4 	movhi	r2,6
   43884:	10a5b904 	addi	r2,r2,-26908
   43888:	10c00115 	stw	r3,4(r2)
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
   4388c:	e0bffd17 	ldw	r2,-12(fp)
   43890:	10800104 	addi	r2,r2,4
   43894:	10800003 	ldbu	r2,0(r2)
   43898:	10803fcc 	andi	r2,r2,255
   4389c:	1006963a 	slli	r3,r2,24
   438a0:	e0bffd17 	ldw	r2,-12(fp)
   438a4:	10800144 	addi	r2,r2,5
   438a8:	10800003 	ldbu	r2,0(r2)
   438ac:	10803fcc 	andi	r2,r2,255
   438b0:	1004943a 	slli	r2,r2,16
   438b4:	1887883a 	add	r3,r3,r2
   438b8:	e0bffd17 	ldw	r2,-12(fp)
   438bc:	10800184 	addi	r2,r2,6
   438c0:	10800003 	ldbu	r2,0(r2)
   438c4:	10803fcc 	andi	r2,r2,255
   438c8:	1004923a 	slli	r2,r2,8
   438cc:	1887883a 	add	r3,r3,r2
   438d0:	e0bffd17 	ldw	r2,-12(fp)
   438d4:	108001c4 	addi	r2,r2,7
   438d8:	10800003 	ldbu	r2,0(r2)
   438dc:	10803fcc 	andi	r2,r2,255
   438e0:	1885883a 	add	r2,r3,r2
   438e4:	1007883a 	mov	r3,r2
   438e8:	008001b4 	movhi	r2,6
   438ec:	10a5b904 	addi	r2,r2,-26908
   438f0:	10c00215 	stw	r3,8(r2)
            SysPara.pc_command_value++;
   438f4:	008001b4 	movhi	r2,6
   438f8:	10a56c04 	addi	r2,r2,-27216
   438fc:	10804c17 	ldw	r2,304(r2)
   43900:	10c00044 	addi	r3,r2,1
   43904:	008001b4 	movhi	r2,6
   43908:	10a56c04 	addi	r2,r2,-27216
   4390c:	10c04c15 	stw	r3,304(r2)

            switch(pc2nios.command)
   43910:	008001b4 	movhi	r2,6
   43914:	10a5b904 	addi	r2,r2,-26908
   43918:	10800117 	ldw	r2,4(r2)
   4391c:	00e94054 	movui	r3,42241
   43920:	10c2d426 	beq	r2,r3,44474 <pc2dev_parse+0xd08>
   43924:	10e940a8 	cmpgeui	r3,r2,42242
   43928:	18004c1e 	bne	r3,zero,43a5c <pc2dev_parse+0x2f0>
   4392c:	10d040a0 	cmpeqi	r3,r2,16642
   43930:	1804f31e 	bne	r3,zero,44d00 <pc2dev_parse+0x1594>
   43934:	10d040e8 	cmpgeui	r3,r2,16643
   43938:	1800221e 	bne	r3,zero,439c4 <pc2dev_parse+0x258>
   4393c:	10d001e0 	cmpeqi	r3,r2,16391
   43940:	1801881e 	bne	r3,zero,43f64 <pc2dev_parse+0x7f8>
   43944:	10d00228 	cmpgeui	r3,r2,16392
   43948:	18000e1e 	bne	r3,zero,43984 <pc2dev_parse+0x218>
   4394c:	10d000e0 	cmpeqi	r3,r2,16387
   43950:	1800de1e 	bne	r3,zero,43ccc <pc2dev_parse+0x560>
   43954:	10d00128 	cmpgeui	r3,r2,16388
   43958:	1800051e 	bne	r3,zero,43970 <pc2dev_parse+0x204>
   4395c:	10d00060 	cmpeqi	r3,r2,16385
   43960:	1800881e 	bne	r3,zero,43b84 <pc2dev_parse+0x418>
   43964:	109000a0 	cmpeqi	r2,r2,16386
   43968:	1000be1e 	bne	r2,zero,43c64 <pc2dev_parse+0x4f8>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   4396c:	00052e06 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43970:	10d00160 	cmpeqi	r3,r2,16389
   43974:	1801531e 	bne	r3,zero,43ec4 <pc2dev_parse+0x758>
   43978:	109001a8 	cmpgeui	r2,r2,16390
   4397c:	10016c1e 	bne	r2,zero,43f30 <pc2dev_parse+0x7c4>
   43980:	00013406 	br	43e54 <pc2dev_parse+0x6e8>
   43984:	10d00420 	cmpeqi	r3,r2,16400
   43988:	18018e1e 	bne	r3,zero,43fc4 <pc2dev_parse+0x858>
   4398c:	10d00468 	cmpgeui	r3,r2,16401
   43990:	1800051e 	bne	r3,zero,439a8 <pc2dev_parse+0x23c>
   43994:	10d00220 	cmpeqi	r3,r2,16392
   43998:	1801761e 	bne	r3,zero,43f74 <pc2dev_parse+0x808>
   4399c:	10900260 	cmpeqi	r2,r2,16393
   439a0:	1001771e 	bne	r2,zero,43f80 <pc2dev_parse+0x814>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   439a4:	00052006 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   439a8:	10d04020 	cmpeqi	r3,r2,16640
   439ac:	1804521e 	bne	r3,zero,44af8 <pc2dev_parse+0x138c>
   439b0:	10d04068 	cmpgeui	r3,r2,16641
   439b4:	18049a1e 	bne	r3,zero,44c20 <pc2dev_parse+0x14b4>
   439b8:	10900460 	cmpeqi	r2,r2,16401
   439bc:	1001921e 	bne	r2,zero,44008 <pc2dev_parse+0x89c>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   439c0:	00051906 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   439c4:	00e88054 	movui	r3,41473
   439c8:	10c1ff26 	beq	r2,r3,441c8 <pc2dev_parse+0xa5c>
   439cc:	10e880a8 	cmpgeui	r3,r2,41474
   439d0:	1800101e 	bne	r3,zero,43a14 <pc2dev_parse+0x2a8>
   439d4:	00e84094 	movui	r3,41218
   439d8:	10c1b226 	beq	r2,r3,440a4 <pc2dev_parse+0x938>
   439dc:	10e840e8 	cmpgeui	r3,r2,41219
   439e0:	1800051e 	bne	r3,zero,439f8 <pc2dev_parse+0x28c>
   439e4:	00e84014 	movui	r3,41216
   439e8:	10c18c26 	beq	r2,r3,4401c <pc2dev_parse+0x8b0>
   439ec:	00e84054 	movui	r3,41217
   439f0:	10c19f26 	beq	r2,r3,44070 <pc2dev_parse+0x904>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   439f4:	00050c06 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   439f8:	00e84114 	movui	r3,41220
   439fc:	10c1bc26 	beq	r2,r3,440f0 <pc2dev_parse+0x984>
   43a00:	10e84130 	cmpltui	r3,r2,41220
   43a04:	1801cb1e 	bne	r3,zero,44134 <pc2dev_parse+0x9c8>
   43a08:	00e88014 	movui	r3,41472
   43a0c:	10c1d926 	beq	r2,r3,44174 <pc2dev_parse+0xa08>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43a10:	00050506 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43a14:	00e90094 	movui	r3,41986
   43a18:	10c22e26 	beq	r2,r3,442d4 <pc2dev_parse+0xb68>
   43a1c:	10e900e8 	cmpgeui	r3,r2,41987
   43a20:	1800071e 	bne	r3,zero,43a40 <pc2dev_parse+0x2d4>
   43a24:	00e8c094 	movui	r3,41730
   43a28:	10c20a26 	beq	r2,r3,44254 <pc2dev_parse+0xae8>
   43a2c:	00e90054 	movui	r3,41985
   43a30:	10c21b26 	beq	r2,r3,442a0 <pc2dev_parse+0xb34>
   43a34:	00e8c054 	movui	r3,41729
   43a38:	10c1f626 	beq	r2,r3,44214 <pc2dev_parse+0xaa8>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43a3c:	0004fa06 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43a40:	00e90114 	movui	r3,41988
   43a44:	10c23d26 	beq	r2,r3,4433c <pc2dev_parse+0xbd0>
   43a48:	10e90130 	cmpltui	r3,r2,41988
   43a4c:	18022e1e 	bne	r3,zero,44308 <pc2dev_parse+0xb9c>
   43a50:	00e90154 	movui	r3,41989
   43a54:	10c24626 	beq	r2,r3,44370 <pc2dev_parse+0xc04>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43a58:	0004f306 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43a5c:	00e9c254 	movui	r3,42761
   43a60:	10c32d26 	beq	r2,r3,44718 <pc2dev_parse+0xfac>
   43a64:	10e9c2a8 	cmpgeui	r3,r2,42762
   43a68:	1800221e 	bne	r3,zero,43af4 <pc2dev_parse+0x388>
   43a6c:	00e9c094 	movui	r3,42754
   43a70:	10c2aa26 	beq	r2,r3,4451c <pc2dev_parse+0xdb0>
   43a74:	10e9c0e8 	cmpgeui	r3,r2,42755
   43a78:	1800101e 	bne	r3,zero,43abc <pc2dev_parse+0x350>
   43a7c:	00e98094 	movui	r3,42498
   43a80:	10c25526 	beq	r2,r3,443d8 <pc2dev_parse+0xc6c>
   43a84:	10e980e8 	cmpgeui	r3,r2,42499
   43a88:	1800051e 	bne	r3,zero,43aa0 <pc2dev_parse+0x334>
   43a8c:	00e94094 	movui	r3,42242
   43a90:	10c28526 	beq	r2,r3,444a8 <pc2dev_parse+0xd3c>
   43a94:	00e98054 	movui	r3,42497
   43a98:	10c24226 	beq	r2,r3,443a4 <pc2dev_parse+0xc38>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43a9c:	0004e206 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43aa0:	00e98114 	movui	r3,42500
   43aa4:	10c26626 	beq	r2,r3,44440 <pc2dev_parse+0xcd4>
   43aa8:	10e98130 	cmpltui	r3,r2,42500
   43aac:	1802571e 	bne	r3,zero,4440c <pc2dev_parse+0xca0>
   43ab0:	00e9c054 	movui	r3,42753
   43ab4:	10c28926 	beq	r2,r3,444dc <pc2dev_parse+0xd70>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43ab8:	0004db06 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43abc:	00e9c154 	movui	r3,42757
   43ac0:	10c2d526 	beq	r2,r3,44618 <pc2dev_parse+0xeac>
   43ac4:	10e9c1a8 	cmpgeui	r3,r2,42758
   43ac8:	1800051e 	bne	r3,zero,43ae0 <pc2dev_parse+0x374>
   43acc:	00e9c0d4 	movui	r3,42755
   43ad0:	10c2ab26 	beq	r2,r3,44580 <pc2dev_parse+0xe14>
   43ad4:	00e9c114 	movui	r3,42756
   43ad8:	10c2bc26 	beq	r2,r3,445cc <pc2dev_parse+0xe60>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43adc:	0004d206 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43ae0:	00e9c1d4 	movui	r3,42759
   43ae4:	10c2ec26 	beq	r2,r3,44698 <pc2dev_parse+0xf2c>
   43ae8:	10a9c228 	cmpgeui	r2,r2,42760
   43aec:	1002fa1e 	bne	r2,zero,446d8 <pc2dev_parse+0xf6c>
   43af0:	0002d906 	br	44658 <pc2dev_parse+0xeec>
   43af4:	00eb0114 	movui	r3,44036
   43af8:	10c37d26 	beq	r2,r3,448f0 <pc2dev_parse+0x1184>
   43afc:	10eb0168 	cmpgeui	r3,r2,44037
   43b00:	1800101e 	bne	r3,zero,43b44 <pc2dev_parse+0x3d8>
   43b04:	00eac014 	movui	r3,43776
   43b08:	10c33926 	beq	r2,r3,447f0 <pc2dev_parse+0x1084>
   43b0c:	10eac068 	cmpgeui	r3,r2,43777
   43b10:	1800051e 	bne	r3,zero,43b28 <pc2dev_parse+0x3bc>
   43b14:	00ea8054 	movui	r3,43521
   43b18:	10c31226 	beq	r2,r3,44764 <pc2dev_parse+0xff8>
   43b1c:	00ea80d4 	movui	r3,43523
   43b20:	10c32026 	beq	r2,r3,447a4 <pc2dev_parse+0x1038>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43b24:	0004c006 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43b28:	00eb0094 	movui	r3,44034
   43b2c:	10c35026 	beq	r2,r3,44870 <pc2dev_parse+0x1104>
   43b30:	10eb00e8 	cmpgeui	r3,r2,44035
   43b34:	18035e1e 	bne	r3,zero,448b0 <pc2dev_parse+0x1144>
   43b38:	00eb0054 	movui	r3,44033
   43b3c:	10c33c26 	beq	r2,r3,44830 <pc2dev_parse+0x10c4>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43b40:	0004b906 	br	44e28 <pc2dev_parse+0x16bc>
            pc2nios.head     = (buf[0] << 8) + buf[1];
            pc2nios.command  = (buf[2] << 8) + buf[3];
            pc2nios.data_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]);
            SysPara.pc_command_value++;

            switch(pc2nios.command)
   43b44:	00eb0214 	movui	r3,44040
   43b48:	10c3a926 	beq	r2,r3,449f0 <pc2dev_parse+0x1284>
   43b4c:	10eb0268 	cmpgeui	r3,r2,44041
   43b50:	1800051e 	bne	r3,zero,43b68 <pc2dev_parse+0x3fc>
   43b54:	00eb0194 	movui	r3,44038
   43b58:	10c38526 	beq	r2,r3,44970 <pc2dev_parse+0x1204>
   43b5c:	10ab01e8 	cmpgeui	r2,r2,44039
   43b60:	1003931e 	bne	r2,zero,449b0 <pc2dev_parse+0x1244>
   43b64:	00037206 	br	44930 <pc2dev_parse+0x11c4>
   43b68:	00eb4014 	movui	r3,44288
   43b6c:	10c3c026 	beq	r2,r3,44a70 <pc2dev_parse+0x1304>
   43b70:	00eb4054 	movui	r3,44289
   43b74:	10c3ce26 	beq	r2,r3,44ab0 <pc2dev_parse+0x1344>
   43b78:	00eb0254 	movui	r3,44041
   43b7c:	10c3ac26 	beq	r2,r3,44a30 <pc2dev_parse+0x12c4>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
                        image_erase(i);
                    break;
                default:
                    break;
   43b80:	0004a906 	br	44e28 <pc2dev_parse+0x16bc>
            switch(pc2nios.command)
            {
                // 设置使用那个报警区域，这个值会写到E2PROM，每次设置值都会有3bit为1
                // 从E2PROM里读出报警区域数据，作为比较
                case PC_SET_ALARM_REGION:
                    alarm_region.select = para;
   43b84:	008001b4 	movhi	r2,6
   43b88:	10a5c204 	addi	r2,r2,-26872
   43b8c:	e0fff817 	ldw	r3,-32(fp)
   43b90:	10c1bd15 	stw	r3,1780(r2)

                    if(alarm_region.select <= 15)  // 范围保护
   43b94:	008001b4 	movhi	r2,6
   43b98:	10a5c204 	addi	r2,r2,-26872
   43b9c:	1081bd17 	ldw	r2,1780(r2)
   43ba0:	10800428 	cmpgeui	r2,r2,16
   43ba4:	1004b01e 	bne	r2,zero,44e68 <pc2dev_parse+0x16fc>
                    {
                        eeprom_write_byte(CUR_ALARM_GROUP + 2, buf[10]);
   43ba8:	e0bffd17 	ldw	r2,-12(fp)
   43bac:	10800284 	addi	r2,r2,10
   43bb0:	10800003 	ldbu	r2,0(r2)
   43bb4:	10803fcc 	andi	r2,r2,255
   43bb8:	100b883a 	mov	r5,r2
   43bbc:	01000084 	movi	r4,2
   43bc0:	0041f280 	call	41f28 <eeprom_write_byte>
                        eeprom_write_byte(CUR_ALARM_GROUP + 3, buf[11]);
   43bc4:	e0bffd17 	ldw	r2,-12(fp)
   43bc8:	108002c4 	addi	r2,r2,11
   43bcc:	10800003 	ldbu	r2,0(r2)
   43bd0:	10803fcc 	andi	r2,r2,255
   43bd4:	100b883a 	mov	r5,r2
   43bd8:	010000c4 	movi	r4,3
   43bdc:	0041f280 	call	41f28 <eeprom_write_byte>
                    }
                    else
                        return;
                    //  接受到设置后, 从E2PROM里读出之前的设置数据
                    region_read_from_rom(&alarm_region, alarm_region.select * 3 + 0);
   43be0:	008001b4 	movhi	r2,6
   43be4:	10a5c204 	addi	r2,r2,-26872
   43be8:	10c1bd17 	ldw	r3,1780(r2)
   43bec:	1805883a 	mov	r2,r3
   43bf0:	1085883a 	add	r2,r2,r2
   43bf4:	10c5883a 	add	r2,r2,r3
   43bf8:	100b883a 	mov	r5,r2
   43bfc:	010001b4 	movhi	r4,6
   43c00:	2125c204 	addi	r4,r4,-26872
   43c04:	0045ad40 	call	45ad4 <region_read_from_rom>
                    region_read_from_rom(&alarm_region, alarm_region.select * 3 + 1);
   43c08:	008001b4 	movhi	r2,6
   43c0c:	10a5c204 	addi	r2,r2,-26872
   43c10:	10c1bd17 	ldw	r3,1780(r2)
   43c14:	1805883a 	mov	r2,r3
   43c18:	1085883a 	add	r2,r2,r2
   43c1c:	10c5883a 	add	r2,r2,r3
   43c20:	10800044 	addi	r2,r2,1
   43c24:	100b883a 	mov	r5,r2
   43c28:	010001b4 	movhi	r4,6
   43c2c:	2125c204 	addi	r4,r4,-26872
   43c30:	0045ad40 	call	45ad4 <region_read_from_rom>
                    region_read_from_rom(&alarm_region, alarm_region.select * 3 + 2);
   43c34:	008001b4 	movhi	r2,6
   43c38:	10a5c204 	addi	r2,r2,-26872
   43c3c:	10c1bd17 	ldw	r3,1780(r2)
   43c40:	1805883a 	mov	r2,r3
   43c44:	1085883a 	add	r2,r2,r2
   43c48:	10c5883a 	add	r2,r2,r3
   43c4c:	10800084 	addi	r2,r2,2
   43c50:	100b883a 	mov	r5,r2
   43c54:	010001b4 	movhi	r4,6
   43c58:	2125c204 	addi	r4,r4,-26872
   43c5c:	0045ad40 	call	45ad4 <region_read_from_rom>
                    break;
   43c60:	00047106 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_READ_ALARM_REGION:
                    if(para <= 15)
   43c64:	e0bff817 	ldw	r2,-32(fp)
   43c68:	10800428 	cmpgeui	r2,r2,16
   43c6c:	10042f1e 	bne	r2,zero,44d2c <pc2dev_parse+0x15c0>
                    {
                        nios2pc.command  = NIOS_UP_ALARM_REGION;
   43c70:	008001b4 	movhi	r2,6
   43c74:	10a5bd04 	addi	r2,r2,-26892
   43c78:	00d40044 	movi	r3,20481
   43c7c:	10c00115 	stw	r3,4(r2)
                        nios2pc.data_len = 4;
   43c80:	008001b4 	movhi	r2,6
   43c84:	10a5bd04 	addi	r2,r2,-26892
   43c88:	00c00104 	movi	r3,4
   43c8c:	10c00215 	stw	r3,8(r2)
                        send_len         = pc2dev_packet(&nios2pc, send_buffer);
   43c90:	014001b4 	movhi	r5,6
   43c94:	29481004 	addi	r5,r5,8256
   43c98:	010001b4 	movhi	r4,6
   43c9c:	2125bd04 	addi	r4,r4,-26892
   43ca0:	0044e840 	call	44e84 <pc2dev_packet>
   43ca4:	e0bff915 	stw	r2,-28(fp)
                        send(s, send_buffer, send_len);
   43ca8:	e0fffc03 	ldbu	r3,-16(fp)
   43cac:	e0bff917 	ldw	r2,-28(fp)
   43cb0:	10bfffcc 	andi	r2,r2,65535
   43cb4:	100d883a 	mov	r6,r2
   43cb8:	014001b4 	movhi	r5,6
   43cbc:	29481004 	addi	r5,r5,8256
   43cc0:	1809883a 	mov	r4,r3
   43cc4:	004709c0 	call	4709c <send>
                    }
                    break;
   43cc8:	00041806 	br	44d2c <pc2dev_parse+0x15c0>
                case PC_LOAD_REGION_DATA:
                    // 下传区域边界数据,写入E2PROM的时候,同时写入
                    alarm_region.wr_which = buf[8];
   43ccc:	e0bffd17 	ldw	r2,-12(fp)
   43cd0:	10c00203 	ldbu	r3,8(r2)
   43cd4:	008001b4 	movhi	r2,6
   43cd8:	10a5c204 	addi	r2,r2,-26872
   43cdc:	10c00105 	stb	r3,4(r2)
                    for(i = 0; i < TARGET_NUMBER * 2; i = i + 2)
   43ce0:	e03ff715 	stw	zero,-36(fp)
   43ce4:	00001c06 	br	43d58 <pc2dev_parse+0x5ec>
                    {
                        recv_pos                    = (buf[i + 9] << 8) + buf[i + 1 + 9];
   43ce8:	e0bff717 	ldw	r2,-36(fp)
   43cec:	10800244 	addi	r2,r2,9
   43cf0:	e0fffd17 	ldw	r3,-12(fp)
   43cf4:	1885883a 	add	r2,r3,r2
   43cf8:	10800003 	ldbu	r2,0(r2)
   43cfc:	10803fcc 	andi	r2,r2,255
   43d00:	1004923a 	slli	r2,r2,8
   43d04:	1009883a 	mov	r4,r2
   43d08:	e0bff717 	ldw	r2,-36(fp)
   43d0c:	10800284 	addi	r2,r2,10
   43d10:	e0fffd17 	ldw	r3,-12(fp)
   43d14:	1885883a 	add	r2,r3,r2
   43d18:	10800003 	ldbu	r2,0(r2)
   43d1c:	10803fcc 	andi	r2,r2,255
   43d20:	2085883a 	add	r2,r4,r2
   43d24:	e0bffa0d 	sth	r2,-24(fp)
                        alarm_region.buffer[i >> 1] = recv_pos;
   43d28:	e0bff717 	ldw	r2,-36(fp)
   43d2c:	1007d07a 	srai	r3,r2,1
   43d30:	008001b4 	movhi	r2,6
   43d34:	10a5c204 	addi	r2,r2,-26872
   43d38:	18c01384 	addi	r3,r3,78
   43d3c:	18c7883a 	add	r3,r3,r3
   43d40:	10c5883a 	add	r2,r2,r3
   43d44:	e0fffa0b 	ldhu	r3,-24(fp)
   43d48:	10c0000d 	sth	r3,0(r2)
                    }
                    break;
                case PC_LOAD_REGION_DATA:
                    // 下传区域边界数据,写入E2PROM的时候,同时写入
                    alarm_region.wr_which = buf[8];
                    for(i = 0; i < TARGET_NUMBER * 2; i = i + 2)
   43d4c:	e0bff717 	ldw	r2,-36(fp)
   43d50:	10800084 	addi	r2,r2,2
   43d54:	e0bff715 	stw	r2,-36(fp)
   43d58:	e0bff717 	ldw	r2,-36(fp)
   43d5c:	10819590 	cmplti	r2,r2,1622
   43d60:	103fe11e 	bne	r2,zero,43ce8 <__alt_mem_epcs_flash+0xfffc2ce8>
                    {
                        recv_pos                    = (buf[i + 9] << 8) + buf[i + 1 + 9];
                        alarm_region.buffer[i >> 1] = recv_pos;
                    }
                    // 8+1+TARGET_NUMBER*2 		+ 1 + 102
                    for(i = 0; i < ZENITH_NUMBER; i++)
   43d64:	e03ff715 	stw	zero,-36(fp)
   43d68:	00000f06 	br	43da8 <pc2dev_parse+0x63c>
                    {
                        alarm_region.zenith_save[i] = buf[1631 + i];
   43d6c:	e0bff717 	ldw	r2,-36(fp)
   43d70:	108197c4 	addi	r2,r2,1631
   43d74:	1007883a 	mov	r3,r2
   43d78:	e0bffd17 	ldw	r2,-12(fp)
   43d7c:	10c5883a 	add	r2,r2,r3
   43d80:	10c00003 	ldbu	r3,0(r2)
   43d84:	008001b4 	movhi	r2,6
   43d88:	10a5c204 	addi	r2,r2,-26872
   43d8c:	e13ff717 	ldw	r4,-36(fp)
   43d90:	1105883a 	add	r2,r2,r4
   43d94:	10800184 	addi	r2,r2,6
   43d98:	10c00005 	stb	r3,0(r2)
                    {
                        recv_pos                    = (buf[i + 9] << 8) + buf[i + 1 + 9];
                        alarm_region.buffer[i >> 1] = recv_pos;
                    }
                    // 8+1+TARGET_NUMBER*2 		+ 1 + 102
                    for(i = 0; i < ZENITH_NUMBER; i++)
   43d9c:	e0bff717 	ldw	r2,-36(fp)
   43da0:	10800044 	addi	r2,r2,1
   43da4:	e0bff715 	stw	r2,-36(fp)
   43da8:	e0bff717 	ldw	r2,-36(fp)
   43dac:	108019d0 	cmplti	r2,r2,103
   43db0:	103fee1e 	bne	r2,zero,43d6c <__alt_mem_epcs_flash+0xfffc2d6c>
                    {
                        alarm_region.zenith_save[i] = buf[1631 + i];
                    }
                    // 异或值暂不读取
                    if(SysPara.update_pos_flag)
   43db4:	008001b4 	movhi	r2,6
   43db8:	10a56c04 	addi	r2,r2,-27216
   43dbc:	10800003 	ldbu	r2,0(r2)
   43dc0:	10803fcc 	andi	r2,r2,255
   43dc4:	10000e26 	beq	r2,zero,43e00 <pc2dev_parse+0x694>
                    {
                        set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, DISABLE);
   43dc8:	018888b4 	movhi	r6,8738
   43dcc:	31888884 	addi	r6,r6,8738
   43dd0:	016c0014 	movui	r5,45056
   43dd4:	d1201604 	addi	r4,gp,-32680
   43dd8:	0042fa00 	call	42fa0 <set_laser_paramter>
                        region_save2eeprom(&alarm_region);
   43ddc:	010001b4 	movhi	r4,6
   43de0:	2125c204 	addi	r4,r4,-26872
   43de4:	00458e40 	call	458e4 <region_save2eeprom>
                        set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, ENABLE);
   43de8:	01844474 	movhi	r6,4369
   43dec:	31844444 	addi	r6,r6,4369
   43df0:	016c0014 	movui	r5,45056
   43df4:	d1201604 	addi	r4,gp,-32680
   43df8:	0042fa00 	call	42fa0 <set_laser_paramter>
   43dfc:	00000306 	br	43e0c <pc2dev_parse+0x6a0>
                    }
                    else
                        region_save2eeprom(&alarm_region);
   43e00:	010001b4 	movhi	r4,6
   43e04:	2125c204 	addi	r4,r4,-26872
   43e08:	00458e40 	call	458e4 <region_save2eeprom>
                    // 如果当前开关输入量的值和修改区域的值一样，才去修改FPGA内报警区域值
                    if(alarm_region.change_region_value == alarm_region.wr_which / 3)
   43e0c:	008001b4 	movhi	r2,6
   43e10:	10a5c204 	addi	r2,r2,-26872
   43e14:	140000c3 	ldbu	r16,3(r2)
   43e18:	008001b4 	movhi	r2,6
   43e1c:	10a5c204 	addi	r2,r2,-26872
   43e20:	10800103 	ldbu	r2,4(r2)
   43e24:	10803fcc 	andi	r2,r2,255
   43e28:	014000c4 	movi	r5,3
   43e2c:	1009883a 	mov	r4,r2
   43e30:	00493180 	call	49318 <__udivsi3>
   43e34:	80c03fcc 	andi	r3,r16,255
   43e38:	10803fcc 	andi	r2,r2,255
   43e3c:	1883bd1e 	bne	r3,r2,44d34 <pc2dev_parse+0x15c8>
                        alarm_region.change_region_flag = 0x01;
   43e40:	008001b4 	movhi	r2,6
   43e44:	10a5c204 	addi	r2,r2,-26872
   43e48:	00c00044 	movi	r3,1
   43e4c:	10c00085 	stb	r3,2(r2)
                    break;
   43e50:	0003b806 	br	44d34 <pc2dev_parse+0x15c8>
                case PC_REQ_REGION_DATA:
                    alarm_region.rd_which = (unsigned char)para;
   43e54:	e0bff817 	ldw	r2,-32(fp)
   43e58:	1007883a 	mov	r3,r2
   43e5c:	008001b4 	movhi	r2,6
   43e60:	10a5c204 	addi	r2,r2,-26872
   43e64:	10c00145 	stb	r3,5(r2)
                    nios2pc.command       = NIOS_UP_REGION_DATA;
   43e68:	008001b4 	movhi	r2,6
   43e6c:	10a5bd04 	addi	r2,r2,-26892
   43e70:	00d40084 	movi	r3,20482
   43e74:	10c00115 	stw	r3,4(r2)
                    nios2pc.data_len      = 1 + TARGET_NUMBER * 2 + ZENITH_NUMBER;
   43e78:	008001b4 	movhi	r2,6
   43e7c:	10a5bd04 	addi	r2,r2,-26892
   43e80:	00c1af84 	movi	r3,1726
   43e84:	10c00215 	stw	r3,8(r2)
                    send_len              = pc2dev_packet(&nios2pc, send_buffer);
   43e88:	014001b4 	movhi	r5,6
   43e8c:	29481004 	addi	r5,r5,8256
   43e90:	010001b4 	movhi	r4,6
   43e94:	2125bd04 	addi	r4,r4,-26892
   43e98:	0044e840 	call	44e84 <pc2dev_packet>
   43e9c:	e0bff915 	stw	r2,-28(fp)
                    send(s, send_buffer, send_len);
   43ea0:	e0fffc03 	ldbu	r3,-16(fp)
   43ea4:	e0bff917 	ldw	r2,-28(fp)
   43ea8:	10bfffcc 	andi	r2,r2,65535
   43eac:	100d883a 	mov	r6,r2
   43eb0:	014001b4 	movhi	r5,6
   43eb4:	29481004 	addi	r5,r5,8256
   43eb8:	1809883a 	mov	r4,r3
   43ebc:	004709c0 	call	4709c <send>
                    break;
   43ec0:	0003d906 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_REQ_RADAR_PARA:  // 请求系统状态参数
                    nios2pc.command  = NIOS_UP_RADAR_PARA;
   43ec4:	008001b4 	movhi	r2,6
   43ec8:	10a5bd04 	addi	r2,r2,-26892
   43ecc:	00d40144 	movi	r3,20485
   43ed0:	10c00115 	stw	r3,4(r2)
                    nios2pc.data_len = sizeof(SysPara);
   43ed4:	008001b4 	movhi	r2,6
   43ed8:	10a5bd04 	addi	r2,r2,-26892
   43edc:	00c04d04 	movi	r3,308
   43ee0:	10c00215 	stw	r3,8(r2)
                    send_len         = pc2dev_packet(&nios2pc, send_buffer);
   43ee4:	014001b4 	movhi	r5,6
   43ee8:	29481004 	addi	r5,r5,8256
   43eec:	010001b4 	movhi	r4,6
   43ef0:	2125bd04 	addi	r4,r4,-26892
   43ef4:	0044e840 	call	44e84 <pc2dev_packet>
   43ef8:	e0bff915 	stw	r2,-28(fp)
                    send(s, send_buffer, send_len);
   43efc:	e0fffc03 	ldbu	r3,-16(fp)
   43f00:	e0bff917 	ldw	r2,-28(fp)
   43f04:	10bfffcc 	andi	r2,r2,65535
   43f08:	100d883a 	mov	r6,r2
   43f0c:	014001b4 	movhi	r5,6
   43f10:	29481004 	addi	r5,r5,8256
   43f14:	1809883a 	mov	r4,r3
   43f18:	004709c0 	call	4709c <send>

                    set_laser_paramter(&Nios2FPGA_pck, 0xc000, 0xaaaa);
   43f1c:	01aaaa94 	movui	r6,43690
   43f20:	01700014 	movui	r5,49152
   43f24:	d1201604 	addi	r4,gp,-32680
   43f28:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   43f2c:	0003be06 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_SET_HW_TYPE:
                    SysPara.board_type = para;
   43f30:	008001b4 	movhi	r2,6
   43f34:	10a56c04 	addi	r2,r2,-27216
   43f38:	e0fff817 	ldw	r3,-32(fp)
   43f3c:	10c02c15 	stw	r3,176(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   43f40:	008001b4 	movhi	r2,6
   43f44:	10a5b904 	addi	r2,r2,-26908
   43f48:	10800117 	ldw	r2,4(r2)
   43f4c:	10bfffcc 	andi	r2,r2,65535
   43f50:	e1bff817 	ldw	r6,-32(fp)
   43f54:	100b883a 	mov	r5,r2
   43f58:	d1201604 	addi	r4,gp,-32680
   43f5c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   43f60:	0003b106 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_SAVA_SYS_PARA:
                    save_sys_para(&SysPara);
   43f64:	010001b4 	movhi	r4,6
   43f68:	21256c04 	addi	r4,r4,-27216
   43f6c:	0045b4c0 	call	45b4c <save_sys_para>
                    break;
   43f70:	0003ad06 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_RESET_NIOS:
                    SysStatus.reset_nios = para;
   43f74:	e0bff817 	ldw	r2,-32(fp)
   43f78:	d0a01415 	stw	r2,-32688(gp)
                    break;
   43f7c:	0003aa06 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_SET_SN:
                    memset(SysPara.dev_sn, 0, sizeof(SysPara.dev_sn));
   43f80:	01800404 	movi	r6,16
   43f84:	000b883a 	mov	r5,zero
   43f88:	010001b4 	movhi	r4,6
   43f8c:	2125a404 	addi	r4,r4,-26992
   43f90:	004951c0 	call	4951c <memset>
                    memcpy(SysPara.dev_sn, &buf[8], sizeof(SysPara.dev_sn));
   43f94:	e0bffd17 	ldw	r2,-12(fp)
   43f98:	10c00204 	addi	r3,r2,8
   43f9c:	008001b4 	movhi	r2,6
   43fa0:	10a56c04 	addi	r2,r2,-27216
   43fa4:	10803804 	addi	r2,r2,224
   43fa8:	1809883a 	mov	r4,r3
   43fac:	00c00404 	movi	r3,16
   43fb0:	180d883a 	mov	r6,r3
   43fb4:	200b883a 	mov	r5,r4
   43fb8:	1009883a 	mov	r4,r2
   43fbc:	00493d40 	call	493d4 <memcpy>
                    break;
   43fc0:	00039906 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_SET_DEV_TYPE:
                    memset(SysPara.dev_type, 0, sizeof(SysPara.dev_type));
   43fc4:	01800504 	movi	r6,20
   43fc8:	000b883a 	mov	r5,zero
   43fcc:	010001b4 	movhi	r4,6
   43fd0:	21259a04 	addi	r4,r4,-27032
   43fd4:	004951c0 	call	4951c <memset>
                    memcpy(SysPara.dev_type, &buf[8], sizeof(SysPara.dev_type));
   43fd8:	e0bffd17 	ldw	r2,-12(fp)
   43fdc:	10c00204 	addi	r3,r2,8
   43fe0:	008001b4 	movhi	r2,6
   43fe4:	10a56c04 	addi	r2,r2,-27216
   43fe8:	10802e04 	addi	r2,r2,184
   43fec:	1809883a 	mov	r4,r3
   43ff0:	00c00504 	movi	r3,20
   43ff4:	180d883a 	mov	r6,r3
   43ff8:	200b883a 	mov	r5,r4
   43ffc:	1009883a 	mov	r4,r2
   44000:	00493d40 	call	493d4 <memcpy>
                    break;
   44004:	00038806 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_SET_DUST_THRESHOLD:
                    SysPara.dust_threshold = para;
   44008:	008001b4 	movhi	r2,6
   4400c:	10a56c04 	addi	r2,r2,-27216
   44010:	e0fff817 	ldw	r3,-32(fp)
   44014:	10c04915 	stw	r3,292(r2)
                    break;
   44018:	00038306 	br	44e28 <pc2dev_parse+0x16bc>
                case LASER_ENABLE:
                    if((para == ENABLE) || (para == DISABLE))
   4401c:	e0fff817 	ldw	r3,-32(fp)
   44020:	00844474 	movhi	r2,4369
   44024:	10844444 	addi	r2,r2,4369
   44028:	18800426 	beq	r3,r2,4403c <pc2dev_parse+0x8d0>
   4402c:	e0fff817 	ldw	r3,-32(fp)
   44030:	008888b4 	movhi	r2,8738
   44034:	10888884 	addi	r2,r2,8738
   44038:	1883401e 	bne	r3,r2,44d3c <pc2dev_parse+0x15d0>
                    {
                        SysPara.laser_enable = para;
   4403c:	008001b4 	movhi	r2,6
   44040:	10a56c04 	addi	r2,r2,-27216
   44044:	e0fff817 	ldw	r3,-32(fp)
   44048:	10c00115 	stw	r3,4(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4404c:	008001b4 	movhi	r2,6
   44050:	10a5b904 	addi	r2,r2,-26908
   44054:	10800117 	ldw	r2,4(r2)
   44058:	10bfffcc 	andi	r2,r2,65535
   4405c:	e1bff817 	ldw	r6,-32(fp)
   44060:	100b883a 	mov	r5,r2
   44064:	d1201604 	addi	r4,gp,-32680
   44068:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4406c:	00033306 	br	44d3c <pc2dev_parse+0x15d0>
                case LASER_FREQ:
                    SysPara.laser_freq = para;
   44070:	008001b4 	movhi	r2,6
   44074:	10a56c04 	addi	r2,r2,-27216
   44078:	e0fff817 	ldw	r3,-32(fp)
   4407c:	10c00215 	stw	r3,8(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44080:	008001b4 	movhi	r2,6
   44084:	10a5b904 	addi	r2,r2,-26908
   44088:	10800117 	ldw	r2,4(r2)
   4408c:	10bfffcc 	andi	r2,r2,65535
   44090:	e1bff817 	ldw	r6,-32(fp)
   44094:	100b883a 	mov	r5,r2
   44098:	d1201604 	addi	r4,gp,-32680
   4409c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   440a0:	00036106 	br	44e28 <pc2dev_parse+0x16bc>
                case LASER_PULSE_WIDTH:
                    if((para >= 3) && (para <= 10))
   440a4:	e0bff817 	ldw	r2,-32(fp)
   440a8:	108000f0 	cmpltui	r2,r2,3
   440ac:	1003251e 	bne	r2,zero,44d44 <pc2dev_parse+0x15d8>
   440b0:	e0bff817 	ldw	r2,-32(fp)
   440b4:	108002e8 	cmpgeui	r2,r2,11
   440b8:	1003221e 	bne	r2,zero,44d44 <pc2dev_parse+0x15d8>
                    {
                        SysPara.laser_pulse_width = para;
   440bc:	008001b4 	movhi	r2,6
   440c0:	10a56c04 	addi	r2,r2,-27216
   440c4:	e0fff817 	ldw	r3,-32(fp)
   440c8:	10c00b15 	stw	r3,44(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   440cc:	008001b4 	movhi	r2,6
   440d0:	10a5b904 	addi	r2,r2,-26908
   440d4:	10800117 	ldw	r2,4(r2)
   440d8:	10bfffcc 	andi	r2,r2,65535
   440dc:	e1bff817 	ldw	r6,-32(fp)
   440e0:	100b883a 	mov	r5,r2
   440e4:	d1201604 	addi	r4,gp,-32680
   440e8:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   440ec:	00031506 	br	44d44 <pc2dev_parse+0x15d8>
                case LASER_PRESDO:
                    memset(SysPara.laser_presdo, 0, sizeof(SysPara.laser_presdo));
   440f0:	01800784 	movi	r6,30
   440f4:	000b883a 	mov	r5,zero
   440f8:	010001b4 	movhi	r4,6
   440fc:	2125a804 	addi	r4,r4,-26976
   44100:	004951c0 	call	4951c <memset>
                    memcpy(SysPara.laser_presdo, &buf[8], sizeof(SysPara.laser_presdo));
   44104:	e0bffd17 	ldw	r2,-12(fp)
   44108:	10c00204 	addi	r3,r2,8
   4410c:	008001b4 	movhi	r2,6
   44110:	10a56c04 	addi	r2,r2,-27216
   44114:	10803c04 	addi	r2,r2,240
   44118:	1809883a 	mov	r4,r3
   4411c:	00c00784 	movi	r3,30
   44120:	180d883a 	mov	r6,r3
   44124:	200b883a 	mov	r5,r4
   44128:	1009883a 	mov	r4,r2
   4412c:	00493d40 	call	493d4 <memcpy>
                    break;
   44130:	00033d06 	br	44e28 <pc2dev_parse+0x16bc>
                case LASER_RECV_DELAY:
                    if(para <= 16)
   44134:	e0bff817 	ldw	r2,-32(fp)
   44138:	10800468 	cmpgeui	r2,r2,17
   4413c:	1003031e 	bne	r2,zero,44d4c <pc2dev_parse+0x15e0>
                    {
                        SysPara.laser_recv_delay = para;
   44140:	008001b4 	movhi	r2,6
   44144:	10a56c04 	addi	r2,r2,-27216
   44148:	e0fff817 	ldw	r3,-32(fp)
   4414c:	10c00315 	stw	r3,12(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44150:	008001b4 	movhi	r2,6
   44154:	10a5b904 	addi	r2,r2,-26908
   44158:	10800117 	ldw	r2,4(r2)
   4415c:	10bfffcc 	andi	r2,r2,65535
   44160:	e1bff817 	ldw	r6,-32(fp)
   44164:	100b883a 	mov	r5,r2
   44168:	d1201604 	addi	r4,gp,-32680
   4416c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44170:	0002f606 	br	44d4c <pc2dev_parse+0x15e0>
                case MOTOR_ENABLE:
                    if((para == ENABLE) || (para == DISABLE))
   44174:	e0fff817 	ldw	r3,-32(fp)
   44178:	00844474 	movhi	r2,4369
   4417c:	10844444 	addi	r2,r2,4369
   44180:	18800426 	beq	r3,r2,44194 <pc2dev_parse+0xa28>
   44184:	e0fff817 	ldw	r3,-32(fp)
   44188:	008888b4 	movhi	r2,8738
   4418c:	10888884 	addi	r2,r2,8738
   44190:	1882f01e 	bne	r3,r2,44d54 <pc2dev_parse+0x15e8>
                    {
                        SysPara.motor_enable = para;
   44194:	008001b4 	movhi	r2,6
   44198:	10a56c04 	addi	r2,r2,-27216
   4419c:	e0fff817 	ldw	r3,-32(fp)
   441a0:	10c00415 	stw	r3,16(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   441a4:	008001b4 	movhi	r2,6
   441a8:	10a5b904 	addi	r2,r2,-26908
   441ac:	10800117 	ldw	r2,4(r2)
   441b0:	10bfffcc 	andi	r2,r2,65535
   441b4:	e1bff817 	ldw	r6,-32(fp)
   441b8:	100b883a 	mov	r5,r2
   441bc:	d1201604 	addi	r4,gp,-32680
   441c0:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   441c4:	0002e306 	br	44d54 <pc2dev_parse+0x15e8>
                case MOTOR_SPEED:
                    if((para >= 8) && (para <= 15))
   441c8:	e0bff817 	ldw	r2,-32(fp)
   441cc:	10800230 	cmpltui	r2,r2,8
   441d0:	1002e21e 	bne	r2,zero,44d5c <pc2dev_parse+0x15f0>
   441d4:	e0bff817 	ldw	r2,-32(fp)
   441d8:	10800428 	cmpgeui	r2,r2,16
   441dc:	1002df1e 	bne	r2,zero,44d5c <pc2dev_parse+0x15f0>
                    {
                        SysPara.motor_expect_speed = para;
   441e0:	008001b4 	movhi	r2,6
   441e4:	10a56c04 	addi	r2,r2,-27216
   441e8:	e0fff817 	ldw	r3,-32(fp)
   441ec:	10c00515 	stw	r3,20(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   441f0:	008001b4 	movhi	r2,6
   441f4:	10a5b904 	addi	r2,r2,-26908
   441f8:	10800117 	ldw	r2,4(r2)
   441fc:	10bfffcc 	andi	r2,r2,65535
   44200:	e1bff817 	ldw	r6,-32(fp)
   44204:	100b883a 	mov	r5,r2
   44208:	d1201604 	addi	r4,gp,-32680
   4420c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44210:	0002d206 	br	44d5c <pc2dev_parse+0x15f0>
                case ZERO_DISTANCE_REVISE:
                    if(para <= 1024)
   44214:	e0bff817 	ldw	r2,-32(fp)
   44218:	10810068 	cmpgeui	r2,r2,1025
   4421c:	1002d11e 	bne	r2,zero,44d64 <pc2dev_parse+0x15f8>
                    {
                        SysPara.zero_distance_revise = para;
   44220:	008001b4 	movhi	r2,6
   44224:	10a56c04 	addi	r2,r2,-27216
   44228:	e0fff817 	ldw	r3,-32(fp)
   4422c:	10c00615 	stw	r3,24(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44230:	008001b4 	movhi	r2,6
   44234:	10a5b904 	addi	r2,r2,-26908
   44238:	10800117 	ldw	r2,4(r2)
   4423c:	10bfffcc 	andi	r2,r2,65535
   44240:	e1bff817 	ldw	r6,-32(fp)
   44244:	100b883a 	mov	r5,r2
   44248:	d1201604 	addi	r4,gp,-32680
   4424c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44250:	0002c406 	br	44d64 <pc2dev_parse+0x15f8>
                case ZERO_ANGLE_REVISE:
                    if((para >= 2) && (para <= 240))
   44254:	e0bff817 	ldw	r2,-32(fp)
   44258:	108000b0 	cmpltui	r2,r2,2
   4425c:	1002c31e 	bne	r2,zero,44d6c <pc2dev_parse+0x1600>
   44260:	e0bff817 	ldw	r2,-32(fp)
   44264:	10803c68 	cmpgeui	r2,r2,241
   44268:	1002c01e 	bne	r2,zero,44d6c <pc2dev_parse+0x1600>
                    {
                        SysPara.zero_angle_revise = para;
   4426c:	008001b4 	movhi	r2,6
   44270:	10a56c04 	addi	r2,r2,-27216
   44274:	e0fff817 	ldw	r3,-32(fp)
   44278:	10c00715 	stw	r3,28(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4427c:	008001b4 	movhi	r2,6
   44280:	10a5b904 	addi	r2,r2,-26908
   44284:	10800117 	ldw	r2,4(r2)
   44288:	10bfffcc 	andi	r2,r2,65535
   4428c:	e1bff817 	ldw	r6,-32(fp)
   44290:	100b883a 	mov	r5,r2
   44294:	d1201604 	addi	r4,gp,-32680
   44298:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4429c:	0002b306 	br	44d6c <pc2dev_parse+0x1600>
                case GRAY_DISTANCE_REVISE1:
                    SysPara.gray_distance_revise1 = para;
   442a0:	008001b4 	movhi	r2,6
   442a4:	10a56c04 	addi	r2,r2,-27216
   442a8:	e0fff817 	ldw	r3,-32(fp)
   442ac:	10c00815 	stw	r3,32(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   442b0:	008001b4 	movhi	r2,6
   442b4:	10a5b904 	addi	r2,r2,-26908
   442b8:	10800117 	ldw	r2,4(r2)
   442bc:	10bfffcc 	andi	r2,r2,65535
   442c0:	e1bff817 	ldw	r6,-32(fp)
   442c4:	100b883a 	mov	r5,r2
   442c8:	d1201604 	addi	r4,gp,-32680
   442cc:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   442d0:	0002d506 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_DISTANCE_REVISE2:
                    SysPara.gray_distance_revise2 = para;
   442d4:	008001b4 	movhi	r2,6
   442d8:	10a56c04 	addi	r2,r2,-27216
   442dc:	e0fff817 	ldw	r3,-32(fp)
   442e0:	10c00915 	stw	r3,36(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   442e4:	008001b4 	movhi	r2,6
   442e8:	10a5b904 	addi	r2,r2,-26908
   442ec:	10800117 	ldw	r2,4(r2)
   442f0:	10bfffcc 	andi	r2,r2,65535
   442f4:	e1bff817 	ldw	r6,-32(fp)
   442f8:	100b883a 	mov	r5,r2
   442fc:	d1201604 	addi	r4,gp,-32680
   44300:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   44304:	0002c806 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_DISTANCE_REVISE3:
                    SysPara.gray_distance_revise3 = para;
   44308:	008001b4 	movhi	r2,6
   4430c:	10a56c04 	addi	r2,r2,-27216
   44310:	e0fff817 	ldw	r3,-32(fp)
   44314:	10c00a15 	stw	r3,40(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44318:	008001b4 	movhi	r2,6
   4431c:	10a5b904 	addi	r2,r2,-26908
   44320:	10800117 	ldw	r2,4(r2)
   44324:	10bfffcc 	andi	r2,r2,65535
   44328:	e1bff817 	ldw	r6,-32(fp)
   4432c:	100b883a 	mov	r5,r2
   44330:	d1201604 	addi	r4,gp,-32680
   44334:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   44338:	0002bb06 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_DISTANCE_REVISE4:
                    SysPara.gray_distance_revise4 = para;
   4433c:	008001b4 	movhi	r2,6
   44340:	10a56c04 	addi	r2,r2,-27216
   44344:	e0fff817 	ldw	r3,-32(fp)
   44348:	10c04715 	stw	r3,284(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4434c:	008001b4 	movhi	r2,6
   44350:	10a5b904 	addi	r2,r2,-26908
   44354:	10800117 	ldw	r2,4(r2)
   44358:	10bfffcc 	andi	r2,r2,65535
   4435c:	e1bff817 	ldw	r6,-32(fp)
   44360:	100b883a 	mov	r5,r2
   44364:	d1201604 	addi	r4,gp,-32680
   44368:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   4436c:	0002ae06 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_DISTANCE_REVISE5:
                    SysPara.gray_distance_revise5 = para;
   44370:	008001b4 	movhi	r2,6
   44374:	10a56c04 	addi	r2,r2,-27216
   44378:	e0fff817 	ldw	r3,-32(fp)
   4437c:	10c04815 	stw	r3,288(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44380:	008001b4 	movhi	r2,6
   44384:	10a5b904 	addi	r2,r2,-26908
   44388:	10800117 	ldw	r2,4(r2)
   4438c:	10bfffcc 	andi	r2,r2,65535
   44390:	e1bff817 	ldw	r6,-32(fp)
   44394:	100b883a 	mov	r5,r2
   44398:	d1201604 	addi	r4,gp,-32680
   4439c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   443a0:	0002a106 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_INFLECTION1:
                    SysPara.gray_inflection1 = para;
   443a4:	008001b4 	movhi	r2,6
   443a8:	10a56c04 	addi	r2,r2,-27216
   443ac:	e0fff817 	ldw	r3,-32(fp)
   443b0:	10c01015 	stw	r3,64(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   443b4:	008001b4 	movhi	r2,6
   443b8:	10a5b904 	addi	r2,r2,-26908
   443bc:	10800117 	ldw	r2,4(r2)
   443c0:	10bfffcc 	andi	r2,r2,65535
   443c4:	e1bff817 	ldw	r6,-32(fp)
   443c8:	100b883a 	mov	r5,r2
   443cc:	d1201604 	addi	r4,gp,-32680
   443d0:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   443d4:	00029406 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_INFLECTION2:
                    SysPara.gray_inflection2 = para;
   443d8:	008001b4 	movhi	r2,6
   443dc:	10a56c04 	addi	r2,r2,-27216
   443e0:	e0fff817 	ldw	r3,-32(fp)
   443e4:	10c01115 	stw	r3,68(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   443e8:	008001b4 	movhi	r2,6
   443ec:	10a5b904 	addi	r2,r2,-26908
   443f0:	10800117 	ldw	r2,4(r2)
   443f4:	10bfffcc 	andi	r2,r2,65535
   443f8:	e1bff817 	ldw	r6,-32(fp)
   443fc:	100b883a 	mov	r5,r2
   44400:	d1201604 	addi	r4,gp,-32680
   44404:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   44408:	00028706 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_INFLECTION3:
                    SysPara.gray_inflection3 = para;
   4440c:	008001b4 	movhi	r2,6
   44410:	10a56c04 	addi	r2,r2,-27216
   44414:	e0fff817 	ldw	r3,-32(fp)
   44418:	10c04515 	stw	r3,276(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4441c:	008001b4 	movhi	r2,6
   44420:	10a5b904 	addi	r2,r2,-26908
   44424:	10800117 	ldw	r2,4(r2)
   44428:	10bfffcc 	andi	r2,r2,65535
   4442c:	e1bff817 	ldw	r6,-32(fp)
   44430:	100b883a 	mov	r5,r2
   44434:	d1201604 	addi	r4,gp,-32680
   44438:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   4443c:	00027a06 	br	44e28 <pc2dev_parse+0x16bc>
                case GRAY_INFLECTION4:
                    SysPara.gray_inflection4 = para;
   44440:	008001b4 	movhi	r2,6
   44444:	10a56c04 	addi	r2,r2,-27216
   44448:	e0fff817 	ldw	r3,-32(fp)
   4444c:	10c04615 	stw	r3,280(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44450:	008001b4 	movhi	r2,6
   44454:	10a5b904 	addi	r2,r2,-26908
   44458:	10800117 	ldw	r2,4(r2)
   4445c:	10bfffcc 	andi	r2,r2,65535
   44460:	e1bff817 	ldw	r6,-32(fp)
   44464:	100b883a 	mov	r5,r2
   44468:	d1201604 	addi	r4,gp,-32680
   4446c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   44470:	00026d06 	br	44e28 <pc2dev_parse+0x16bc>
                case NOISE_DIFF_SETTING1:
                    SysPara.noise_diff_setting1 = para;
   44474:	008001b4 	movhi	r2,6
   44478:	10a56c04 	addi	r2,r2,-27216
   4447c:	e0fff817 	ldw	r3,-32(fp)
   44480:	10c00d15 	stw	r3,52(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44484:	008001b4 	movhi	r2,6
   44488:	10a5b904 	addi	r2,r2,-26908
   4448c:	10800117 	ldw	r2,4(r2)
   44490:	10bfffcc 	andi	r2,r2,65535
   44494:	e1bff817 	ldw	r6,-32(fp)
   44498:	100b883a 	mov	r5,r2
   4449c:	d1201604 	addi	r4,gp,-32680
   444a0:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   444a4:	00026006 	br	44e28 <pc2dev_parse+0x16bc>
                case NOISE_DIFF_SETTING2:
                    SysPara.noise_diff_setting2 = para;
   444a8:	008001b4 	movhi	r2,6
   444ac:	10a56c04 	addi	r2,r2,-27216
   444b0:	e0fff817 	ldw	r3,-32(fp)
   444b4:	10c00e15 	stw	r3,56(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   444b8:	008001b4 	movhi	r2,6
   444bc:	10a5b904 	addi	r2,r2,-26908
   444c0:	10800117 	ldw	r2,4(r2)
   444c4:	10bfffcc 	andi	r2,r2,65535
   444c8:	e1bff817 	ldw	r6,-32(fp)
   444cc:	100b883a 	mov	r5,r2
   444d0:	d1201604 	addi	r4,gp,-32680
   444d4:	0042fa00 	call	42fa0 <set_laser_paramter>
                    break;
   444d8:	00025306 	br	44e28 <pc2dev_parse+0x16bc>

                case SIGNAL_THRESHOLD:
                    if(para <= 1024)
   444dc:	e0bff817 	ldw	r2,-32(fp)
   444e0:	10810068 	cmpgeui	r2,r2,1025
   444e4:	1002231e 	bne	r2,zero,44d74 <pc2dev_parse+0x1608>
                    {
                        SysPara.signal_thresold = para;
   444e8:	008001b4 	movhi	r2,6
   444ec:	10a56c04 	addi	r2,r2,-27216
   444f0:	e0fff817 	ldw	r3,-32(fp)
   444f4:	10c00c15 	stw	r3,48(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   444f8:	008001b4 	movhi	r2,6
   444fc:	10a5b904 	addi	r2,r2,-26908
   44500:	10800117 	ldw	r2,4(r2)
   44504:	10bfffcc 	andi	r2,r2,65535
   44508:	e1bff817 	ldw	r6,-32(fp)
   4450c:	100b883a 	mov	r5,r2
   44510:	d1201604 	addi	r4,gp,-32680
   44514:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44518:	00021606 	br	44d74 <pc2dev_parse+0x1608>
                case APD_VOL_SETTING:
                    if((para & 0x3f) <= 1024)
   4451c:	e0bff817 	ldw	r2,-32(fp)
   44520:	10800fcc 	andi	r2,r2,63
   44524:	10810068 	cmpgeui	r2,r2,1025
   44528:	1002141e 	bne	r2,zero,44d7c <pc2dev_parse+0x1610>
                    {
                        if((para >> 15 & 0x01) == 0x01)
   4452c:	e0bff817 	ldw	r2,-32(fp)
   44530:	10a0000c 	andi	r2,r2,32768
   44534:	10000526 	beq	r2,zero,4454c <pc2dev_parse+0xde0>
                            SysPara.signal_thresold = para;
   44538:	008001b4 	movhi	r2,6
   4453c:	10a56c04 	addi	r2,r2,-27216
   44540:	e0fff817 	ldw	r3,-32(fp)
   44544:	10c00c15 	stw	r3,48(r2)
   44548:	00000406 	br	4455c <pc2dev_parse+0xdf0>
                        else
                            SysPara.apd_vol_base = para;
   4454c:	008001b4 	movhi	r2,6
   44550:	10a56c04 	addi	r2,r2,-27216
   44554:	e0fff817 	ldw	r3,-32(fp)
   44558:	10c00f15 	stw	r3,60(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4455c:	008001b4 	movhi	r2,6
   44560:	10a5b904 	addi	r2,r2,-26908
   44564:	10800117 	ldw	r2,4(r2)
   44568:	10bfffcc 	andi	r2,r2,65535
   4456c:	e1bff817 	ldw	r6,-32(fp)
   44570:	100b883a 	mov	r5,r2
   44574:	d1201604 	addi	r4,gp,-32680
   44578:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4457c:	0001ff06 	br	44d7c <pc2dev_parse+0x1610>
                case TEMP_VOL_COF1:
                    if((para >= 20) && (para <= 45))
   44580:	e0bff817 	ldw	r2,-32(fp)
   44584:	10800530 	cmpltui	r2,r2,20
   44588:	1001fe1e 	bne	r2,zero,44d84 <pc2dev_parse+0x1618>
   4458c:	e0bff817 	ldw	r2,-32(fp)
   44590:	10800ba8 	cmpgeui	r2,r2,46
   44594:	1001fb1e 	bne	r2,zero,44d84 <pc2dev_parse+0x1618>
                    {
                        SysPara.temp_volt_cof1 = para;
   44598:	008001b4 	movhi	r2,6
   4459c:	10a56c04 	addi	r2,r2,-27216
   445a0:	e0fff817 	ldw	r3,-32(fp)
   445a4:	10c01715 	stw	r3,92(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   445a8:	008001b4 	movhi	r2,6
   445ac:	10a5b904 	addi	r2,r2,-26908
   445b0:	10800117 	ldw	r2,4(r2)
   445b4:	10bfffcc 	andi	r2,r2,65535
   445b8:	e1bff817 	ldw	r6,-32(fp)
   445bc:	100b883a 	mov	r5,r2
   445c0:	d1201604 	addi	r4,gp,-32680
   445c4:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   445c8:	0001ee06 	br	44d84 <pc2dev_parse+0x1618>
                case TEMP_VOL_COF2:
                    if((para >= 20) && (para <= 45))
   445cc:	e0bff817 	ldw	r2,-32(fp)
   445d0:	10800530 	cmpltui	r2,r2,20
   445d4:	1001ed1e 	bne	r2,zero,44d8c <pc2dev_parse+0x1620>
   445d8:	e0bff817 	ldw	r2,-32(fp)
   445dc:	10800ba8 	cmpgeui	r2,r2,46
   445e0:	1001ea1e 	bne	r2,zero,44d8c <pc2dev_parse+0x1620>
                    {
                        SysPara.temp_volt_cof2 = para;
   445e4:	008001b4 	movhi	r2,6
   445e8:	10a56c04 	addi	r2,r2,-27216
   445ec:	e0fff817 	ldw	r3,-32(fp)
   445f0:	10c01815 	stw	r3,96(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   445f4:	008001b4 	movhi	r2,6
   445f8:	10a5b904 	addi	r2,r2,-26908
   445fc:	10800117 	ldw	r2,4(r2)
   44600:	10bfffcc 	andi	r2,r2,65535
   44604:	e1bff817 	ldw	r6,-32(fp)
   44608:	100b883a 	mov	r5,r2
   4460c:	d1201604 	addi	r4,gp,-32680
   44610:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44614:	0001dd06 	br	44d8c <pc2dev_parse+0x1620>
                case TEMP_VOL_INFLECTION:
                    if(para <= 50)
   44618:	e0bff817 	ldw	r2,-32(fp)
   4461c:	10800ce8 	cmpgeui	r2,r2,51
   44620:	1001dc1e 	bne	r2,zero,44d94 <pc2dev_parse+0x1628>
                    {
                        SysPara.temp_volt_inflection = para;
   44624:	008001b4 	movhi	r2,6
   44628:	10a56c04 	addi	r2,r2,-27216
   4462c:	e0fff817 	ldw	r3,-32(fp)
   44630:	10c01915 	stw	r3,100(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44634:	008001b4 	movhi	r2,6
   44638:	10a5b904 	addi	r2,r2,-26908
   4463c:	10800117 	ldw	r2,4(r2)
   44640:	10bfffcc 	andi	r2,r2,65535
   44644:	e1bff817 	ldw	r6,-32(fp)
   44648:	100b883a 	mov	r5,r2
   4464c:	d1201604 	addi	r4,gp,-32680
   44650:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44654:	0001cf06 	br	44d94 <pc2dev_parse+0x1628>
                case TEMP_DISTANCE_COF1:
                    if(para <= 128)
   44658:	e0bff817 	ldw	r2,-32(fp)
   4465c:	10802068 	cmpgeui	r2,r2,129
   44660:	1001ce1e 	bne	r2,zero,44d9c <pc2dev_parse+0x1630>
                    {
                        SysPara.temp_distance_cof1 = para;
   44664:	008001b4 	movhi	r2,6
   44668:	10a56c04 	addi	r2,r2,-27216
   4466c:	e0fff817 	ldw	r3,-32(fp)
   44670:	10c01a15 	stw	r3,104(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44674:	008001b4 	movhi	r2,6
   44678:	10a5b904 	addi	r2,r2,-26908
   4467c:	10800117 	ldw	r2,4(r2)
   44680:	10bfffcc 	andi	r2,r2,65535
   44684:	e1bff817 	ldw	r6,-32(fp)
   44688:	100b883a 	mov	r5,r2
   4468c:	d1201604 	addi	r4,gp,-32680
   44690:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44694:	0001c106 	br	44d9c <pc2dev_parse+0x1630>

                case TEMP_DISTANCE_COF2:
                    if(para <= 128)
   44698:	e0bff817 	ldw	r2,-32(fp)
   4469c:	10802068 	cmpgeui	r2,r2,129
   446a0:	1001c01e 	bne	r2,zero,44da4 <pc2dev_parse+0x1638>
                    {
                        SysPara.temp_distance_cof2 = para;
   446a4:	008001b4 	movhi	r2,6
   446a8:	10a56c04 	addi	r2,r2,-27216
   446ac:	e0fff817 	ldw	r3,-32(fp)
   446b0:	10c01b15 	stw	r3,108(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   446b4:	008001b4 	movhi	r2,6
   446b8:	10a5b904 	addi	r2,r2,-26908
   446bc:	10800117 	ldw	r2,4(r2)
   446c0:	10bfffcc 	andi	r2,r2,65535
   446c4:	e1bff817 	ldw	r6,-32(fp)
   446c8:	100b883a 	mov	r5,r2
   446cc:	d1201604 	addi	r4,gp,-32680
   446d0:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   446d4:	0001b306 	br	44da4 <pc2dev_parse+0x1638>
                case TEMP_DISTANCE_INFLECTION:
                    if(para <= 60)
   446d8:	e0bff817 	ldw	r2,-32(fp)
   446dc:	10800f68 	cmpgeui	r2,r2,61
   446e0:	1001b21e 	bne	r2,zero,44dac <pc2dev_parse+0x1640>
                    {
                        SysPara.temp_distance_inflection = para;
   446e4:	e0fff817 	ldw	r3,-32(fp)
   446e8:	008001b4 	movhi	r2,6
   446ec:	10a56c04 	addi	r2,r2,-27216
   446f0:	10c01c15 	stw	r3,112(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   446f4:	008001b4 	movhi	r2,6
   446f8:	10a5b904 	addi	r2,r2,-26908
   446fc:	10800117 	ldw	r2,4(r2)
   44700:	10bfffcc 	andi	r2,r2,65535
   44704:	e1bff817 	ldw	r6,-32(fp)
   44708:	100b883a 	mov	r5,r2
   4470c:	d1201604 	addi	r4,gp,-32680
   44710:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44714:	0001a506 	br	44dac <pc2dev_parse+0x1640>
                case VALID_NUM_THRESHOLD:
                    if((para > 1) && (para < 40))
   44718:	e0bff817 	ldw	r2,-32(fp)
   4471c:	108000b0 	cmpltui	r2,r2,2
   44720:	1001a41e 	bne	r2,zero,44db4 <pc2dev_parse+0x1648>
   44724:	e0bff817 	ldw	r2,-32(fp)
   44728:	10800a28 	cmpgeui	r2,r2,40
   4472c:	1001a11e 	bne	r2,zero,44db4 <pc2dev_parse+0x1648>
                    {
                        SysPara.valid_num_threshold = para;
   44730:	008001b4 	movhi	r2,6
   44734:	10a56c04 	addi	r2,r2,-27216
   44738:	e0fff817 	ldw	r3,-32(fp)
   4473c:	10c04415 	stw	r3,272(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44740:	008001b4 	movhi	r2,6
   44744:	10a5b904 	addi	r2,r2,-26908
   44748:	10800117 	ldw	r2,4(r2)
   4474c:	10bfffcc 	andi	r2,r2,65535
   44750:	e1bff817 	ldw	r6,-32(fp)
   44754:	100b883a 	mov	r5,r2
   44758:	d1201604 	addi	r4,gp,-32680
   4475c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44760:	00019406 	br	44db4 <pc2dev_parse+0x1648>
                case MIN_DISTANCE_VALUE:
                    if(para <= 500)
   44764:	e0bff817 	ldw	r2,-32(fp)
   44768:	10807d68 	cmpgeui	r2,r2,501
   4476c:	1001931e 	bne	r2,zero,44dbc <pc2dev_parse+0x1650>
                    {
                        SysPara.min_display_distance = para;
   44770:	008001b4 	movhi	r2,6
   44774:	10a56c04 	addi	r2,r2,-27216
   44778:	e0fff817 	ldw	r3,-32(fp)
   4477c:	10c01215 	stw	r3,72(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44780:	008001b4 	movhi	r2,6
   44784:	10a5b904 	addi	r2,r2,-26908
   44788:	10800117 	ldw	r2,4(r2)
   4478c:	10bfffcc 	andi	r2,r2,65535
   44790:	e1bff817 	ldw	r6,-32(fp)
   44794:	100b883a 	mov	r5,r2
   44798:	d1201604 	addi	r4,gp,-32680
   4479c:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   447a0:	00018606 	br	44dbc <pc2dev_parse+0x1650>
                case FIRST_NOISE_FILTER:
                    if((para >= 2) && (para <= 12))
   447a4:	e0bff817 	ldw	r2,-32(fp)
   447a8:	108000b0 	cmpltui	r2,r2,2
   447ac:	1001851e 	bne	r2,zero,44dc4 <pc2dev_parse+0x1658>
   447b0:	e0bff817 	ldw	r2,-32(fp)
   447b4:	10800368 	cmpgeui	r2,r2,13
   447b8:	1001821e 	bne	r2,zero,44dc4 <pc2dev_parse+0x1658>
                    {
                        SysPara.first_noise_filter = para;
   447bc:	008001b4 	movhi	r2,6
   447c0:	10a56c04 	addi	r2,r2,-27216
   447c4:	e0fff817 	ldw	r3,-32(fp)
   447c8:	10c01415 	stw	r3,80(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   447cc:	008001b4 	movhi	r2,6
   447d0:	10a5b904 	addi	r2,r2,-26908
   447d4:	10800117 	ldw	r2,4(r2)
   447d8:	10bfffcc 	andi	r2,r2,65535
   447dc:	e1bff817 	ldw	r6,-32(fp)
   447e0:	100b883a 	mov	r5,r2
   447e4:	d1201604 	addi	r4,gp,-32680
   447e8:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   447ec:	00017506 	br	44dc4 <pc2dev_parse+0x1658>
                case DUST_ALARM_THRESHOLD:
                    if(para <= 100)
   447f0:	e0bff817 	ldw	r2,-32(fp)
   447f4:	10801968 	cmpgeui	r2,r2,101
   447f8:	1001741e 	bne	r2,zero,44dcc <pc2dev_parse+0x1660>
                    {
                        SysPara.dust_alarm_threshold = para;
   447fc:	008001b4 	movhi	r2,6
   44800:	10a56c04 	addi	r2,r2,-27216
   44804:	e0fff817 	ldw	r3,-32(fp)
   44808:	10c02215 	stw	r3,136(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4480c:	008001b4 	movhi	r2,6
   44810:	10a5b904 	addi	r2,r2,-26908
   44814:	10800117 	ldw	r2,4(r2)
   44818:	10bfffcc 	andi	r2,r2,65535
   4481c:	e1bff817 	ldw	r6,-32(fp)
   44820:	100b883a 	mov	r5,r2
   44824:	d1201604 	addi	r4,gp,-32680
   44828:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4482c:	00016706 	br	44dcc <pc2dev_parse+0x1660>

                case DA_CYCLE_PARA1:
                    if(para <= 1023)
   44830:	e0bff817 	ldw	r2,-32(fp)
   44834:	10810028 	cmpgeui	r2,r2,1024
   44838:	1001661e 	bne	r2,zero,44dd4 <pc2dev_parse+0x1668>
                    {
                        SysPara.da_cycle_para1 = para;
   4483c:	008001b4 	movhi	r2,6
   44840:	10a56c04 	addi	r2,r2,-27216
   44844:	e0fff817 	ldw	r3,-32(fp)
   44848:	10c02315 	stw	r3,140(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4484c:	008001b4 	movhi	r2,6
   44850:	10a5b904 	addi	r2,r2,-26908
   44854:	10800117 	ldw	r2,4(r2)
   44858:	10bfffcc 	andi	r2,r2,65535
   4485c:	e1bff817 	ldw	r6,-32(fp)
   44860:	100b883a 	mov	r5,r2
   44864:	d1201604 	addi	r4,gp,-32680
   44868:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4486c:	00015906 	br	44dd4 <pc2dev_parse+0x1668>
                case DA_CYCLE_PARA2:
                    if(para <= 1023)
   44870:	e0bff817 	ldw	r2,-32(fp)
   44874:	10810028 	cmpgeui	r2,r2,1024
   44878:	1001581e 	bne	r2,zero,44ddc <pc2dev_parse+0x1670>
                    {
                        SysPara.da_cycle_para2 = para;
   4487c:	008001b4 	movhi	r2,6
   44880:	10a56c04 	addi	r2,r2,-27216
   44884:	e0fff817 	ldw	r3,-32(fp)
   44888:	10c02415 	stw	r3,144(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4488c:	008001b4 	movhi	r2,6
   44890:	10a5b904 	addi	r2,r2,-26908
   44894:	10800117 	ldw	r2,4(r2)
   44898:	10bfffcc 	andi	r2,r2,65535
   4489c:	e1bff817 	ldw	r6,-32(fp)
   448a0:	100b883a 	mov	r5,r2
   448a4:	d1201604 	addi	r4,gp,-32680
   448a8:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   448ac:	00014b06 	br	44ddc <pc2dev_parse+0x1670>
                case DA_CYCLE_PARA3:
                    if(para <= 1023)
   448b0:	e0bff817 	ldw	r2,-32(fp)
   448b4:	10810028 	cmpgeui	r2,r2,1024
   448b8:	10014a1e 	bne	r2,zero,44de4 <pc2dev_parse+0x1678>
                    {
                        SysPara.da_cycle_para3 = para;
   448bc:	008001b4 	movhi	r2,6
   448c0:	10a56c04 	addi	r2,r2,-27216
   448c4:	e0fff817 	ldw	r3,-32(fp)
   448c8:	10c02515 	stw	r3,148(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   448cc:	008001b4 	movhi	r2,6
   448d0:	10a5b904 	addi	r2,r2,-26908
   448d4:	10800117 	ldw	r2,4(r2)
   448d8:	10bfffcc 	andi	r2,r2,65535
   448dc:	e1bff817 	ldw	r6,-32(fp)
   448e0:	100b883a 	mov	r5,r2
   448e4:	d1201604 	addi	r4,gp,-32680
   448e8:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   448ec:	00013d06 	br	44de4 <pc2dev_parse+0x1678>
                case DA_CYCLE_PARA4:
                    if(para <= 1023)
   448f0:	e0bff817 	ldw	r2,-32(fp)
   448f4:	10810028 	cmpgeui	r2,r2,1024
   448f8:	10013c1e 	bne	r2,zero,44dec <pc2dev_parse+0x1680>
                    {
                        SysPara.da_cycle_para4 = para;
   448fc:	008001b4 	movhi	r2,6
   44900:	10a56c04 	addi	r2,r2,-27216
   44904:	e0fff817 	ldw	r3,-32(fp)
   44908:	10c02615 	stw	r3,152(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4490c:	008001b4 	movhi	r2,6
   44910:	10a5b904 	addi	r2,r2,-26908
   44914:	10800117 	ldw	r2,4(r2)
   44918:	10bfffcc 	andi	r2,r2,65535
   4491c:	e1bff817 	ldw	r6,-32(fp)
   44920:	100b883a 	mov	r5,r2
   44924:	d1201604 	addi	r4,gp,-32680
   44928:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4492c:	00012f06 	br	44dec <pc2dev_parse+0x1680>
                case DA_CYCLE_PARA5:
                    if(para <= 1023)
   44930:	e0bff817 	ldw	r2,-32(fp)
   44934:	10810028 	cmpgeui	r2,r2,1024
   44938:	10012e1e 	bne	r2,zero,44df4 <pc2dev_parse+0x1688>
                    {
                        SysPara.da_cycle_para5 = para;
   4493c:	008001b4 	movhi	r2,6
   44940:	10a56c04 	addi	r2,r2,-27216
   44944:	e0fff817 	ldw	r3,-32(fp)
   44948:	10c02715 	stw	r3,156(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4494c:	008001b4 	movhi	r2,6
   44950:	10a5b904 	addi	r2,r2,-26908
   44954:	10800117 	ldw	r2,4(r2)
   44958:	10bfffcc 	andi	r2,r2,65535
   4495c:	e1bff817 	ldw	r6,-32(fp)
   44960:	100b883a 	mov	r5,r2
   44964:	d1201604 	addi	r4,gp,-32680
   44968:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   4496c:	00012106 	br	44df4 <pc2dev_parse+0x1688>
                case DA_CYCLE_PARA6:
                    if(para <= 1023)
   44970:	e0bff817 	ldw	r2,-32(fp)
   44974:	10810028 	cmpgeui	r2,r2,1024
   44978:	1001201e 	bne	r2,zero,44dfc <pc2dev_parse+0x1690>
                    {
                        SysPara.da_cycle_para6 = para;
   4497c:	008001b4 	movhi	r2,6
   44980:	10a56c04 	addi	r2,r2,-27216
   44984:	e0fff817 	ldw	r3,-32(fp)
   44988:	10c02815 	stw	r3,160(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   4498c:	008001b4 	movhi	r2,6
   44990:	10a5b904 	addi	r2,r2,-26908
   44994:	10800117 	ldw	r2,4(r2)
   44998:	10bfffcc 	andi	r2,r2,65535
   4499c:	e1bff817 	ldw	r6,-32(fp)
   449a0:	100b883a 	mov	r5,r2
   449a4:	d1201604 	addi	r4,gp,-32680
   449a8:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   449ac:	00011306 	br	44dfc <pc2dev_parse+0x1690>
                case DA_CYCLE_PARA7:
                    if(para <= 1023)
   449b0:	e0bff817 	ldw	r2,-32(fp)
   449b4:	10810028 	cmpgeui	r2,r2,1024
   449b8:	1001121e 	bne	r2,zero,44e04 <pc2dev_parse+0x1698>
                    {
                        SysPara.da_cycle_para7 = para;
   449bc:	008001b4 	movhi	r2,6
   449c0:	10a56c04 	addi	r2,r2,-27216
   449c4:	e0fff817 	ldw	r3,-32(fp)
   449c8:	10c02915 	stw	r3,164(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   449cc:	008001b4 	movhi	r2,6
   449d0:	10a5b904 	addi	r2,r2,-26908
   449d4:	10800117 	ldw	r2,4(r2)
   449d8:	10bfffcc 	andi	r2,r2,65535
   449dc:	e1bff817 	ldw	r6,-32(fp)
   449e0:	100b883a 	mov	r5,r2
   449e4:	d1201604 	addi	r4,gp,-32680
   449e8:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   449ec:	00010506 	br	44e04 <pc2dev_parse+0x1698>
                case DA_CYCLE_PARA8:
                    if(para <= 1023)
   449f0:	e0bff817 	ldw	r2,-32(fp)
   449f4:	10810028 	cmpgeui	r2,r2,1024
   449f8:	1001041e 	bne	r2,zero,44e0c <pc2dev_parse+0x16a0>
                    {
                        SysPara.da_cycle_para8 = para;
   449fc:	008001b4 	movhi	r2,6
   44a00:	10a56c04 	addi	r2,r2,-27216
   44a04:	e0fff817 	ldw	r3,-32(fp)
   44a08:	10c02a15 	stw	r3,168(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44a0c:	008001b4 	movhi	r2,6
   44a10:	10a5b904 	addi	r2,r2,-26908
   44a14:	10800117 	ldw	r2,4(r2)
   44a18:	10bfffcc 	andi	r2,r2,65535
   44a1c:	e1bff817 	ldw	r6,-32(fp)
   44a20:	100b883a 	mov	r5,r2
   44a24:	d1201604 	addi	r4,gp,-32680
   44a28:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44a2c:	0000f706 	br	44e0c <pc2dev_parse+0x16a0>
                case DA_CYCLE_PARA9:
                    if(para <= 1023)
   44a30:	e0bff817 	ldw	r2,-32(fp)
   44a34:	10810028 	cmpgeui	r2,r2,1024
   44a38:	1000f61e 	bne	r2,zero,44e14 <pc2dev_parse+0x16a8>
                    {
                        SysPara.da_cycle_para9 = para;
   44a3c:	008001b4 	movhi	r2,6
   44a40:	10a56c04 	addi	r2,r2,-27216
   44a44:	e0fff817 	ldw	r3,-32(fp)
   44a48:	10c02b15 	stw	r3,172(r2)
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44a4c:	008001b4 	movhi	r2,6
   44a50:	10a5b904 	addi	r2,r2,-26908
   44a54:	10800117 	ldw	r2,4(r2)
   44a58:	10bfffcc 	andi	r2,r2,65535
   44a5c:	e1bff817 	ldw	r6,-32(fp)
   44a60:	100b883a 	mov	r5,r2
   44a64:	d1201604 	addi	r4,gp,-32680
   44a68:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44a6c:	0000e906 	br	44e14 <pc2dev_parse+0x16a8>
                case MIN_TARGET_SIZE:
                	if((para >= 0) && (para <= 8000))
   44a70:	e0bff817 	ldw	r2,-32(fp)
   44a74:	1087d068 	cmpgeui	r2,r2,8001
   44a78:	1000e81e 	bne	r2,zero,44e1c <pc2dev_parse+0x16b0>
                	{
                    SysPara.min_target_size = para;
   44a7c:	008001b4 	movhi	r2,6
   44a80:	10a56c04 	addi	r2,r2,-27216
   44a84:	e0fff817 	ldw	r3,-32(fp)
   44a88:	10c04a15 	stw	r3,296(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44a8c:	008001b4 	movhi	r2,6
   44a90:	10a5b904 	addi	r2,r2,-26908
   44a94:	10800117 	ldw	r2,4(r2)
   44a98:	10bfffcc 	andi	r2,r2,65535
   44a9c:	e1bff817 	ldw	r6,-32(fp)
   44aa0:	100b883a 	mov	r5,r2
   44aa4:	d1201604 	addi	r4,gp,-32680
   44aa8:	0042fa00 	call	42fa0 <set_laser_paramter>
                	}
                    break;
   44aac:	0000db06 	br	44e1c <pc2dev_parse+0x16b0>
                case ALARM_OUTPUT_THRESHOLD:
                    if((para >= 1) && (para <= 500))
   44ab0:	e0bff817 	ldw	r2,-32(fp)
   44ab4:	1000db26 	beq	r2,zero,44e24 <pc2dev_parse+0x16b8>
   44ab8:	e0bff817 	ldw	r2,-32(fp)
   44abc:	10807d68 	cmpgeui	r2,r2,501
   44ac0:	1000d81e 	bne	r2,zero,44e24 <pc2dev_parse+0x16b8>
                    {
                    SysPara.alarm_output_threshold = para;
   44ac4:	008001b4 	movhi	r2,6
   44ac8:	10a56c04 	addi	r2,r2,-27216
   44acc:	e0fff817 	ldw	r3,-32(fp)
   44ad0:	10c04b15 	stw	r3,300(r2)
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
   44ad4:	008001b4 	movhi	r2,6
   44ad8:	10a5b904 	addi	r2,r2,-26908
   44adc:	10800117 	ldw	r2,4(r2)
   44ae0:	10bfffcc 	andi	r2,r2,65535
   44ae4:	e1bff817 	ldw	r6,-32(fp)
   44ae8:	100b883a 	mov	r5,r2
   44aec:	d1201604 	addi	r4,gp,-32680
   44af0:	0042fa00 	call	42fa0 <set_laser_paramter>
                    }
                    break;
   44af4:	0000cb06 	br	44e24 <pc2dev_parse+0x16b8>
                case PC_REMOTE_UPDATE_WRITE:
                    image.addr = (buf[8] << 24) + (buf[9] << 16) + (buf[10] << 8) + (buf[11]);
   44af8:	e0bffd17 	ldw	r2,-12(fp)
   44afc:	10800204 	addi	r2,r2,8
   44b00:	10800003 	ldbu	r2,0(r2)
   44b04:	10803fcc 	andi	r2,r2,255
   44b08:	1006963a 	slli	r3,r2,24
   44b0c:	e0bffd17 	ldw	r2,-12(fp)
   44b10:	10800244 	addi	r2,r2,9
   44b14:	10800003 	ldbu	r2,0(r2)
   44b18:	10803fcc 	andi	r2,r2,255
   44b1c:	1004943a 	slli	r2,r2,16
   44b20:	1887883a 	add	r3,r3,r2
   44b24:	e0bffd17 	ldw	r2,-12(fp)
   44b28:	10800284 	addi	r2,r2,10
   44b2c:	10800003 	ldbu	r2,0(r2)
   44b30:	10803fcc 	andi	r2,r2,255
   44b34:	1004923a 	slli	r2,r2,8
   44b38:	1887883a 	add	r3,r3,r2
   44b3c:	e0bffd17 	ldw	r2,-12(fp)
   44b40:	108002c4 	addi	r2,r2,11
   44b44:	10800003 	ldbu	r2,0(r2)
   44b48:	10803fcc 	andi	r2,r2,255
   44b4c:	1885883a 	add	r2,r3,r2
   44b50:	1007883a 	mov	r3,r2
   44b54:	008001b4 	movhi	r2,6
   44b58:	10905004 	addi	r2,r2,16704
   44b5c:	10c00015 	stw	r3,0(r2)
                    memcpy(image.data, &buf[12], 256);
   44b60:	e0bffd17 	ldw	r2,-12(fp)
   44b64:	10c00304 	addi	r3,r2,12
   44b68:	008001b4 	movhi	r2,6
   44b6c:	10905004 	addi	r2,r2,16704
   44b70:	10800104 	addi	r2,r2,4
   44b74:	1809883a 	mov	r4,r3
   44b78:	00c04004 	movi	r3,256
   44b7c:	180d883a 	mov	r6,r3
   44b80:	200b883a 	mov	r5,r4
   44b84:	1009883a 	mov	r4,r2
   44b88:	00493d40 	call	493d4 <memcpy>
                    image_write(image.addr, image.data);
   44b8c:	008001b4 	movhi	r2,6
   44b90:	10905004 	addi	r2,r2,16704
   44b94:	10800017 	ldw	r2,0(r2)
   44b98:	014001b4 	movhi	r5,6
   44b9c:	29505104 	addi	r5,r5,16708
   44ba0:	1009883a 	mov	r4,r2
   44ba4:	0045d7c0 	call	45d7c <image_write>

                    image_read(image.addr, image.data);
   44ba8:	008001b4 	movhi	r2,6
   44bac:	10905004 	addi	r2,r2,16704
   44bb0:	10800017 	ldw	r2,0(r2)
   44bb4:	014001b4 	movhi	r5,6
   44bb8:	29505104 	addi	r5,r5,16708
   44bbc:	1009883a 	mov	r4,r2
   44bc0:	0045e740 	call	45e74 <image_read>
                    nios2pc.command  = NIOS_REMOTE_WRITE_REPONSE;
   44bc4:	008001b4 	movhi	r2,6
   44bc8:	10a5bd04 	addi	r2,r2,-26892
   44bcc:	00d44004 	movi	r3,20736
   44bd0:	10c00115 	stw	r3,4(r2)
                    nios2pc.data_len = 4 + 256;
   44bd4:	008001b4 	movhi	r2,6
   44bd8:	10a5bd04 	addi	r2,r2,-26892
   44bdc:	00c04104 	movi	r3,260
   44be0:	10c00215 	stw	r3,8(r2)
                    send_len         = pc2dev_packet(&nios2pc, send_buffer);
   44be4:	014001b4 	movhi	r5,6
   44be8:	29481004 	addi	r5,r5,8256
   44bec:	010001b4 	movhi	r4,6
   44bf0:	2125bd04 	addi	r4,r4,-26892
   44bf4:	0044e840 	call	44e84 <pc2dev_packet>
   44bf8:	e0bff915 	stw	r2,-28(fp)
                    send(s, send_buffer, send_len);
   44bfc:	e0fffc03 	ldbu	r3,-16(fp)
   44c00:	e0bff917 	ldw	r2,-28(fp)
   44c04:	10bfffcc 	andi	r2,r2,65535
   44c08:	100d883a 	mov	r6,r2
   44c0c:	014001b4 	movhi	r5,6
   44c10:	29481004 	addi	r5,r5,8256
   44c14:	1809883a 	mov	r4,r3
   44c18:	004709c0 	call	4709c <send>
                    break;
   44c1c:	00008206 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_REMOTE_UPDATE_READ:
                    image.addr = (buf[8] << 24) + (buf[9] << 16) + (buf[10] << 8) + (buf[11]);
   44c20:	e0bffd17 	ldw	r2,-12(fp)
   44c24:	10800204 	addi	r2,r2,8
   44c28:	10800003 	ldbu	r2,0(r2)
   44c2c:	10803fcc 	andi	r2,r2,255
   44c30:	1006963a 	slli	r3,r2,24
   44c34:	e0bffd17 	ldw	r2,-12(fp)
   44c38:	10800244 	addi	r2,r2,9
   44c3c:	10800003 	ldbu	r2,0(r2)
   44c40:	10803fcc 	andi	r2,r2,255
   44c44:	1004943a 	slli	r2,r2,16
   44c48:	1887883a 	add	r3,r3,r2
   44c4c:	e0bffd17 	ldw	r2,-12(fp)
   44c50:	10800284 	addi	r2,r2,10
   44c54:	10800003 	ldbu	r2,0(r2)
   44c58:	10803fcc 	andi	r2,r2,255
   44c5c:	1004923a 	slli	r2,r2,8
   44c60:	1887883a 	add	r3,r3,r2
   44c64:	e0bffd17 	ldw	r2,-12(fp)
   44c68:	108002c4 	addi	r2,r2,11
   44c6c:	10800003 	ldbu	r2,0(r2)
   44c70:	10803fcc 	andi	r2,r2,255
   44c74:	1885883a 	add	r2,r3,r2
   44c78:	1007883a 	mov	r3,r2
   44c7c:	008001b4 	movhi	r2,6
   44c80:	10905004 	addi	r2,r2,16704
   44c84:	10c00015 	stw	r3,0(r2)
                    image_read(image.addr, image.data);
   44c88:	008001b4 	movhi	r2,6
   44c8c:	10905004 	addi	r2,r2,16704
   44c90:	10800017 	ldw	r2,0(r2)
   44c94:	014001b4 	movhi	r5,6
   44c98:	29505104 	addi	r5,r5,16708
   44c9c:	1009883a 	mov	r4,r2
   44ca0:	0045e740 	call	45e74 <image_read>

                    nios2pc.command  = NIOS_UP_REMOTE_UPDATE_IMAGE;
   44ca4:	008001b4 	movhi	r2,6
   44ca8:	10a5bd04 	addi	r2,r2,-26892
   44cac:	00d44044 	movi	r3,20737
   44cb0:	10c00115 	stw	r3,4(r2)
                    nios2pc.data_len = 4 + 256;
   44cb4:	008001b4 	movhi	r2,6
   44cb8:	10a5bd04 	addi	r2,r2,-26892
   44cbc:	00c04104 	movi	r3,260
   44cc0:	10c00215 	stw	r3,8(r2)
                    send_len         = pc2dev_packet(&nios2pc, send_buffer);
   44cc4:	014001b4 	movhi	r5,6
   44cc8:	29481004 	addi	r5,r5,8256
   44ccc:	010001b4 	movhi	r4,6
   44cd0:	2125bd04 	addi	r4,r4,-26892
   44cd4:	0044e840 	call	44e84 <pc2dev_packet>
   44cd8:	e0bff915 	stw	r2,-28(fp)
                    send(s, send_buffer, send_len);
   44cdc:	e0fffc03 	ldbu	r3,-16(fp)
   44ce0:	e0bff917 	ldw	r2,-28(fp)
   44ce4:	10bfffcc 	andi	r2,r2,65535
   44ce8:	100d883a 	mov	r6,r2
   44cec:	014001b4 	movhi	r5,6
   44cf0:	29481004 	addi	r5,r5,8256
   44cf4:	1809883a 	mov	r4,r3
   44cf8:	004709c0 	call	4709c <send>
                    break;
   44cfc:	00004a06 	br	44e28 <pc2dev_parse+0x16bc>
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
   44d00:	e03ff715 	stw	zero,-36(fp)
   44d04:	00000506 	br	44d1c <pc2dev_parse+0x15b0>
                        image_erase(i);
   44d08:	e13ff717 	ldw	r4,-36(fp)
   44d0c:	0045f0c0 	call	45f0c <image_erase>
                    nios2pc.data_len = 4 + 256;
                    send_len         = pc2dev_packet(&nios2pc, send_buffer);
                    send(s, send_buffer, send_len);
                    break;
                case PC_REMOTE_UPDATE_ERASE:
                    for(i = 0; i < para; i++)
   44d10:	e0bff717 	ldw	r2,-36(fp)
   44d14:	10800044 	addi	r2,r2,1
   44d18:	e0bff715 	stw	r2,-36(fp)
   44d1c:	e0fff717 	ldw	r3,-36(fp)
   44d20:	e0bff817 	ldw	r2,-32(fp)
   44d24:	18bff836 	bltu	r3,r2,44d08 <__alt_mem_epcs_flash+0xfffc3d08>
                        image_erase(i);
                    break;
   44d28:	00003f06 	br	44e28 <pc2dev_parse+0x16bc>
                        nios2pc.command  = NIOS_UP_ALARM_REGION;
                        nios2pc.data_len = 4;
                        send_len         = pc2dev_packet(&nios2pc, send_buffer);
                        send(s, send_buffer, send_len);
                    }
                    break;
   44d2c:	0001883a 	nop
   44d30:	00003d06 	br	44e28 <pc2dev_parse+0x16bc>
                    else
                        region_save2eeprom(&alarm_region);
                    // 如果当前开关输入量的值和修改区域的值一样，才去修改FPGA内报警区域值
                    if(alarm_region.change_region_value == alarm_region.wr_which / 3)
                        alarm_region.change_region_flag = 0x01;
                    break;
   44d34:	0001883a 	nop
   44d38:	00003b06 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para == ENABLE) || (para == DISABLE))
                    {
                        SysPara.laser_enable = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d3c:	0001883a 	nop
   44d40:	00003906 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 3) && (para <= 10))
                    {
                        SysPara.laser_pulse_width = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d44:	0001883a 	nop
   44d48:	00003706 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 16)
                    {
                        SysPara.laser_recv_delay = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d4c:	0001883a 	nop
   44d50:	00003506 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para == ENABLE) || (para == DISABLE))
                    {
                        SysPara.motor_enable = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d54:	0001883a 	nop
   44d58:	00003306 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 8) && (para <= 15))
                    {
                        SysPara.motor_expect_speed = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d5c:	0001883a 	nop
   44d60:	00003106 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1024)
                    {
                        SysPara.zero_distance_revise = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d64:	0001883a 	nop
   44d68:	00002f06 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 2) && (para <= 240))
                    {
                        SysPara.zero_angle_revise = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d6c:	0001883a 	nop
   44d70:	00002d06 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1024)
                    {
                        SysPara.signal_thresold = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d74:	0001883a 	nop
   44d78:	00002b06 	br	44e28 <pc2dev_parse+0x16bc>
                            SysPara.signal_thresold = para;
                        else
                            SysPara.apd_vol_base = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d7c:	0001883a 	nop
   44d80:	00002906 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 20) && (para <= 45))
                    {
                        SysPara.temp_volt_cof1 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d84:	0001883a 	nop
   44d88:	00002706 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 20) && (para <= 45))
                    {
                        SysPara.temp_volt_cof2 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d8c:	0001883a 	nop
   44d90:	00002506 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 50)
                    {
                        SysPara.temp_volt_inflection = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d94:	0001883a 	nop
   44d98:	00002306 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 128)
                    {
                        SysPara.temp_distance_cof1 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44d9c:	0001883a 	nop
   44da0:	00002106 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 128)
                    {
                        SysPara.temp_distance_cof2 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44da4:	0001883a 	nop
   44da8:	00001f06 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 60)
                    {
                        SysPara.temp_distance_inflection = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dac:	0001883a 	nop
   44db0:	00001d06 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para > 1) && (para < 40))
                    {
                        SysPara.valid_num_threshold = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44db4:	0001883a 	nop
   44db8:	00001b06 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 500)
                    {
                        SysPara.min_display_distance = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dbc:	0001883a 	nop
   44dc0:	00001906 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 2) && (para <= 12))
                    {
                        SysPara.first_noise_filter = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dc4:	0001883a 	nop
   44dc8:	00001706 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 100)
                    {
                        SysPara.dust_alarm_threshold = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dcc:	0001883a 	nop
   44dd0:	00001506 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para1 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dd4:	0001883a 	nop
   44dd8:	00001306 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para2 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44ddc:	0001883a 	nop
   44de0:	00001106 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para3 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44de4:	0001883a 	nop
   44de8:	00000f06 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para4 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dec:	0001883a 	nop
   44df0:	00000d06 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para5 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44df4:	0001883a 	nop
   44df8:	00000b06 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para6 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44dfc:	0001883a 	nop
   44e00:	00000906 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para7 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44e04:	0001883a 	nop
   44e08:	00000706 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para8 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44e0c:	0001883a 	nop
   44e10:	00000506 	br	44e28 <pc2dev_parse+0x16bc>
                    if(para <= 1023)
                    {
                        SysPara.da_cycle_para9 = para;
                        set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44e14:	0001883a 	nop
   44e18:	00000306 	br	44e28 <pc2dev_parse+0x16bc>
                	if((para >= 0) && (para <= 8000))
                	{
                    SysPara.min_target_size = para;
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                	}
                    break;
   44e1c:	0001883a 	nop
   44e20:	00000106 	br	44e28 <pc2dev_parse+0x16bc>
                    if((para >= 1) && (para <= 500))
                    {
                    SysPara.alarm_output_threshold = para;
                    set_laser_paramter(&Nios2FPGA_pck, pc2nios.command, para);
                    }
                    break;
   44e24:	0001883a 	nop
                        image_erase(i);
                    break;
                default:
                    break;
            }
            packet_len = pc2nios.data_len + 12;
   44e28:	008001b4 	movhi	r2,6
   44e2c:	10a5b904 	addi	r2,r2,-26908
   44e30:	10800217 	ldw	r2,8(r2)
   44e34:	10800304 	addi	r2,r2,12
   44e38:	e0bffb15 	stw	r2,-20(fp)
            len        = len - packet_len;
   44e3c:	e0fffe17 	ldw	r3,-8(fp)
   44e40:	e0bffb17 	ldw	r2,-20(fp)
   44e44:	1885c83a 	sub	r2,r3,r2
   44e48:	e0bffe15 	stw	r2,-8(fp)
            buf        = buf + packet_len;
   44e4c:	e0bffb17 	ldw	r2,-20(fp)
   44e50:	e0fffd17 	ldw	r3,-12(fp)
   44e54:	1885883a 	add	r2,r3,r2
   44e58:	e0bffd15 	stw	r2,-12(fp)
    int            send_len;
    unsigned short recv_pos;
    unsigned int   para;        // PC 传给 nios 的参数值
    int            packet_len;  // buf里可能有多包数据，本包数据长度

    while(len != 0)
   44e5c:	e0bffe17 	ldw	r2,-8(fp)
   44e60:	103a4c1e 	bne	r2,zero,43794 <__alt_mem_epcs_flash+0xfffc2794>
   44e64:	00000106 	br	44e6c <pc2dev_parse+0x1700>
                    {
                        eeprom_write_byte(CUR_ALARM_GROUP + 2, buf[10]);
                        eeprom_write_byte(CUR_ALARM_GROUP + 3, buf[11]);
                    }
                    else
                        return;
   44e68:	0001883a 	nop
            // nios2pc.data_len = 4;
            // send_len = pc2dev_packet(&nios2pc, send_buffer);
            // send(s, send_buffer, send_len);
        }
    }
}
   44e6c:	e6ffff04 	addi	sp,fp,-4
   44e70:	dfc00217 	ldw	ra,8(sp)
   44e74:	df000117 	ldw	fp,4(sp)
   44e78:	dc000017 	ldw	r16,0(sp)
   44e7c:	dec00304 	addi	sp,sp,12
   44e80:	f800283a 	ret

00044e84 <pc2dev_packet>:
 * @param data
 * @param buf
 * @return int 打包后要发送给上位机的字节数
 */
int pc2dev_packet(struct __nios2pc *data, unsigned char *buf)
{
   44e84:	defff604 	addi	sp,sp,-40
   44e88:	dfc00915 	stw	ra,36(sp)
   44e8c:	df000815 	stw	fp,32(sp)
   44e90:	dc000715 	stw	r16,28(sp)
   44e94:	df000804 	addi	fp,sp,32
   44e98:	e13ffd15 	stw	r4,-12(fp)
   44e9c:	e17ffe15 	stw	r5,-8(fp)
    int           i;
    int           offset_addr;
    int           buf_len;
    unsigned char checksum;
    unsigned char temp;
    buf[0] = (data->head >> 8) & 0xff;
   44ea0:	e0bffd17 	ldw	r2,-12(fp)
   44ea4:	10800017 	ldw	r2,0(r2)
   44ea8:	1004d23a 	srli	r2,r2,8
   44eac:	1007883a 	mov	r3,r2
   44eb0:	e0bffe17 	ldw	r2,-8(fp)
   44eb4:	10c00005 	stb	r3,0(r2)
    buf[1] = (data->head >> 0) & 0xff;
   44eb8:	e0bffe17 	ldw	r2,-8(fp)
   44ebc:	10800044 	addi	r2,r2,1
   44ec0:	e0fffd17 	ldw	r3,-12(fp)
   44ec4:	18c00017 	ldw	r3,0(r3)
   44ec8:	10c00005 	stb	r3,0(r2)
    buf[2] = (data->command >> 8) & 0xff;
   44ecc:	e0bffe17 	ldw	r2,-8(fp)
   44ed0:	10800084 	addi	r2,r2,2
   44ed4:	e0fffd17 	ldw	r3,-12(fp)
   44ed8:	18c00117 	ldw	r3,4(r3)
   44edc:	1806d23a 	srli	r3,r3,8
   44ee0:	10c00005 	stb	r3,0(r2)
    buf[3] = (data->command >> 0) & 0xff;
   44ee4:	e0bffe17 	ldw	r2,-8(fp)
   44ee8:	108000c4 	addi	r2,r2,3
   44eec:	e0fffd17 	ldw	r3,-12(fp)
   44ef0:	18c00117 	ldw	r3,4(r3)
   44ef4:	10c00005 	stb	r3,0(r2)

    buf[4] = (data->data_len >> 24) & 0xff;  // 数据长度
   44ef8:	e0bffe17 	ldw	r2,-8(fp)
   44efc:	10800104 	addi	r2,r2,4
   44f00:	e0fffd17 	ldw	r3,-12(fp)
   44f04:	18c00217 	ldw	r3,8(r3)
   44f08:	1806d63a 	srli	r3,r3,24
   44f0c:	10c00005 	stb	r3,0(r2)
    buf[5] = (data->data_len >> 16) & 0xff;
   44f10:	e0bffe17 	ldw	r2,-8(fp)
   44f14:	10800144 	addi	r2,r2,5
   44f18:	e0fffd17 	ldw	r3,-12(fp)
   44f1c:	18c00217 	ldw	r3,8(r3)
   44f20:	1806d43a 	srli	r3,r3,16
   44f24:	10c00005 	stb	r3,0(r2)
    buf[6] = (data->data_len >> 8) & 0xff;
   44f28:	e0bffe17 	ldw	r2,-8(fp)
   44f2c:	10800184 	addi	r2,r2,6
   44f30:	e0fffd17 	ldw	r3,-12(fp)
   44f34:	18c00217 	ldw	r3,8(r3)
   44f38:	1806d23a 	srli	r3,r3,8
   44f3c:	10c00005 	stb	r3,0(r2)
    buf[7] = (data->data_len >> 0) & 0xff;
   44f40:	e0bffe17 	ldw	r2,-8(fp)
   44f44:	108001c4 	addi	r2,r2,7
   44f48:	e0fffd17 	ldw	r3,-12(fp)
   44f4c:	18c00217 	ldw	r3,8(r3)
   44f50:	10c00005 	stb	r3,0(r2)

    switch(data->command)
   44f54:	e0bffd17 	ldw	r2,-12(fp)
   44f58:	10800117 	ldw	r2,4(r2)
   44f5c:	10d400a0 	cmpeqi	r3,r2,20482
   44f60:	1800621e 	bne	r3,zero,450ec <pc2dev_packet+0x268>
   44f64:	10d400e8 	cmpgeui	r3,r2,20483
   44f68:	1800051e 	bne	r3,zero,44f80 <pc2dev_packet+0xfc>
   44f6c:	10d40020 	cmpeqi	r3,r2,20480
   44f70:	1800bd1e 	bne	r3,zero,45268 <pc2dev_packet+0x3e4>
   44f74:	10940060 	cmpeqi	r2,r2,20481
   44f78:	1000091e 	bne	r2,zero,44fa0 <pc2dev_packet+0x11c>
   44f7c:	00016306 	br	4550c <pc2dev_packet+0x688>
   44f80:	10d40160 	cmpeqi	r3,r2,20485
   44f84:	1800f21e 	bne	r3,zero,45350 <pc2dev_packet+0x4cc>
   44f88:	10d40170 	cmpltui	r3,r2,20485
   44f8c:	18015f1e 	bne	r3,zero,4550c <pc2dev_packet+0x688>
   44f90:	10abc004 	addi	r2,r2,-20736
   44f94:	108000a8 	cmpgeui	r2,r2,2
   44f98:	10015c1e 	bne	r2,zero,4550c <pc2dev_packet+0x688>
   44f9c:	00011506 	br	453f4 <pc2dev_packet+0x570>
    {
        case NIOS_UP_ALARM_REGION:
            offset_addr = CUR_ALARM_GROUP;
   44fa0:	e03ffb15 	stw	zero,-20(fp)
            for(i = 0; i < data->data_len; i++)
   44fa4:	e03ff815 	stw	zero,-32(fp)
   44fa8:	00000d06 	br	44fe0 <pc2dev_packet+0x15c>
            {
                buf[i + 8] = eeprom_read_byte(offset_addr + i);
   44fac:	e0bff817 	ldw	r2,-32(fp)
   44fb0:	10800204 	addi	r2,r2,8
   44fb4:	e0fffe17 	ldw	r3,-8(fp)
   44fb8:	18a1883a 	add	r16,r3,r2
   44fbc:	e0fffb17 	ldw	r3,-20(fp)
   44fc0:	e0bff817 	ldw	r2,-32(fp)
   44fc4:	1885883a 	add	r2,r3,r2
   44fc8:	1009883a 	mov	r4,r2
   44fcc:	00421d40 	call	421d4 <eeprom_read_byte>
   44fd0:	80800005 	stb	r2,0(r16)

    switch(data->command)
    {
        case NIOS_UP_ALARM_REGION:
            offset_addr = CUR_ALARM_GROUP;
            for(i = 0; i < data->data_len; i++)
   44fd4:	e0bff817 	ldw	r2,-32(fp)
   44fd8:	10800044 	addi	r2,r2,1
   44fdc:	e0bff815 	stw	r2,-32(fp)
   44fe0:	e0bffd17 	ldw	r2,-12(fp)
   44fe4:	10800217 	ldw	r2,8(r2)
   44fe8:	e0fff817 	ldw	r3,-32(fp)
   44fec:	18bfef36 	bltu	r3,r2,44fac <__alt_mem_epcs_flash+0xfffc3fac>
            {
                buf[i + 8] = eeprom_read_byte(offset_addr + i);
            }
            buf[8]   = 0x00;
   44ff0:	e0bffe17 	ldw	r2,-8(fp)
   44ff4:	10800204 	addi	r2,r2,8
   44ff8:	10000005 	stb	zero,0(r2)
            buf[9]   = 0x00;
   44ffc:	e0bffe17 	ldw	r2,-8(fp)
   45000:	10800244 	addi	r2,r2,9
   45004:	10000005 	stb	zero,0(r2)
            buf[10]  = 0x00;
   45008:	e0bffe17 	ldw	r2,-8(fp)
   4500c:	10800284 	addi	r2,r2,10
   45010:	10000005 	stb	zero,0(r2)
            buf[11]  = alarm_region.change_region_value;
   45014:	e0bffe17 	ldw	r2,-8(fp)
   45018:	10c002c4 	addi	r3,r2,11
   4501c:	008001b4 	movhi	r2,6
   45020:	10a5c204 	addi	r2,r2,-26872
   45024:	108000c3 	ldbu	r2,3(r2)
   45028:	18800005 	stb	r2,0(r3)
            checksum = 0;
   4502c:	e03ffa05 	stb	zero,-24(fp)
            for(i = 0; i < 8 + data->data_len; i++)
   45030:	e03ff815 	stw	zero,-32(fp)
   45034:	00000a06 	br	45060 <pc2dev_packet+0x1dc>
            {
                checksum ^= buf[i];
   45038:	e0bff817 	ldw	r2,-32(fp)
   4503c:	e0fffe17 	ldw	r3,-8(fp)
   45040:	1885883a 	add	r2,r3,r2
   45044:	10c00003 	ldbu	r3,0(r2)
   45048:	e0bffa03 	ldbu	r2,-24(fp)
   4504c:	1884f03a 	xor	r2,r3,r2
   45050:	e0bffa05 	stb	r2,-24(fp)
            buf[8]   = 0x00;
            buf[9]   = 0x00;
            buf[10]  = 0x00;
            buf[11]  = alarm_region.change_region_value;
            checksum = 0;
            for(i = 0; i < 8 + data->data_len; i++)
   45054:	e0bff817 	ldw	r2,-32(fp)
   45058:	10800044 	addi	r2,r2,1
   4505c:	e0bff815 	stw	r2,-32(fp)
   45060:	e0bffd17 	ldw	r2,-12(fp)
   45064:	10800217 	ldw	r2,8(r2)
   45068:	10800204 	addi	r2,r2,8
   4506c:	e0fff817 	ldw	r3,-32(fp)
   45070:	18bff136 	bltu	r3,r2,45038 <__alt_mem_epcs_flash+0xfffc4038>
            {
                checksum ^= buf[i];
            }
            buf[8 + data->data_len + 0] = 0x00;
   45074:	e0bffd17 	ldw	r2,-12(fp)
   45078:	10800217 	ldw	r2,8(r2)
   4507c:	10800204 	addi	r2,r2,8
   45080:	e0fffe17 	ldw	r3,-8(fp)
   45084:	1885883a 	add	r2,r3,r2
   45088:	10000005 	stb	zero,0(r2)
            buf[8 + data->data_len + 1] = 0x00;
   4508c:	e0bffd17 	ldw	r2,-12(fp)
   45090:	10800217 	ldw	r2,8(r2)
   45094:	10800244 	addi	r2,r2,9
   45098:	e0fffe17 	ldw	r3,-8(fp)
   4509c:	1885883a 	add	r2,r3,r2
   450a0:	10000005 	stb	zero,0(r2)
            buf[8 + data->data_len + 2] = 0x00;
   450a4:	e0bffd17 	ldw	r2,-12(fp)
   450a8:	10800217 	ldw	r2,8(r2)
   450ac:	10800284 	addi	r2,r2,10
   450b0:	e0fffe17 	ldw	r3,-8(fp)
   450b4:	1885883a 	add	r2,r3,r2
   450b8:	10000005 	stb	zero,0(r2)
            buf[8 + data->data_len + 3] = checksum;
   450bc:	e0bffd17 	ldw	r2,-12(fp)
   450c0:	10800217 	ldw	r2,8(r2)
   450c4:	108002c4 	addi	r2,r2,11
   450c8:	e0fffe17 	ldw	r3,-8(fp)
   450cc:	1885883a 	add	r2,r3,r2
   450d0:	e0fffa03 	ldbu	r3,-24(fp)
   450d4:	10c00005 	stb	r3,0(r2)

            buf_len = (8 + data->data_len + 4);
   450d8:	e0bffd17 	ldw	r2,-12(fp)
   450dc:	10800217 	ldw	r2,8(r2)
   450e0:	10800304 	addi	r2,r2,12
   450e4:	e0bff915 	stw	r2,-28(fp)
            break;
   450e8:	00013e06 	br	455e4 <pc2dev_packet+0x760>
        case NIOS_UP_REGION_DATA:
            // 8 + TARGET_NUMBER*2 + 1 + 102
            offset_addr = GROUP_OFFSET_ADDR + alarm_region.rd_which * REGION_SPACE_SIZE;
   450ec:	008001b4 	movhi	r2,6
   450f0:	10a5c204 	addi	r2,r2,-26872
   450f4:	10800143 	ldbu	r2,5(r2)
   450f8:	10803fcc 	andi	r2,r2,255
   450fc:	10800084 	addi	r2,r2,2
   45100:	100492fa 	slli	r2,r2,11
   45104:	e0bffb15 	stw	r2,-20(fp)
            buf[8]      = alarm_region.rd_which;
   45108:	e0bffe17 	ldw	r2,-8(fp)
   4510c:	10c00204 	addi	r3,r2,8
   45110:	008001b4 	movhi	r2,6
   45114:	10a5c204 	addi	r2,r2,-26872
   45118:	10800143 	ldbu	r2,5(r2)
   4511c:	18800005 	stb	r2,0(r3)
            buf_len     = 9;
   45120:	00800244 	movi	r2,9
   45124:	e0bff915 	stw	r2,-28(fp)
            eeprom_sequential_read(offset_addr, buf + 9, TARGET_NUMBER * 2 + 1 + 102);
   45128:	e0fffb17 	ldw	r3,-20(fp)
   4512c:	e0bffe17 	ldw	r2,-8(fp)
   45130:	10800244 	addi	r2,r2,9
   45134:	0181af44 	movi	r6,1725
   45138:	100b883a 	mov	r5,r2
   4513c:	1809883a 	mov	r4,r3
   45140:	00422a40 	call	422a4 <eeprom_sequential_read>
            for(i = 9; i < 9 + TARGET_NUMBER * 2; i += 2)
   45144:	00800244 	movi	r2,9
   45148:	e0bff815 	stw	r2,-32(fp)
   4514c:	00001706 	br	451ac <pc2dev_packet+0x328>
            {
                temp       = buf[i + 1];
   45150:	e0bff817 	ldw	r2,-32(fp)
   45154:	10800044 	addi	r2,r2,1
   45158:	e0fffe17 	ldw	r3,-8(fp)
   4515c:	1885883a 	add	r2,r3,r2
   45160:	10800003 	ldbu	r2,0(r2)
   45164:	e0bffc05 	stb	r2,-16(fp)
                buf[i + 1] = buf[i];
   45168:	e0bff817 	ldw	r2,-32(fp)
   4516c:	10800044 	addi	r2,r2,1
   45170:	e0fffe17 	ldw	r3,-8(fp)
   45174:	1885883a 	add	r2,r3,r2
   45178:	e0fff817 	ldw	r3,-32(fp)
   4517c:	e13ffe17 	ldw	r4,-8(fp)
   45180:	20c7883a 	add	r3,r4,r3
   45184:	18c00003 	ldbu	r3,0(r3)
   45188:	10c00005 	stb	r3,0(r2)
                buf[i]     = temp;
   4518c:	e0bff817 	ldw	r2,-32(fp)
   45190:	e0fffe17 	ldw	r3,-8(fp)
   45194:	1885883a 	add	r2,r3,r2
   45198:	e0fffc03 	ldbu	r3,-16(fp)
   4519c:	10c00005 	stb	r3,0(r2)
            // 8 + TARGET_NUMBER*2 + 1 + 102
            offset_addr = GROUP_OFFSET_ADDR + alarm_region.rd_which * REGION_SPACE_SIZE;
            buf[8]      = alarm_region.rd_which;
            buf_len     = 9;
            eeprom_sequential_read(offset_addr, buf + 9, TARGET_NUMBER * 2 + 1 + 102);
            for(i = 9; i < 9 + TARGET_NUMBER * 2; i += 2)
   451a0:	e0bff817 	ldw	r2,-32(fp)
   451a4:	10800084 	addi	r2,r2,2
   451a8:	e0bff815 	stw	r2,-32(fp)
   451ac:	e0bff817 	ldw	r2,-32(fp)
   451b0:	108197d0 	cmplti	r2,r2,1631
   451b4:	103fe61e 	bne	r2,zero,45150 <__alt_mem_epcs_flash+0xfffc4150>
                temp       = buf[i + 1];
                buf[i + 1] = buf[i];
                buf[i]     = temp;
            }

            buf_len += TARGET_NUMBER * 2 + 1 + 102;
   451b8:	e0bff917 	ldw	r2,-28(fp)
   451bc:	1081af44 	addi	r2,r2,1725
   451c0:	e0bff915 	stw	r2,-28(fp)

            checksum = 0;
   451c4:	e03ffa05 	stb	zero,-24(fp)
            for(i = 0; i < buf_len; i++)
   451c8:	e03ff815 	stw	zero,-32(fp)
   451cc:	00000a06 	br	451f8 <pc2dev_packet+0x374>
            {
                checksum ^= buf[i];
   451d0:	e0bff817 	ldw	r2,-32(fp)
   451d4:	e0fffe17 	ldw	r3,-8(fp)
   451d8:	1885883a 	add	r2,r3,r2
   451dc:	10c00003 	ldbu	r3,0(r2)
   451e0:	e0bffa03 	ldbu	r2,-24(fp)
   451e4:	1884f03a 	xor	r2,r3,r2
   451e8:	e0bffa05 	stb	r2,-24(fp)
            }

            buf_len += TARGET_NUMBER * 2 + 1 + 102;

            checksum = 0;
            for(i = 0; i < buf_len; i++)
   451ec:	e0bff817 	ldw	r2,-32(fp)
   451f0:	10800044 	addi	r2,r2,1
   451f4:	e0bff815 	stw	r2,-32(fp)
   451f8:	e0fff817 	ldw	r3,-32(fp)
   451fc:	e0bff917 	ldw	r2,-28(fp)
   45200:	18bff316 	blt	r3,r2,451d0 <__alt_mem_epcs_flash+0xfffc41d0>
            {
                checksum ^= buf[i];
            }
            buf[buf_len + 1] = 0x00;
   45204:	e0bff917 	ldw	r2,-28(fp)
   45208:	10800044 	addi	r2,r2,1
   4520c:	e0fffe17 	ldw	r3,-8(fp)
   45210:	1885883a 	add	r2,r3,r2
   45214:	10000005 	stb	zero,0(r2)
            buf[buf_len + 2] = 0x00;
   45218:	e0bff917 	ldw	r2,-28(fp)
   4521c:	10800084 	addi	r2,r2,2
   45220:	e0fffe17 	ldw	r3,-8(fp)
   45224:	1885883a 	add	r2,r3,r2
   45228:	10000005 	stb	zero,0(r2)
            buf[buf_len + 3] = 0x00;
   4522c:	e0bff917 	ldw	r2,-28(fp)
   45230:	108000c4 	addi	r2,r2,3
   45234:	e0fffe17 	ldw	r3,-8(fp)
   45238:	1885883a 	add	r2,r3,r2
   4523c:	10000005 	stb	zero,0(r2)
            buf[buf_len + 4] = checksum;
   45240:	e0bff917 	ldw	r2,-28(fp)
   45244:	10800104 	addi	r2,r2,4
   45248:	e0fffe17 	ldw	r3,-8(fp)
   4524c:	1885883a 	add	r2,r3,r2
   45250:	e0fffa03 	ldbu	r3,-24(fp)
   45254:	10c00005 	stb	r3,0(r2)
            buf_len += 4;
   45258:	e0bff917 	ldw	r2,-28(fp)
   4525c:	10800104 	addi	r2,r2,4
   45260:	e0bff915 	stw	r2,-28(fp)
            break;
   45264:	0000df06 	br	455e4 <pc2dev_packet+0x760>
        case NIOS_UP_RESPONSE_PC:
            buf[8]  = (SysPara.pc_command_value >> 24) & 0xff;
   45268:	e0bffe17 	ldw	r2,-8(fp)
   4526c:	10c00204 	addi	r3,r2,8
   45270:	008001b4 	movhi	r2,6
   45274:	10a56c04 	addi	r2,r2,-27216
   45278:	10804c17 	ldw	r2,304(r2)
   4527c:	1004d63a 	srli	r2,r2,24
   45280:	18800005 	stb	r2,0(r3)
            buf[9]  = (SysPara.pc_command_value >> 16) & 0xff;
   45284:	e0bffe17 	ldw	r2,-8(fp)
   45288:	10c00244 	addi	r3,r2,9
   4528c:	008001b4 	movhi	r2,6
   45290:	10a56c04 	addi	r2,r2,-27216
   45294:	10804c17 	ldw	r2,304(r2)
   45298:	1004d43a 	srli	r2,r2,16
   4529c:	18800005 	stb	r2,0(r3)
            buf[10] = (SysPara.pc_command_value >> 8) & 0xff;
   452a0:	e0bffe17 	ldw	r2,-8(fp)
   452a4:	10c00284 	addi	r3,r2,10
   452a8:	008001b4 	movhi	r2,6
   452ac:	10a56c04 	addi	r2,r2,-27216
   452b0:	10804c17 	ldw	r2,304(r2)
   452b4:	1004d23a 	srli	r2,r2,8
   452b8:	18800005 	stb	r2,0(r3)
            buf[11] = (SysPara.pc_command_value >> 0) & 0xff;
   452bc:	e0bffe17 	ldw	r2,-8(fp)
   452c0:	10c002c4 	addi	r3,r2,11
   452c4:	008001b4 	movhi	r2,6
   452c8:	10a56c04 	addi	r2,r2,-27216
   452cc:	10804c17 	ldw	r2,304(r2)
   452d0:	18800005 	stb	r2,0(r3)
            for(i = 0; i < 12; i++)
   452d4:	e03ff815 	stw	zero,-32(fp)
   452d8:	00000a06 	br	45304 <pc2dev_packet+0x480>
            {
                checksum ^= buf[i];
   452dc:	e0bff817 	ldw	r2,-32(fp)
   452e0:	e0fffe17 	ldw	r3,-8(fp)
   452e4:	1885883a 	add	r2,r3,r2
   452e8:	10c00003 	ldbu	r3,0(r2)
   452ec:	e0bffa03 	ldbu	r2,-24(fp)
   452f0:	1884f03a 	xor	r2,r3,r2
   452f4:	e0bffa05 	stb	r2,-24(fp)
        case NIOS_UP_RESPONSE_PC:
            buf[8]  = (SysPara.pc_command_value >> 24) & 0xff;
            buf[9]  = (SysPara.pc_command_value >> 16) & 0xff;
            buf[10] = (SysPara.pc_command_value >> 8) & 0xff;
            buf[11] = (SysPara.pc_command_value >> 0) & 0xff;
            for(i = 0; i < 12; i++)
   452f8:	e0bff817 	ldw	r2,-32(fp)
   452fc:	10800044 	addi	r2,r2,1
   45300:	e0bff815 	stw	r2,-32(fp)
   45304:	e0bff817 	ldw	r2,-32(fp)
   45308:	10800310 	cmplti	r2,r2,12
   4530c:	103ff31e 	bne	r2,zero,452dc <__alt_mem_epcs_flash+0xfffc42dc>
            {
                checksum ^= buf[i];
            }
            buf[12] = 0;
   45310:	e0bffe17 	ldw	r2,-8(fp)
   45314:	10800304 	addi	r2,r2,12
   45318:	10000005 	stb	zero,0(r2)
            buf[13] = 0;
   4531c:	e0bffe17 	ldw	r2,-8(fp)
   45320:	10800344 	addi	r2,r2,13
   45324:	10000005 	stb	zero,0(r2)
            buf[14] = 0;
   45328:	e0bffe17 	ldw	r2,-8(fp)
   4532c:	10800384 	addi	r2,r2,14
   45330:	10000005 	stb	zero,0(r2)
            buf[15] = checksum;
   45334:	e0bffe17 	ldw	r2,-8(fp)
   45338:	108003c4 	addi	r2,r2,15
   4533c:	e0fffa03 	ldbu	r3,-24(fp)
   45340:	10c00005 	stb	r3,0(r2)
            buf_len = 16;
   45344:	00800404 	movi	r2,16
   45348:	e0bff915 	stw	r2,-28(fp)
            break;
   4534c:	0000a506 	br	455e4 <pc2dev_packet+0x760>
        case NIOS_UP_RADAR_PARA:
            memcpy(&buf[8], (unsigned char *)&SysPara, sizeof(SysPara));
   45350:	e0bffe17 	ldw	r2,-8(fp)
   45354:	10800204 	addi	r2,r2,8
   45358:	01804d04 	movi	r6,308
   4535c:	014001b4 	movhi	r5,6
   45360:	29656c04 	addi	r5,r5,-27216
   45364:	1009883a 	mov	r4,r2
   45368:	00493d40 	call	493d4 <memcpy>
            for(i = 0; i < 8 + sizeof(SysPara); i++)
   4536c:	e03ff815 	stw	zero,-32(fp)
   45370:	00000a06 	br	4539c <pc2dev_packet+0x518>
            {
                checksum ^= buf[i];
   45374:	e0bff817 	ldw	r2,-32(fp)
   45378:	e0fffe17 	ldw	r3,-8(fp)
   4537c:	1885883a 	add	r2,r3,r2
   45380:	10c00003 	ldbu	r3,0(r2)
   45384:	e0bffa03 	ldbu	r2,-24(fp)
   45388:	1884f03a 	xor	r2,r3,r2
   4538c:	e0bffa05 	stb	r2,-24(fp)
            buf[15] = checksum;
            buf_len = 16;
            break;
        case NIOS_UP_RADAR_PARA:
            memcpy(&buf[8], (unsigned char *)&SysPara, sizeof(SysPara));
            for(i = 0; i < 8 + sizeof(SysPara); i++)
   45390:	e0bff817 	ldw	r2,-32(fp)
   45394:	10800044 	addi	r2,r2,1
   45398:	e0bff815 	stw	r2,-32(fp)
   4539c:	e0bff817 	ldw	r2,-32(fp)
   453a0:	10804f30 	cmpltui	r2,r2,316
   453a4:	103ff31e 	bne	r2,zero,45374 <__alt_mem_epcs_flash+0xfffc4374>
            {
                checksum ^= buf[i];
            }
            buf[8 + sizeof(SysPara) + 0] = 0xaa;
   453a8:	e0bffe17 	ldw	r2,-8(fp)
   453ac:	10804f04 	addi	r2,r2,316
   453b0:	00ffea84 	movi	r3,-86
   453b4:	10c00005 	stb	r3,0(r2)
            buf[8 + sizeof(SysPara) + 1] = 0xbb;
   453b8:	e0bffe17 	ldw	r2,-8(fp)
   453bc:	10804f44 	addi	r2,r2,317
   453c0:	00ffeec4 	movi	r3,-69
   453c4:	10c00005 	stb	r3,0(r2)
            buf[8 + sizeof(SysPara) + 2] = 0xcc;
   453c8:	e0bffe17 	ldw	r2,-8(fp)
   453cc:	10804f84 	addi	r2,r2,318
   453d0:	00fff304 	movi	r3,-52
   453d4:	10c00005 	stb	r3,0(r2)
            buf[8 + sizeof(SysPara) + 3] = checksum;
   453d8:	e0bffe17 	ldw	r2,-8(fp)
   453dc:	10804fc4 	addi	r2,r2,319
   453e0:	e0fffa03 	ldbu	r3,-24(fp)
   453e4:	10c00005 	stb	r3,0(r2)
            buf_len                      = 8 + sizeof(SysPara) + 4;
   453e8:	00805004 	movi	r2,320
   453ec:	e0bff915 	stw	r2,-28(fp)
            break;
   453f0:	00007c06 	br	455e4 <pc2dev_packet+0x760>
        case NIOS_REMOTE_WRITE_REPONSE:
        case NIOS_UP_REMOTE_UPDATE_IMAGE:
            buf[8]  = (image.addr >> 24) & 0xff;
   453f4:	e0bffe17 	ldw	r2,-8(fp)
   453f8:	10c00204 	addi	r3,r2,8
   453fc:	008001b4 	movhi	r2,6
   45400:	10905004 	addi	r2,r2,16704
   45404:	10800017 	ldw	r2,0(r2)
   45408:	1004d63a 	srli	r2,r2,24
   4540c:	18800005 	stb	r2,0(r3)
            buf[9]  = (image.addr >> 16) & 0xff;
   45410:	e0bffe17 	ldw	r2,-8(fp)
   45414:	10c00244 	addi	r3,r2,9
   45418:	008001b4 	movhi	r2,6
   4541c:	10905004 	addi	r2,r2,16704
   45420:	10800017 	ldw	r2,0(r2)
   45424:	1004d43a 	srli	r2,r2,16
   45428:	18800005 	stb	r2,0(r3)
            buf[10] = (image.addr >> 8) & 0xff;
   4542c:	e0bffe17 	ldw	r2,-8(fp)
   45430:	10c00284 	addi	r3,r2,10
   45434:	008001b4 	movhi	r2,6
   45438:	10905004 	addi	r2,r2,16704
   4543c:	10800017 	ldw	r2,0(r2)
   45440:	1004d23a 	srli	r2,r2,8
   45444:	18800005 	stb	r2,0(r3)
            buf[11] = (image.addr >> 0) & 0xff;
   45448:	e0bffe17 	ldw	r2,-8(fp)
   4544c:	10c002c4 	addi	r3,r2,11
   45450:	008001b4 	movhi	r2,6
   45454:	10905004 	addi	r2,r2,16704
   45458:	10800017 	ldw	r2,0(r2)
   4545c:	18800005 	stb	r2,0(r3)
            memcpy(&buf[12], image.data, 256);
   45460:	e0bffe17 	ldw	r2,-8(fp)
   45464:	10c00304 	addi	r3,r2,12
   45468:	008001b4 	movhi	r2,6
   4546c:	10905004 	addi	r2,r2,16704
   45470:	1809883a 	mov	r4,r3
   45474:	10800104 	addi	r2,r2,4
   45478:	00c04004 	movi	r3,256
   4547c:	180d883a 	mov	r6,r3
   45480:	100b883a 	mov	r5,r2
   45484:	00493d40 	call	493d4 <memcpy>
            for(i = 0; i < 8 + 4 + 256; i++)
   45488:	e03ff815 	stw	zero,-32(fp)
   4548c:	00000a06 	br	454b8 <pc2dev_packet+0x634>
                checksum ^= buf[i];
   45490:	e0bff817 	ldw	r2,-32(fp)
   45494:	e0fffe17 	ldw	r3,-8(fp)
   45498:	1885883a 	add	r2,r3,r2
   4549c:	10c00003 	ldbu	r3,0(r2)
   454a0:	e0bffa03 	ldbu	r2,-24(fp)
   454a4:	1884f03a 	xor	r2,r3,r2
   454a8:	e0bffa05 	stb	r2,-24(fp)
            buf[8]  = (image.addr >> 24) & 0xff;
            buf[9]  = (image.addr >> 16) & 0xff;
            buf[10] = (image.addr >> 8) & 0xff;
            buf[11] = (image.addr >> 0) & 0xff;
            memcpy(&buf[12], image.data, 256);
            for(i = 0; i < 8 + 4 + 256; i++)
   454ac:	e0bff817 	ldw	r2,-32(fp)
   454b0:	10800044 	addi	r2,r2,1
   454b4:	e0bff815 	stw	r2,-32(fp)
   454b8:	e0bff817 	ldw	r2,-32(fp)
   454bc:	10804310 	cmplti	r2,r2,268
   454c0:	103ff31e 	bne	r2,zero,45490 <__alt_mem_epcs_flash+0xfffc4490>
                checksum ^= buf[i];
            buf[272] = buf[273] = buf[274] = 0;
   454c4:	e0bffe17 	ldw	r2,-8(fp)
   454c8:	11004404 	addi	r4,r2,272
   454cc:	e0bffe17 	ldw	r2,-8(fp)
   454d0:	10804444 	addi	r2,r2,273
   454d4:	e0fffe17 	ldw	r3,-8(fp)
   454d8:	18c04484 	addi	r3,r3,274
   454dc:	18000005 	stb	zero,0(r3)
   454e0:	18c00003 	ldbu	r3,0(r3)
   454e4:	10c00005 	stb	r3,0(r2)
   454e8:	10800003 	ldbu	r2,0(r2)
   454ec:	20800005 	stb	r2,0(r4)
            buf[275]                       = checksum;
   454f0:	e0bffe17 	ldw	r2,-8(fp)
   454f4:	108044c4 	addi	r2,r2,275
   454f8:	e0fffa03 	ldbu	r3,-24(fp)
   454fc:	10c00005 	stb	r3,0(r2)
            buf_len                        = 8 + 4 + 256 + 4;
   45500:	00804404 	movi	r2,272
   45504:	e0bff915 	stw	r2,-28(fp)
            break;
   45508:	00003606 	br	455e4 <pc2dev_packet+0x760>
        default:
            buf[8]  = (data->value >> 24) & 0xff;
   4550c:	e0bffe17 	ldw	r2,-8(fp)
   45510:	10800204 	addi	r2,r2,8
   45514:	e0fffd17 	ldw	r3,-12(fp)
   45518:	18c00317 	ldw	r3,12(r3)
   4551c:	1806d63a 	srli	r3,r3,24
   45520:	10c00005 	stb	r3,0(r2)
            buf[9]  = (data->value >> 16) & 0xff;
   45524:	e0bffe17 	ldw	r2,-8(fp)
   45528:	10800244 	addi	r2,r2,9
   4552c:	e0fffd17 	ldw	r3,-12(fp)
   45530:	18c00317 	ldw	r3,12(r3)
   45534:	1806d43a 	srli	r3,r3,16
   45538:	10c00005 	stb	r3,0(r2)
            buf[10] = (data->value >> 8) & 0xff;
   4553c:	e0bffe17 	ldw	r2,-8(fp)
   45540:	10800284 	addi	r2,r2,10
   45544:	e0fffd17 	ldw	r3,-12(fp)
   45548:	18c00317 	ldw	r3,12(r3)
   4554c:	1806d23a 	srli	r3,r3,8
   45550:	10c00005 	stb	r3,0(r2)
            buf[11] = (data->value >> 0) & 0xff;
   45554:	e0bffe17 	ldw	r2,-8(fp)
   45558:	108002c4 	addi	r2,r2,11
   4555c:	e0fffd17 	ldw	r3,-12(fp)
   45560:	18c00317 	ldw	r3,12(r3)
   45564:	10c00005 	stb	r3,0(r2)
            for(i = 0; i < 12; i++)
   45568:	e03ff815 	stw	zero,-32(fp)
   4556c:	00000a06 	br	45598 <pc2dev_packet+0x714>
            {
                checksum ^= buf[i];
   45570:	e0bff817 	ldw	r2,-32(fp)
   45574:	e0fffe17 	ldw	r3,-8(fp)
   45578:	1885883a 	add	r2,r3,r2
   4557c:	10c00003 	ldbu	r3,0(r2)
   45580:	e0bffa03 	ldbu	r2,-24(fp)
   45584:	1884f03a 	xor	r2,r3,r2
   45588:	e0bffa05 	stb	r2,-24(fp)
        default:
            buf[8]  = (data->value >> 24) & 0xff;
            buf[9]  = (data->value >> 16) & 0xff;
            buf[10] = (data->value >> 8) & 0xff;
            buf[11] = (data->value >> 0) & 0xff;
            for(i = 0; i < 12; i++)
   4558c:	e0bff817 	ldw	r2,-32(fp)
   45590:	10800044 	addi	r2,r2,1
   45594:	e0bff815 	stw	r2,-32(fp)
   45598:	e0bff817 	ldw	r2,-32(fp)
   4559c:	10800310 	cmplti	r2,r2,12
   455a0:	103ff31e 	bne	r2,zero,45570 <__alt_mem_epcs_flash+0xfffc4570>
            {
                checksum ^= buf[i];
            }
            buf[12] = 0;
   455a4:	e0bffe17 	ldw	r2,-8(fp)
   455a8:	10800304 	addi	r2,r2,12
   455ac:	10000005 	stb	zero,0(r2)
            buf[13] = 0;
   455b0:	e0bffe17 	ldw	r2,-8(fp)
   455b4:	10800344 	addi	r2,r2,13
   455b8:	10000005 	stb	zero,0(r2)
            buf[14] = 0;
   455bc:	e0bffe17 	ldw	r2,-8(fp)
   455c0:	10800384 	addi	r2,r2,14
   455c4:	10000005 	stb	zero,0(r2)
            buf[15] = checksum;
   455c8:	e0bffe17 	ldw	r2,-8(fp)
   455cc:	108003c4 	addi	r2,r2,15
   455d0:	e0fffa03 	ldbu	r3,-24(fp)
   455d4:	10c00005 	stb	r3,0(r2)
            buf_len = 16;
   455d8:	00800404 	movi	r2,16
   455dc:	e0bff915 	stw	r2,-28(fp)
            break;
   455e0:	0001883a 	nop
    }

    return buf_len;
   455e4:	e0bff917 	ldw	r2,-28(fp)
}
   455e8:	e6ffff04 	addi	sp,fp,-4
   455ec:	dfc00217 	ldw	ra,8(sp)
   455f0:	df000117 	ldw	fp,4(sp)
   455f4:	dc000017 	ldw	r16,0(sp)
   455f8:	dec00304 	addi	sp,sp,12
   455fc:	f800283a 	ret

00045600 <queue_init>:
 * @param   queue_element_t* const ptr: pointer to the array to store the data.
 * @param   const unsigned size: the size of the queue.
 * @return  None
 */
void queue_init(Queue* const queue, queue_item_t* const ptr, const unsigned size)
{
   45600:	defffb04 	addi	sp,sp,-20
   45604:	dfc00415 	stw	ra,16(sp)
   45608:	df000315 	stw	fp,12(sp)
   4560c:	df000304 	addi	fp,sp,12
   45610:	e13ffd15 	stw	r4,-12(fp)
   45614:	e17ffe15 	stw	r5,-8(fp)
   45618:	e1bfff15 	stw	r6,-4(fp)
    queue->front = 0;
   4561c:	e0bffd17 	ldw	r2,-12(fp)
   45620:	10000015 	stw	zero,0(r2)
    queue->rear = 0;
   45624:	e0bffd17 	ldw	r2,-12(fp)
   45628:	10000115 	stw	zero,4(r2)
    queue->depth = size;
   4562c:	e0bffd17 	ldw	r2,-12(fp)
   45630:	e0ffff17 	ldw	r3,-4(fp)
   45634:	10c00215 	stw	r3,8(r2)
    queue->data = ptr;
   45638:	e0bffd17 	ldw	r2,-12(fp)
   4563c:	e0fffe17 	ldw	r3,-8(fp)
   45640:	10c00415 	stw	r3,16(r2)
    memset(queue->data, 0, sizeof(queue_item_t) * queue->depth);
   45644:	e0bffd17 	ldw	r2,-12(fp)
   45648:	10c00417 	ldw	r3,16(r2)
   4564c:	e0bffd17 	ldw	r2,-12(fp)
   45650:	10800217 	ldw	r2,8(r2)
   45654:	1085883a 	add	r2,r2,r2
   45658:	1085883a 	add	r2,r2,r2
   4565c:	100d883a 	mov	r6,r2
   45660:	000b883a 	mov	r5,zero
   45664:	1809883a 	mov	r4,r3
   45668:	004951c0 	call	4951c <memset>
    queue->frame_over_flag = 0;
   4566c:	e0bffd17 	ldw	r2,-12(fp)
   45670:	10000315 	stw	zero,12(r2)
}
   45674:	0001883a 	nop
   45678:	e037883a 	mov	sp,fp
   4567c:	dfc00117 	ldw	ra,4(sp)
   45680:	df000017 	ldw	fp,0(sp)
   45684:	dec00204 	addi	sp,sp,8
   45688:	f800283a 	ret

0004568c <queue_clear>:
 * @brief   Sets the front and the back to the same index and flags the queue as empty.
 * @param   Queue* const queue: pointer to a Queue.
 * @return  Queue_Status: returns the status of the queue. Should read Queue_Empty.
 */
void queue_clear(Queue* const queue)
{
   4568c:	defffe04 	addi	sp,sp,-8
   45690:	df000115 	stw	fp,4(sp)
   45694:	df000104 	addi	fp,sp,4
   45698:	e13fff15 	stw	r4,-4(fp)
    /* Perform the same operation as queue_init(). */
    queue->front = queue->rear = 0;
   4569c:	e0bfff17 	ldw	r2,-4(fp)
   456a0:	10000115 	stw	zero,4(r2)
   456a4:	e0bfff17 	ldw	r2,-4(fp)
   456a8:	10c00117 	ldw	r3,4(r2)
   456ac:	e0bfff17 	ldw	r2,-4(fp)
   456b0:	10c00015 	stw	r3,0(r2)
//    memset(queue->data, 0, sizeof(queue_item_t) * queue->depth);
}
   456b4:	0001883a 	nop
   456b8:	e037883a 	mov	sp,fp
   456bc:	df000017 	ldw	fp,0(sp)
   456c0:	dec00104 	addi	sp,sp,4
   456c4:	f800283a 	ret

000456c8 <queue_push>:
 * @param   Queue* const queue: pointer to a Queue.
 *          queue_element_t queue_element: data to be emplaced upon the queue.
 * @return  None.
 */
bool queue_push(Queue* const queue, const queue_item_t queue_element)
{
   456c8:	defffc04 	addi	sp,sp,-16
   456cc:	dfc00315 	stw	ra,12(sp)
   456d0:	df000215 	stw	fp,8(sp)
   456d4:	df000204 	addi	fp,sp,8
   456d8:	e13ffe15 	stw	r4,-8(fp)
   456dc:	e17fff15 	stw	r5,-4(fp)
	queue->data[queue->rear] = queue_element;
   456e0:	e0bffe17 	ldw	r2,-8(fp)
   456e4:	10c00417 	ldw	r3,16(r2)
   456e8:	e0bffe17 	ldw	r2,-8(fp)
   456ec:	10800117 	ldw	r2,4(r2)
   456f0:	1085883a 	add	r2,r2,r2
   456f4:	1085883a 	add	r2,r2,r2
   456f8:	1885883a 	add	r2,r3,r2
   456fc:	e0ffff17 	ldw	r3,-4(fp)
   45700:	10c00015 	stw	r3,0(r2)
	queue->rear = (queue->rear+1) % queue->depth;
   45704:	e0bffe17 	ldw	r2,-8(fp)
   45708:	10800117 	ldw	r2,4(r2)
   4570c:	10c00044 	addi	r3,r2,1
   45710:	e0bffe17 	ldw	r2,-8(fp)
   45714:	10800217 	ldw	r2,8(r2)
   45718:	100b883a 	mov	r5,r2
   4571c:	1809883a 	mov	r4,r3
   45720:	004937c0 	call	4937c <__umodsi3>
   45724:	1007883a 	mov	r3,r2
   45728:	e0bffe17 	ldw	r2,-8(fp)
   4572c:	10c00115 	stw	r3,4(r2)
    return true;
   45730:	00800044 	movi	r2,1
}
   45734:	e037883a 	mov	sp,fp
   45738:	dfc00117 	ldw	ra,4(sp)
   4573c:	df000017 	ldw	fp,0(sp)
   45740:	dec00204 	addi	sp,sp,8
   45744:	f800283a 	ret

00045748 <queue_pop>:
 * @brief   Removes an entry from the queue.
 * @param   Queue* const queue: pointer to a Queue.
 * @return  queue_element_t: the last element in the queue.
 */
queue_item_t queue_pop(Queue* const queue)
{
   45748:	defffc04 	addi	sp,sp,-16
   4574c:	dfc00315 	stw	ra,12(sp)
   45750:	df000215 	stw	fp,8(sp)
   45754:	df000204 	addi	fp,sp,8
   45758:	e13fff15 	stw	r4,-4(fp)
    /* First check to see if the queue is full. Since enqueue() doesn't update the front
     * pointer there is a possibility that the queue could've wrapped. Performing the
     * overfull check here means that 'front' is read only and not write. */
    queue_item_t data = queue->data[queue->front];
   4575c:	e0bfff17 	ldw	r2,-4(fp)
   45760:	10c00417 	ldw	r3,16(r2)
   45764:	e0bfff17 	ldw	r2,-4(fp)
   45768:	10800017 	ldw	r2,0(r2)
   4576c:	1085883a 	add	r2,r2,r2
   45770:	1085883a 	add	r2,r2,r2
   45774:	1885883a 	add	r2,r3,r2
   45778:	10800017 	ldw	r2,0(r2)
   4577c:	e0bffe15 	stw	r2,-8(fp)
    queue->front = (queue->front + 1) % queue->depth;
   45780:	e0bfff17 	ldw	r2,-4(fp)
   45784:	10800017 	ldw	r2,0(r2)
   45788:	10c00044 	addi	r3,r2,1
   4578c:	e0bfff17 	ldw	r2,-4(fp)
   45790:	10800217 	ldw	r2,8(r2)
   45794:	100b883a 	mov	r5,r2
   45798:	1809883a 	mov	r4,r3
   4579c:	004937c0 	call	4937c <__umodsi3>
   457a0:	1007883a 	mov	r3,r2
   457a4:	e0bfff17 	ldw	r2,-4(fp)
   457a8:	10c00015 	stw	r3,0(r2)
    return data;
   457ac:	e0bffe17 	ldw	r2,-8(fp)
}
   457b0:	e037883a 	mov	sp,fp
   457b4:	dfc00117 	ldw	ra,4(sp)
   457b8:	df000017 	ldw	fp,0(sp)
   457bc:	dec00204 	addi	sp,sp,8
   457c0:	f800283a 	ret

000457c4 <queue_count>:
 * @brief   Returns the number of objects in a queue.
 * @param   const Queue *queue: the queue to be checked.
 * @return  unsigned int: count
 */
unsigned int queue_count(const Queue* const queue)
{
   457c4:	defffd04 	addi	sp,sp,-12
   457c8:	dfc00215 	stw	ra,8(sp)
   457cc:	df000115 	stw	fp,4(sp)
   457d0:	df000104 	addi	fp,sp,4
   457d4:	e13fff15 	stw	r4,-4(fp)
    if(queue_is_empty(queue) == false)
   457d8:	e13fff17 	ldw	r4,-4(fp)
   457dc:	00458a40 	call	458a4 <queue_is_empty>
   457e0:	1080005c 	xori	r2,r2,1
   457e4:	10803fcc 	andi	r2,r2,255
   457e8:	10000e26 	beq	r2,zero,45824 <queue_count+0x60>
        return (queue->rear + queue->depth - queue->front) % queue->depth;
   457ec:	e0bfff17 	ldw	r2,-4(fp)
   457f0:	10c00117 	ldw	r3,4(r2)
   457f4:	e0bfff17 	ldw	r2,-4(fp)
   457f8:	10800217 	ldw	r2,8(r2)
   457fc:	1887883a 	add	r3,r3,r2
   45800:	e0bfff17 	ldw	r2,-4(fp)
   45804:	10800017 	ldw	r2,0(r2)
   45808:	1887c83a 	sub	r3,r3,r2
   4580c:	e0bfff17 	ldw	r2,-4(fp)
   45810:	10800217 	ldw	r2,8(r2)
   45814:	100b883a 	mov	r5,r2
   45818:	1809883a 	mov	r4,r3
   4581c:	004937c0 	call	4937c <__umodsi3>
   45820:	00000106 	br	45828 <queue_count+0x64>
    else
        return 0;
   45824:	0005883a 	mov	r2,zero
}
   45828:	e037883a 	mov	sp,fp
   4582c:	dfc00117 	ldw	ra,4(sp)
   45830:	df000017 	ldw	fp,0(sp)
   45834:	dec00204 	addi	sp,sp,8
   45838:	f800283a 	ret

0004583c <queue_is_full>:
 * @brief   Boolean check to see if the queue is full
 * @param   const Queue *queue: the queue to be checked.
 * @return  bool: false if not full. true if full.
 */
bool queue_is_full(const Queue* const queue)
{
   4583c:	defffc04 	addi	sp,sp,-16
   45840:	dfc00315 	stw	ra,12(sp)
   45844:	df000215 	stw	fp,8(sp)
   45848:	dc000115 	stw	r16,4(sp)
   4584c:	df000204 	addi	fp,sp,8
   45850:	e13ffe15 	stw	r4,-8(fp)
    if(queue->front == ( (queue->rear+1) % queue->depth) )
   45854:	e0bffe17 	ldw	r2,-8(fp)
   45858:	14000017 	ldw	r16,0(r2)
   4585c:	e0bffe17 	ldw	r2,-8(fp)
   45860:	10800117 	ldw	r2,4(r2)
   45864:	10c00044 	addi	r3,r2,1
   45868:	e0bffe17 	ldw	r2,-8(fp)
   4586c:	10800217 	ldw	r2,8(r2)
   45870:	100b883a 	mov	r5,r2
   45874:	1809883a 	mov	r4,r3
   45878:	004937c0 	call	4937c <__umodsi3>
   4587c:	8080021e 	bne	r16,r2,45888 <queue_is_full+0x4c>
        return true;
   45880:	00800044 	movi	r2,1
   45884:	00000106 	br	4588c <queue_is_full+0x50>
    else
        return false;
   45888:	0005883a 	mov	r2,zero
}
   4588c:	e6ffff04 	addi	sp,fp,-4
   45890:	dfc00217 	ldw	ra,8(sp)
   45894:	df000117 	ldw	fp,4(sp)
   45898:	dc000017 	ldw	r16,0(sp)
   4589c:	dec00304 	addi	sp,sp,12
   458a0:	f800283a 	ret

000458a4 <queue_is_empty>:
 * @brief   Boolean check to see if the queue is empty.
 * @param   const Queue *queue: the queue to be checked.
 * @return  bool: false if not empty. true if empty.
 */
bool queue_is_empty(const Queue* const queue)
{
   458a4:	defffe04 	addi	sp,sp,-8
   458a8:	df000115 	stw	fp,4(sp)
   458ac:	df000104 	addi	fp,sp,4
   458b0:	e13fff15 	stw	r4,-4(fp)
    if(queue->front == queue->rear)
   458b4:	e0bfff17 	ldw	r2,-4(fp)
   458b8:	10c00017 	ldw	r3,0(r2)
   458bc:	e0bfff17 	ldw	r2,-4(fp)
   458c0:	10800117 	ldw	r2,4(r2)
   458c4:	1880021e 	bne	r3,r2,458d0 <queue_is_empty+0x2c>
        return true;
   458c8:	00800044 	movi	r2,1
   458cc:	00000106 	br	458d4 <queue_is_empty+0x30>
    else
        return false;
   458d0:	0005883a 	mov	r2,zero
}
   458d4:	e037883a 	mov	sp,fp
   458d8:	df000017 	ldw	fp,0(sp)
   458dc:	dec00104 	addi	sp,sp,4
   458e0:	f800283a 	ret

000458e4 <region_save2eeprom>:
 * @param region
 * @return true
 * @return false
 */
bool region_save2eeprom(struct __region *region)
{
   458e4:	defffc04 	addi	sp,sp,-16
   458e8:	dfc00315 	stw	ra,12(sp)
   458ec:	df000215 	stw	fp,8(sp)
   458f0:	df000204 	addi	fp,sp,8
   458f4:	e13fff15 	stw	r4,-4(fp)
    unsigned int offset_addr;

    eeprom_write_byte(3, (unsigned char)region->select);  //
   458f8:	e0bfff17 	ldw	r2,-4(fp)
   458fc:	1081bd17 	ldw	r2,1780(r2)
   45900:	10803fcc 	andi	r2,r2,255
   45904:	100b883a 	mov	r5,r2
   45908:	010000c4 	movi	r4,3
   4590c:	0041f280 	call	41f28 <eeprom_write_byte>
    delay_us(10000);
   45910:	0109c404 	movi	r4,10000
   45914:	00402c80 	call	402c8 <delay_us>

    offset_addr = GROUP_OFFSET_ADDR + REGION_SPACE_SIZE * region->wr_which;
   45918:	e0bfff17 	ldw	r2,-4(fp)
   4591c:	10800103 	ldbu	r2,4(r2)
   45920:	10803fcc 	andi	r2,r2,255
   45924:	10800084 	addi	r2,r2,2
   45928:	100492fa 	slli	r2,r2,11
   4592c:	e0bffe15 	stw	r2,-8(fp)
    eeprom_write_page(offset_addr, (alt_u8 *)region->buffer, TARGET_NUMBER * 2);
   45930:	e0bfff17 	ldw	r2,-4(fp)
   45934:	10802704 	addi	r2,r2,156
   45938:	01819584 	movi	r6,1622
   4593c:	100b883a 	mov	r5,r2
   45940:	e13ffe17 	ldw	r4,-8(fp)
   45944:	0041fd40 	call	41fd4 <eeprom_write_page>
    offset_addr += TARGET_NUMBER * 2;
   45948:	e0bffe17 	ldw	r2,-8(fp)
   4594c:	10819584 	addi	r2,r2,1622
   45950:	e0bffe15 	stw	r2,-8(fp)
    eeprom_write_page(offset_addr, (alt_u8 *)region->zenith_save, ZENITH_NUMBER);
   45954:	e0bfff17 	ldw	r2,-4(fp)
   45958:	10800184 	addi	r2,r2,6
   4595c:	018019c4 	movi	r6,103
   45960:	100b883a 	mov	r5,r2
   45964:	e13ffe17 	ldw	r4,-8(fp)
   45968:	0041fd40 	call	41fd4 <eeprom_write_page>

    return true;
   4596c:	00800044 	movi	r2,1
}
   45970:	e037883a 	mov	sp,fp
   45974:	dfc00117 	ldw	ra,4(sp)
   45978:	df000017 	ldw	fp,0(sp)
   4597c:	dec00204 	addi	sp,sp,8
   45980:	f800283a 	ret

00045984 <region_save2fpga>:
 * @param num 0,内层; 1, 中间层; 2:外层
 * @return true
 * @return false
 */
bool region_save2fpga(struct __region *region, int num)
{
   45984:	defffa04 	addi	sp,sp,-24
   45988:	dfc00515 	stw	ra,20(sp)
   4598c:	df000415 	stw	fp,16(sp)
   45990:	df000404 	addi	fp,sp,16
   45994:	e13ffe15 	stw	r4,-8(fp)
   45998:	e17fff15 	stw	r5,-4(fp)
    int          i;
    unsigned int data;
    if(num == 0)
   4599c:	e0bfff17 	ldw	r2,-4(fp)
   459a0:	1000041e 	bne	r2,zero,459b4 <region_save2fpga+0x30>
        data = 0x12340000 + WR_REGION0_DATA;
   459a4:	00848d74 	movhi	r2,4661
   459a8:	10ac4004 	addi	r2,r2,-20224
   459ac:	e0bffd15 	stw	r2,-12(fp)
   459b0:	00000d06 	br	459e8 <region_save2fpga+0x64>
    else if(num == 1)
   459b4:	e0bfff17 	ldw	r2,-4(fp)
   459b8:	10800058 	cmpnei	r2,r2,1
   459bc:	1000041e 	bne	r2,zero,459d0 <region_save2fpga+0x4c>
        data = 0x12340000 + WR_REGION1_DATA;
   459c0:	00848d74 	movhi	r2,4661
   459c4:	10ac4044 	addi	r2,r2,-20223
   459c8:	e0bffd15 	stw	r2,-12(fp)
   459cc:	00000606 	br	459e8 <region_save2fpga+0x64>
    else if(num == 2)
   459d0:	e0bfff17 	ldw	r2,-4(fp)
   459d4:	10800098 	cmpnei	r2,r2,2
   459d8:	1000031e 	bne	r2,zero,459e8 <region_save2fpga+0x64>
        data = 0x12340000 + WR_REGION2_DATA;
   459dc:	00848d74 	movhi	r2,4661
   459e0:	10ac4084 	addi	r2,r2,-20222
   459e4:	e0bffd15 	stw	r2,-12(fp)

    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   459e8:	e0bffd17 	ldw	r2,-12(fp)
   459ec:	1004143a 	roli	r2,r2,16
   459f0:	100d883a 	mov	r6,r2
   459f4:	01400234 	movhi	r5,8
   459f8:	29484004 	addi	r5,r5,8448
   459fc:	01000234 	movhi	r4,8
   45a00:	21087a04 	addi	r4,r4,8680
   45a04:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
    data = 811;
   45a08:	0080cac4 	movi	r2,811
   45a0c:	e0bffd15 	stw	r2,-12(fp)
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   45a10:	e0bffd17 	ldw	r2,-12(fp)
   45a14:	1004143a 	roli	r2,r2,16
   45a18:	100d883a 	mov	r6,r2
   45a1c:	01400234 	movhi	r5,8
   45a20:	29484004 	addi	r5,r5,8448
   45a24:	01000234 	movhi	r4,8
   45a28:	21087a04 	addi	r4,r4,8680
   45a2c:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>

    //    data = 0x1000;
    for(i = 0; i < 811; i++)
   45a30:	e03ffc15 	stw	zero,-16(fp)
   45a34:	00001306 	br	45a84 <region_save2fpga+0x100>
    {
        data = region->buffer[i];
   45a38:	e0fffe17 	ldw	r3,-8(fp)
   45a3c:	e0bffc17 	ldw	r2,-16(fp)
   45a40:	10801384 	addi	r2,r2,78
   45a44:	1085883a 	add	r2,r2,r2
   45a48:	1885883a 	add	r2,r3,r2
   45a4c:	1080000b 	ldhu	r2,0(r2)
   45a50:	10bfffcc 	andi	r2,r2,65535
   45a54:	e0bffd15 	stw	r2,-12(fp)
        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   45a58:	e0bffd17 	ldw	r2,-12(fp)
   45a5c:	1004143a 	roli	r2,r2,16
   45a60:	100d883a 	mov	r6,r2
   45a64:	01400234 	movhi	r5,8
   45a68:	29484004 	addi	r5,r5,8448
   45a6c:	01000234 	movhi	r4,8
   45a70:	21087a04 	addi	r4,r4,8680
   45a74:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
    data = 811;
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));

    //    data = 0x1000;
    for(i = 0; i < 811; i++)
   45a78:	e0bffc17 	ldw	r2,-16(fp)
   45a7c:	10800044 	addi	r2,r2,1
   45a80:	e0bffc15 	stw	r2,-16(fp)
   45a84:	e0bffc17 	ldw	r2,-16(fp)
   45a88:	1080cad0 	cmplti	r2,r2,811
   45a8c:	103fea1e 	bne	r2,zero,45a38 <__alt_mem_epcs_flash+0xfffc4a38>
    {
        data = region->buffer[i];
        altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
    }
    data = 0xccccdddd;
   45a90:	00b33374 	movhi	r2,52429
   45a94:	10b77744 	addi	r2,r2,-8739
   45a98:	e0bffd15 	stw	r2,-12(fp)
    altera_avalon_fifo_write_fifo(PROTOCOL_FIFO_IN_BASE, PROTOCOL_FIFO_IN_CSR_BASE, (data >> 16) + (data << 16));
   45a9c:	e0bffd17 	ldw	r2,-12(fp)
   45aa0:	1004143a 	roli	r2,r2,16
   45aa4:	100d883a 	mov	r6,r2
   45aa8:	01400234 	movhi	r5,8
   45aac:	29484004 	addi	r5,r5,8448
   45ab0:	01000234 	movhi	r4,8
   45ab4:	21087a04 	addi	r4,r4,8680
   45ab8:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
    return true;
   45abc:	00800044 	movi	r2,1
}
   45ac0:	e037883a 	mov	sp,fp
   45ac4:	dfc00117 	ldw	ra,4(sp)
   45ac8:	df000017 	ldw	fp,0(sp)
   45acc:	dec00204 	addi	sp,sp,8
   45ad0:	f800283a 	ret

00045ad4 <region_read_from_rom>:
 * @param num e2prom内存空间编号. 0, 3内存; 1,4,中间层; 2,5 外层
 * @return true
 * @return false
 */
bool region_read_from_rom(struct __region *region, int num)
{
   45ad4:	defffb04 	addi	sp,sp,-20
   45ad8:	dfc00415 	stw	ra,16(sp)
   45adc:	df000315 	stw	fp,12(sp)
   45ae0:	df000304 	addi	fp,sp,12
   45ae4:	e13ffe15 	stw	r4,-8(fp)
   45ae8:	e17fff15 	stw	r5,-4(fp)
    unsigned int offset_addr;

    offset_addr = GROUP_OFFSET_ADDR + num * REGION_SPACE_SIZE;
   45aec:	e0bfff17 	ldw	r2,-4(fp)
   45af0:	10800084 	addi	r2,r2,2
   45af4:	100492fa 	slli	r2,r2,11
   45af8:	e0bffd15 	stw	r2,-12(fp)
    eeprom_sequential_read(offset_addr, (alt_u8 *)region->buffer, TARGET_NUMBER * 2);
   45afc:	e0bffe17 	ldw	r2,-8(fp)
   45b00:	10802704 	addi	r2,r2,156
   45b04:	01819584 	movi	r6,1622
   45b08:	100b883a 	mov	r5,r2
   45b0c:	e13ffd17 	ldw	r4,-12(fp)
   45b10:	00422a40 	call	422a4 <eeprom_sequential_read>
    region_save2fpga(&alarm_region, num % 3);
   45b14:	e0bfff17 	ldw	r2,-4(fp)
   45b18:	014000c4 	movi	r5,3
   45b1c:	1009883a 	mov	r4,r2
   45b20:	00492a40 	call	492a4 <__modsi3>
   45b24:	100b883a 	mov	r5,r2
   45b28:	010001b4 	movhi	r4,6
   45b2c:	2125c204 	addi	r4,r4,-26872
   45b30:	00459840 	call	45984 <region_save2fpga>

    return true;
   45b34:	00800044 	movi	r2,1
}
   45b38:	e037883a 	mov	sp,fp
   45b3c:	dfc00117 	ldw	ra,4(sp)
   45b40:	df000017 	ldw	fp,0(sp)
   45b44:	dec00204 	addi	sp,sp,8
   45b48:	f800283a 	ret

00045b4c <save_sys_para>:
 * @brief 将SysStatus里的系统运行参数保存到Flash里, 小端模式写入
 * TODO: 解决参数区域内容被意外擦除
 * @param data
 */
void save_sys_para(Sys_Para *data)
{
   45b4c:	deff9d04 	addi	sp,sp,-396
   45b50:	dfc06215 	stw	ra,392(sp)
   45b54:	df006115 	stw	fp,388(sp)
   45b58:	df006104 	addi	fp,sp,388
   45b5c:	e13fff15 	stw	r4,-4(fp)
    unsigned char buf[384];
    memset(buf, 0, sizeof(buf));
   45b60:	01806004 	movi	r6,384
   45b64:	000b883a 	mov	r5,zero
   45b68:	e13f9f04 	addi	r4,fp,-388
   45b6c:	004951c0 	call	4951c <memset>
    memcpy(buf, (unsigned char *)data, sizeof(Sys_Para));
   45b70:	01804d04 	movi	r6,308
   45b74:	e17fff17 	ldw	r5,-4(fp)
   45b78:	e13f9f04 	addi	r4,fp,-388
   45b7c:	00493d40 	call	493d4 <memcpy>
    eeprom_write_page(SYS_PARA_ADDR, buf, sizeof(Sys_Para));
   45b80:	01804d04 	movi	r6,308
   45b84:	e17f9f04 	addi	r5,fp,-388
   45b88:	01010004 	movi	r4,1024
   45b8c:	0041fd40 	call	41fd4 <eeprom_write_page>
}
   45b90:	0001883a 	nop
   45b94:	e037883a 	mov	sp,fp
   45b98:	dfc00117 	ldw	ra,4(sp)
   45b9c:	df000017 	ldw	fp,0(sp)
   45ba0:	dec00204 	addi	sp,sp,8
   45ba4:	f800283a 	ret

00045ba8 <read_sys_para>:
 * @brief 如果Flash为空，则版本号为0.01。保存参数重新上电后，版本号正常
 *
 * @param status
 */
void read_sys_para(Sys_Para *status)
{
   45ba8:	deff9c04 	addi	sp,sp,-400
   45bac:	dfc06315 	stw	ra,396(sp)
   45bb0:	df006215 	stw	fp,392(sp)
   45bb4:	df006204 	addi	fp,sp,392
   45bb8:	e13fff15 	stw	r4,-4(fp)
    unsigned int  num = 5;
   45bbc:	00800144 	movi	r2,5
   45bc0:	e0bf9e15 	stw	r2,-392(fp)
    unsigned char buf[384];

    while(num--)
   45bc4:	00005406 	br	45d18 <read_sys_para+0x170>
    {
        eeprom_sequential_read(SYS_PARA_ADDR, buf, sizeof(Sys_Para));
   45bc8:	e0bf9f04 	addi	r2,fp,-388
   45bcc:	01804d04 	movi	r6,308
   45bd0:	100b883a 	mov	r5,r2
   45bd4:	01010004 	movi	r4,1024
   45bd8:	00422a40 	call	422a4 <eeprom_sequential_read>
        status->dust_threshold = 400;
   45bdc:	e0bfff17 	ldw	r2,-4(fp)
   45be0:	00c06404 	movi	r3,400
   45be4:	10c04915 	stw	r3,292(r2)
        // 简单判断从eeprom读出来的数据是否正确
        if(((buf[4] == 0x11) && (buf[5] == 0x11) && (buf[6] == 0x11) && (buf[7] == 0x11)) ||
   45be8:	e0bfa003 	ldbu	r2,-384(fp)
   45bec:	10803fcc 	andi	r2,r2,255
   45bf0:	10800458 	cmpnei	r2,r2,17
   45bf4:	10000c1e 	bne	r2,zero,45c28 <read_sys_para+0x80>
   45bf8:	e0bfa043 	ldbu	r2,-383(fp)
   45bfc:	10803fcc 	andi	r2,r2,255
   45c00:	10800458 	cmpnei	r2,r2,17
   45c04:	1000081e 	bne	r2,zero,45c28 <read_sys_para+0x80>
   45c08:	e0bfa083 	ldbu	r2,-382(fp)
   45c0c:	10803fcc 	andi	r2,r2,255
   45c10:	10800458 	cmpnei	r2,r2,17
   45c14:	1000041e 	bne	r2,zero,45c28 <read_sys_para+0x80>
   45c18:	e0bfa0c3 	ldbu	r2,-381(fp)
   45c1c:	10803fcc 	andi	r2,r2,255
   45c20:	10800460 	cmpeqi	r2,r2,17
   45c24:	1000101e 	bne	r2,zero,45c68 <read_sys_para+0xc0>
           ((buf[4] == 0x22) && (buf[5] == 0x22) && (buf[6] == 0x22) && (buf[7] == 0x22)))
   45c28:	e0bfa003 	ldbu	r2,-384(fp)
    while(num--)
    {
        eeprom_sequential_read(SYS_PARA_ADDR, buf, sizeof(Sys_Para));
        status->dust_threshold = 400;
        // 简单判断从eeprom读出来的数据是否正确
        if(((buf[4] == 0x11) && (buf[5] == 0x11) && (buf[6] == 0x11) && (buf[7] == 0x11)) ||
   45c2c:	10803fcc 	andi	r2,r2,255
   45c30:	10800898 	cmpnei	r2,r2,34
   45c34:	1000381e 	bne	r2,zero,45d18 <read_sys_para+0x170>
           ((buf[4] == 0x22) && (buf[5] == 0x22) && (buf[6] == 0x22) && (buf[7] == 0x22)))
   45c38:	e0bfa043 	ldbu	r2,-383(fp)
   45c3c:	10803fcc 	andi	r2,r2,255
   45c40:	10800898 	cmpnei	r2,r2,34
   45c44:	1000341e 	bne	r2,zero,45d18 <read_sys_para+0x170>
   45c48:	e0bfa083 	ldbu	r2,-382(fp)
   45c4c:	10803fcc 	andi	r2,r2,255
   45c50:	10800898 	cmpnei	r2,r2,34
   45c54:	1000301e 	bne	r2,zero,45d18 <read_sys_para+0x170>
   45c58:	e0bfa0c3 	ldbu	r2,-381(fp)
   45c5c:	10803fcc 	andi	r2,r2,255
   45c60:	10800898 	cmpnei	r2,r2,34
   45c64:	10002c1e 	bne	r2,zero,45d18 <read_sys_para+0x170>
        {
            memcpy(status, buf, sizeof(Sys_Para));
   45c68:	e0bf9f04 	addi	r2,fp,-388
   45c6c:	01804d04 	movi	r6,308
   45c70:	100b883a 	mov	r5,r2
   45c74:	e13fff17 	ldw	r4,-4(fp)
   45c78:	00493d40 	call	493d4 <memcpy>

            // 标识位即时写入E2PROM, 如果此时系统断电, 重新上电后系统状态会出错
            status->update_pos_flag = true;
   45c7c:	e0bfff17 	ldw	r2,-4(fp)
   45c80:	00c00044 	movi	r3,1
   45c84:	10c00005 	stb	r3,0(r2)
            status->motor_enable    = ENABLE;
   45c88:	e0ffff17 	ldw	r3,-4(fp)
   45c8c:	00844474 	movhi	r2,4369
   45c90:	10844444 	addi	r2,r2,4369
   45c94:	18800415 	stw	r2,16(r3)
            status->laser_enable    = ENABLE;
   45c98:	e0ffff17 	ldw	r3,-4(fp)
   45c9c:	00844474 	movhi	r2,4369
   45ca0:	10844444 	addi	r2,r2,4369
   45ca4:	18800115 	stw	r2,4(r3)
            status->max_pwm_duty    = 10;
   45ca8:	e0bfff17 	ldw	r2,-4(fp)
   45cac:	00c00284 	movi	r3,10
   45cb0:	10c01f15 	stw	r3,124(r2)
            status->dust_threshold  = 400;
   45cb4:	e0bfff17 	ldw	r2,-4(fp)
   45cb8:	00c06404 	movi	r3,400
   45cbc:	10c04915 	stw	r3,292(r2)
            memcpy(status->nios_ver, NIOS_VERSION, 4);
   45cc0:	e0bfff17 	ldw	r2,-4(fp)
   45cc4:	10801504 	addi	r2,r2,84
   45cc8:	01800104 	movi	r6,4
   45ccc:	01400174 	movhi	r5,5
   45cd0:	2974dc04 	addi	r5,r5,-11408
   45cd4:	1009883a 	mov	r4,r2
   45cd8:	00493d40 	call	493d4 <memcpy>
            memcpy(status->fpga_ver, FPGA_VERSION, 4);
   45cdc:	e0bfff17 	ldw	r2,-4(fp)
   45ce0:	10801604 	addi	r2,r2,88
   45ce4:	01800104 	movi	r6,4
   45ce8:	01400174 	movhi	r5,5
   45cec:	2974dc04 	addi	r5,r5,-11408
   45cf0:	1009883a 	mov	r4,r2
   45cf4:	00493d40 	call	493d4 <memcpy>
            memcpy(status->dev_pn, DEV_PN_NUM, 20);
   45cf8:	e0bfff17 	ldw	r2,-4(fp)
   45cfc:	10803304 	addi	r2,r2,204
   45d00:	01800504 	movi	r6,20
   45d04:	01400174 	movhi	r5,5
   45d08:	2974de04 	addi	r5,r5,-11400
   45d0c:	1009883a 	mov	r4,r2
   45d10:	00493d40 	call	493d4 <memcpy>
   45d14:	00000406 	br	45d28 <read_sys_para+0x180>
void read_sys_para(Sys_Para *status)
{
    unsigned int  num = 5;
    unsigned char buf[384];

    while(num--)
   45d18:	e0bf9e17 	ldw	r2,-392(fp)
   45d1c:	10ffffc4 	addi	r3,r2,-1
   45d20:	e0ff9e15 	stw	r3,-392(fp)
   45d24:	103fa81e 	bne	r2,zero,45bc8 <__alt_mem_epcs_flash+0xfffc4bc8>
            memcpy(status->dev_pn, DEV_PN_NUM, 20);

            return;
        }
    }
}
   45d28:	e037883a 	mov	sp,fp
   45d2c:	dfc00117 	ldw	ra,4(sp)
   45d30:	df000017 	ldw	fp,0(sp)
   45d34:	dec00204 	addi	sp,sp,8
   45d38:	f800283a 	ret

00045d3c <rd_switch_io_value>:

unsigned char rd_switch_io_value(void)
{
   45d3c:	defffe04 	addi	sp,sp,-8
   45d40:	df000115 	stw	fp,4(sp)
   45d44:	df000104 	addi	fp,sp,4
    unsigned char data;
    data = IORD_ALTERA_AVALON_PIO_DATA(ALARM_SELECT_BASE);
   45d48:	00800234 	movhi	r2,8
   45d4c:	10885004 	addi	r2,r2,8512
   45d50:	10800037 	ldwio	r2,0(r2)
   45d54:	e0bfff05 	stb	r2,-4(fp)
    data = (~data) & 0x0f;
   45d58:	e0bfff03 	ldbu	r2,-4(fp)
   45d5c:	0084303a 	nor	r2,zero,r2
   45d60:	108003cc 	andi	r2,r2,15
   45d64:	e0bfff05 	stb	r2,-4(fp)
    return data;
   45d68:	e0bfff03 	ldbu	r2,-4(fp)
}
   45d6c:	e037883a 	mov	sp,fp
   45d70:	df000017 	ldw	fp,0(sp)
   45d74:	dec00104 	addi	sp,sp,4
   45d78:	f800283a 	ret

00045d7c <image_write>:
#include "remote_update.h"

update_t image;

int image_write(int addr, unsigned char *data)
{
   45d7c:	defff104 	addi	sp,sp,-60
   45d80:	dfc00e15 	stw	ra,56(sp)
   45d84:	df000d15 	stw	fp,52(sp)
   45d88:	df000d04 	addi	fp,sp,52
   45d8c:	e13ffe15 	stw	r4,-8(fp)
   45d90:	e17fff15 	stw	r5,-4(fp)
    int           block_addr;
    int           offset;
    int           ret_code;
    alt_flash_fd *fd;

    block_addr = (int)(addr / EPCS_BLOCK_SIZE) * EPCS_BLOCK_SIZE;
   45d94:	e0bffe17 	ldw	r2,-8(fp)
   45d98:	1000020e 	bge	r2,zero,45da4 <image_write+0x28>
   45d9c:	00ffffd4 	movui	r3,65535
   45da0:	10c5883a 	add	r2,r2,r3
   45da4:	1005d43a 	srai	r2,r2,16
   45da8:	1004943a 	slli	r2,r2,16
   45dac:	e0bff415 	stw	r2,-48(fp)
    offset     = addr % EPCS_BLOCK_SIZE;
   45db0:	e0fffe17 	ldw	r3,-8(fp)
   45db4:	00a00074 	movhi	r2,32769
   45db8:	10bfffc4 	addi	r2,r2,-1
   45dbc:	1884703a 	and	r2,r3,r2
   45dc0:	1000030e 	bge	r2,zero,45dd0 <image_write+0x54>
   45dc4:	10bfffc4 	addi	r2,r2,-1
   45dc8:	10bffff4 	orhi	r2,r2,65535
   45dcc:	10800044 	addi	r2,r2,1
   45dd0:	e0bff515 	stw	r2,-44(fp)
    fd         = alt_flash_open_dev(EPCS_FLASH_NAME);
   45dd4:	01000174 	movhi	r4,5
   45dd8:	2134e204 	addi	r4,r4,-11384
   45ddc:	00498880 	call	49888 <alt_flash_open_dev>
   45de0:	e0bff615 	stw	r2,-40(fp)
    if(!fd)
   45de4:	e0bff617 	ldw	r2,-40(fp)
   45de8:	1000021e 	bne	r2,zero,45df4 <image_write+0x78>
        return 0;
   45dec:	0005883a 	mov	r2,zero
   45df0:	00001b06 	br	45e60 <image_write+0xe4>
    else
    {
        ret_code = alt_write_flash_block(fd, block_addr, block_addr + offset, data, 256);
   45df4:	e0fff417 	ldw	r3,-48(fp)
   45df8:	e0bff517 	ldw	r2,-44(fp)
   45dfc:	1885883a 	add	r2,r3,r2
   45e00:	e0fff617 	ldw	r3,-40(fp)
   45e04:	e0fff815 	stw	r3,-32(fp)
   45e08:	e0fff417 	ldw	r3,-48(fp)
   45e0c:	e0fff915 	stw	r3,-28(fp)
   45e10:	e0bffa15 	stw	r2,-24(fp)
   45e14:	e0bfff17 	ldw	r2,-4(fp)
   45e18:	e0bffb15 	stw	r2,-20(fp)
   45e1c:	00804004 	movi	r2,256
   45e20:	e0bffc15 	stw	r2,-16(fp)
                                      int data_offset,
                                      const void *data, int length)
{

  int ret_code;
  ret_code = fd->write_block( fd, block_offset, data_offset, data, length );
   45e24:	e0bff817 	ldw	r2,-32(fp)
   45e28:	10800917 	ldw	r2,36(r2)
   45e2c:	e0fffc17 	ldw	r3,-16(fp)
   45e30:	d8c00015 	stw	r3,0(sp)
   45e34:	e1fffb17 	ldw	r7,-20(fp)
   45e38:	e1bffa17 	ldw	r6,-24(fp)
   45e3c:	e17ff917 	ldw	r5,-28(fp)
   45e40:	e13ff817 	ldw	r4,-32(fp)
   45e44:	103ee83a 	callr	r2
   45e48:	e0bffd15 	stw	r2,-12(fp)

/* remove dcache_flush call for FB330552  
  if(!ret_code)
      alt_dcache_flush((alt_u8*)fd->base_addr + data_offset, length);
*/
  return ret_code;
   45e4c:	e0bffd17 	ldw	r2,-12(fp)
   45e50:	e0bff715 	stw	r2,-36(fp)
        alt_flash_close_dev(fd);
   45e54:	e13ff617 	ldw	r4,-40(fp)
   45e58:	00498f00 	call	498f0 <alt_flash_close_dev>
        return ret_code;
   45e5c:	e0bff717 	ldw	r2,-36(fp)
    }
}
   45e60:	e037883a 	mov	sp,fp
   45e64:	dfc00117 	ldw	ra,4(sp)
   45e68:	df000017 	ldw	fp,0(sp)
   45e6c:	dec00204 	addi	sp,sp,8
   45e70:	f800283a 	ret

00045e74 <image_read>:

int image_read(int addr, unsigned char *data)
{
   45e74:	defff604 	addi	sp,sp,-40
   45e78:	dfc00915 	stw	ra,36(sp)
   45e7c:	df000815 	stw	fp,32(sp)
   45e80:	df000804 	addi	fp,sp,32
   45e84:	e13ffe15 	stw	r4,-8(fp)
   45e88:	e17fff15 	stw	r5,-4(fp)
    int           ret_code;
    alt_flash_fd *fd;

    fd = alt_flash_open_dev(EPCS_FLASH_NAME);
   45e8c:	01000174 	movhi	r4,5
   45e90:	2134e204 	addi	r4,r4,-11384
   45e94:	00498880 	call	49888 <alt_flash_open_dev>
   45e98:	e0bff815 	stw	r2,-32(fp)
    if(!fd)
   45e9c:	e0bff817 	ldw	r2,-32(fp)
   45ea0:	1000021e 	bne	r2,zero,45eac <image_read+0x38>
        return 0;
   45ea4:	0005883a 	mov	r2,zero
   45ea8:	00001306 	br	45ef8 <image_read+0x84>
   45eac:	e0bff817 	ldw	r2,-32(fp)
   45eb0:	e0bffa15 	stw	r2,-24(fp)
   45eb4:	e0bffe17 	ldw	r2,-8(fp)
   45eb8:	e0bffb15 	stw	r2,-20(fp)
   45ebc:	e0bfff17 	ldw	r2,-4(fp)
   45ec0:	e0bffc15 	stw	r2,-16(fp)
   45ec4:	00804004 	movi	r2,256
   45ec8:	e0bffd15 	stw	r2,-12(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_read_flash( 
                                      alt_flash_fd* fd, int offset, 
                                      void* dest_addr, int length )
{
  return fd->read( fd, offset, dest_addr, length );
   45ecc:	e0bffa17 	ldw	r2,-24(fp)
   45ed0:	10800617 	ldw	r2,24(r2)
   45ed4:	e1fffd17 	ldw	r7,-12(fp)
   45ed8:	e1bffc17 	ldw	r6,-16(fp)
   45edc:	e17ffb17 	ldw	r5,-20(fp)
   45ee0:	e13ffa17 	ldw	r4,-24(fp)
   45ee4:	103ee83a 	callr	r2
    else
    {
        ret_code = alt_read_flash(fd, addr, data, 256);
   45ee8:	e0bff915 	stw	r2,-28(fp)
        alt_flash_close_dev(fd);
   45eec:	e13ff817 	ldw	r4,-32(fp)
   45ef0:	00498f00 	call	498f0 <alt_flash_close_dev>

        return ret_code;
   45ef4:	e0bff917 	ldw	r2,-28(fp)
    }
}
   45ef8:	e037883a 	mov	sp,fp
   45efc:	dfc00117 	ldw	ra,4(sp)
   45f00:	df000017 	ldw	fp,0(sp)
   45f04:	dec00204 	addi	sp,sp,8
   45f08:	f800283a 	ret

00045f0c <image_erase>:

int image_erase(int block_offset)
{
   45f0c:	defff704 	addi	sp,sp,-36
   45f10:	dfc00815 	stw	ra,32(sp)
   45f14:	df000715 	stw	fp,28(sp)
   45f18:	df000704 	addi	fp,sp,28
   45f1c:	e13fff15 	stw	r4,-4(fp)
    int           ret_code;
    alt_flash_fd *fd;

    fd = alt_flash_open_dev(EPCS_FLASH_NAME);
   45f20:	01000174 	movhi	r4,5
   45f24:	2134e204 	addi	r4,r4,-11384
   45f28:	00498880 	call	49888 <alt_flash_open_dev>
   45f2c:	e0bff915 	stw	r2,-28(fp)
    if(!fd)
   45f30:	e0bff917 	ldw	r2,-28(fp)
   45f34:	1000021e 	bne	r2,zero,45f40 <image_erase+0x34>
        return 0;
   45f38:	0005883a 	mov	r2,zero
   45f3c:	00001206 	br	45f88 <image_erase+0x7c>
    else
    {
        ret_code = alt_erase_flash_block(fd, block_offset * EPCS_BLOCK_SIZE, EPCS_BLOCK_SIZE);
   45f40:	e0bfff17 	ldw	r2,-4(fp)
   45f44:	1004943a 	slli	r2,r2,16
   45f48:	e0fff917 	ldw	r3,-28(fp)
   45f4c:	e0fffb15 	stw	r3,-20(fp)
   45f50:	e0bffc15 	stw	r2,-16(fp)
   45f54:	00800074 	movhi	r2,1
   45f58:	e0bffd15 	stw	r2,-12(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_erase_flash_block( 
                                      alt_flash_fd* fd, int offset, int length) 
{
  int ret_code;
  ret_code = fd->erase_block( fd, offset );
   45f5c:	e0bffb17 	ldw	r2,-20(fp)
   45f60:	10800817 	ldw	r2,32(r2)
   45f64:	e17ffc17 	ldw	r5,-16(fp)
   45f68:	e13ffb17 	ldw	r4,-20(fp)
   45f6c:	103ee83a 	callr	r2
   45f70:	e0bffe15 	stw	r2,-8(fp)
  
/* remove dcache_flush call for FB330552  
  if(!ret_code)
      alt_dcache_flush((alt_u8*)fd->base_addr + offset, length);
*/
  return ret_code;
   45f74:	e0bffe17 	ldw	r2,-8(fp)
   45f78:	e0bffa15 	stw	r2,-24(fp)
        alt_flash_close_dev(fd);
   45f7c:	e13ff917 	ldw	r4,-28(fp)
   45f80:	00498f00 	call	498f0 <alt_flash_close_dev>
        return ret_code;
   45f84:	e0bffa17 	ldw	r2,-24(fp)
    }
}
   45f88:	e037883a 	mov	sp,fp
   45f8c:	dfc00117 	ldw	ra,4(sp)
   45f90:	df000017 	ldw	fp,0(sp)
   45f94:	dec00204 	addi	sp,sp,8
   45f98:	f800283a 	ret

00045f9c <string2hex>:
 * @param src 源字符串
 * @param len 源字符串长度
 * @param dest
 */
static void string2hex(const char *src, int len, char *dest)
{
   45f9c:	defffa04 	addi	sp,sp,-24
   45fa0:	df000515 	stw	fp,20(sp)
   45fa4:	df000504 	addi	fp,sp,20
   45fa8:	e13ffd15 	stw	r4,-12(fp)
   45fac:	e17ffe15 	stw	r5,-8(fp)
   45fb0:	e1bfff15 	stw	r6,-4(fp)
    int  i;
    char data[2];
    for(i = 0; i < len; i++)
   45fb4:	e03ffb15 	stw	zero,-20(fp)
   45fb8:	00001a06 	br	46024 <string2hex+0x88>
    {
        data[0] = *src++;  // 取出前面2个字符
   45fbc:	e0bffd17 	ldw	r2,-12(fp)
   45fc0:	10c00044 	addi	r3,r2,1
   45fc4:	e0fffd15 	stw	r3,-12(fp)
   45fc8:	10800003 	ldbu	r2,0(r2)
   45fcc:	e0bffc05 	stb	r2,-16(fp)
        data[1] = *src++;
   45fd0:	e0bffd17 	ldw	r2,-12(fp)
   45fd4:	10c00044 	addi	r3,r2,1
   45fd8:	e0fffd15 	stw	r3,-12(fp)
   45fdc:	10800003 	ldbu	r2,0(r2)
   45fe0:	e0bffc45 	stb	r2,-15(fp)
        //        *dest = strtol(data, &pEnd, 16);
        *dest = ((data[0] - 0x30) << 4) + (data[1] - 0x30);
   45fe4:	e0bffc03 	ldbu	r2,-16(fp)
   45fe8:	10bff404 	addi	r2,r2,-48
   45fec:	1004913a 	slli	r2,r2,4
   45ff0:	1007883a 	mov	r3,r2
   45ff4:	e0bffc43 	ldbu	r2,-15(fp)
   45ff8:	1885883a 	add	r2,r3,r2
   45ffc:	10bff404 	addi	r2,r2,-48
   46000:	1007883a 	mov	r3,r2
   46004:	e0bfff17 	ldw	r2,-4(fp)
   46008:	10c00005 	stb	r3,0(r2)
        dest++;
   4600c:	e0bfff17 	ldw	r2,-4(fp)
   46010:	10800044 	addi	r2,r2,1
   46014:	e0bfff15 	stw	r2,-4(fp)
 */
static void string2hex(const char *src, int len, char *dest)
{
    int  i;
    char data[2];
    for(i = 0; i < len; i++)
   46018:	e0bffb17 	ldw	r2,-20(fp)
   4601c:	10800044 	addi	r2,r2,1
   46020:	e0bffb15 	stw	r2,-20(fp)
   46024:	e0fffb17 	ldw	r3,-20(fp)
   46028:	e0bffe17 	ldw	r2,-8(fp)
   4602c:	18bfe316 	blt	r3,r2,45fbc <__alt_mem_epcs_flash+0xfffc4fbc>
        data[1] = *src++;
        //        *dest = strtol(data, &pEnd, 16);
        *dest = ((data[0] - 0x30) << 4) + (data[1] - 0x30);
        dest++;
    }
}
   46030:	0001883a 	nop
   46034:	e037883a 	mov	sp,fp
   46038:	df000017 	ldw	fp,0(sp)
   4603c:	dec00104 	addi	sp,sp,4
   46040:	f800283a 	ret

00046044 <find_index>:

static int find_index(char *str, int str_len, char **array, int length)
{
   46044:	defff804 	addi	sp,sp,-32
   46048:	dfc00715 	stw	ra,28(sp)
   4604c:	df000615 	stw	fp,24(sp)
   46050:	df000604 	addi	fp,sp,24
   46054:	e13ffc15 	stw	r4,-16(fp)
   46058:	e17ffd15 	stw	r5,-12(fp)
   4605c:	e1bffe15 	stw	r6,-8(fp)
   46060:	e1ffff15 	stw	r7,-4(fp)
    int i;
    int len;
    for(i = 0; i < length; i++)
   46064:	e03ffa15 	stw	zero,-24(fp)
   46068:	00001f06 	br	460e8 <find_index+0xa4>
    {
        len = strlen(array[i]);
   4606c:	e0bffa17 	ldw	r2,-24(fp)
   46070:	1085883a 	add	r2,r2,r2
   46074:	1085883a 	add	r2,r2,r2
   46078:	1007883a 	mov	r3,r2
   4607c:	e0bffe17 	ldw	r2,-8(fp)
   46080:	10c5883a 	add	r2,r2,r3
   46084:	10800017 	ldw	r2,0(r2)
   46088:	1009883a 	mov	r4,r2
   4608c:	00497200 	call	49720 <strlen>
   46090:	e0bffb15 	stw	r2,-20(fp)
        if(strncmp(str, array[i], str_len) == 0 && (len == str_len))
   46094:	e0bffa17 	ldw	r2,-24(fp)
   46098:	1085883a 	add	r2,r2,r2
   4609c:	1085883a 	add	r2,r2,r2
   460a0:	1007883a 	mov	r3,r2
   460a4:	e0bffe17 	ldw	r2,-8(fp)
   460a8:	10c5883a 	add	r2,r2,r3
   460ac:	10800017 	ldw	r2,0(r2)
   460b0:	e0fffd17 	ldw	r3,-12(fp)
   460b4:	180d883a 	mov	r6,r3
   460b8:	100b883a 	mov	r5,r2
   460bc:	e13ffc17 	ldw	r4,-16(fp)
   460c0:	00497b80 	call	497b8 <strncmp>
   460c4:	1000051e 	bne	r2,zero,460dc <find_index+0x98>
   460c8:	e0fffb17 	ldw	r3,-20(fp)
   460cc:	e0bffd17 	ldw	r2,-12(fp)
   460d0:	1880021e 	bne	r3,r2,460dc <find_index+0x98>
            return i;
   460d4:	e0bffa17 	ldw	r2,-24(fp)
   460d8:	00000706 	br	460f8 <find_index+0xb4>

static int find_index(char *str, int str_len, char **array, int length)
{
    int i;
    int len;
    for(i = 0; i < length; i++)
   460dc:	e0bffa17 	ldw	r2,-24(fp)
   460e0:	10800044 	addi	r2,r2,1
   460e4:	e0bffa15 	stw	r2,-24(fp)
   460e8:	e0fffa17 	ldw	r3,-24(fp)
   460ec:	e0bfff17 	ldw	r2,-4(fp)
   460f0:	18bfde16 	blt	r3,r2,4606c <__alt_mem_epcs_flash+0xfffc506c>
    {
        len = strlen(array[i]);
        if(strncmp(str, array[i], str_len) == 0 && (len == str_len))
            return i;
    }
    return -1;
   460f4:	00bfffc4 	movi	r2,-1
}
   460f8:	e037883a 	mov	sp,fp
   460fc:	dfc00117 	ldw	ra,4(sp)
   46100:	df000017 	ldw	fp,0(sp)
   46104:	dec00204 	addi	sp,sp,8
   46108:	f800283a 	ret

0004610c <sick_protocol_process>:

void sick_protocol_process(SOCKET s, unsigned char *buf, int len)
{
   4610c:	defff604 	addi	sp,sp,-40
   46110:	dfc00915 	stw	ra,36(sp)
   46114:	df000815 	stw	fp,32(sp)
   46118:	df000804 	addi	fp,sp,32
   4611c:	2005883a 	mov	r2,r4
   46120:	e17ffe15 	stw	r5,-8(fp)
   46124:	e1bfff15 	stw	r6,-4(fp)
   46128:	e0bffd05 	stb	r2,-12(fp)
    int            send_len;
    int            i;
    unsigned char  enable_flag  = 0;  //  enable = 1, 上传数据， enable = 2 停止上传数据
   4612c:	e03ff905 	stb	zero,-28(fp)
    unsigned char *recv_command = buf + 1;
   46130:	e0bffe17 	ldw	r2,-8(fp)
   46134:	10800044 	addi	r2,r2,1
   46138:	e0bffa15 	stw	r2,-24(fp)
    int            pos          = 0;
   4613c:	e03ffb15 	stw	zero,-20(fp)
    pos                         = find_index((char *)recv_command, len - 2, tim561_index, 572);
   46140:	e0bfff17 	ldw	r2,-4(fp)
   46144:	10bfff84 	addi	r2,r2,-2
   46148:	01c08f04 	movi	r7,572
   4614c:	018001b4 	movhi	r6,6
   46150:	31a8db04 	addi	r6,r6,-23700
   46154:	100b883a 	mov	r5,r2
   46158:	e13ffa17 	ldw	r4,-24(fp)
   4615c:	00460440 	call	46044 <find_index>
   46160:	e0bffb15 	stw	r2,-20(fp)
    if(pos != -1)  // 命令属于tim561协议
   46164:	e0bffb17 	ldw	r2,-20(fp)
   46168:	10bfffe0 	cmpeqi	r2,r2,-1
   4616c:	1001b91e 	bne	r2,zero,46854 <sick_protocol_process+0x748>
    {
        /*
         *  "sMI 0 3 F4724744" , "sMI 2"需要回复很多命令，需要特殊处理
         */
        if(strncmp((char *)recv_command, "sMI 0 3 F4724744", strlen((char *)"sMI 0 3 F4724744")) == 0)
   46170:	01800404 	movi	r6,16
   46174:	01400174 	movhi	r5,5
   46178:	2974e604 	addi	r5,r5,-11368
   4617c:	e13ffa17 	ldw	r4,-24(fp)
   46180:	00497b80 	call	497b8 <strncmp>
   46184:	1000701e 	bne	r2,zero,46348 <sick_protocol_process+0x23c>
        {
            if(SysPara.update_pos_flag == false)  //   没有上传数据时，sops软件电机点击stop measure响应下面数据
   46188:	008001b4 	movhi	r2,6
   4618c:	10a56c04 	addi	r2,r2,-27216
   46190:	10800003 	ldbu	r2,0(r2)
   46194:	1080005c 	xori	r2,r2,1
   46198:	10803fcc 	andi	r2,r2,255
   4619c:	10003526 	beq	r2,zero,46274 <sick_protocol_process+0x168>
            {
                for(i = 0; i < 2; i++)
   461a0:	e03ff815 	stw	zero,-32(fp)
   461a4:	00002f06 	br	46264 <sick_protocol_process+0x158>
                {
                    send_len = strlen(sMI_0_3_F4724744_start[i]);
   461a8:	008001b4 	movhi	r2,6
   461ac:	10b44404 	addi	r2,r2,-12016
   461b0:	e0fff817 	ldw	r3,-32(fp)
   461b4:	18c7883a 	add	r3,r3,r3
   461b8:	18c7883a 	add	r3,r3,r3
   461bc:	10c5883a 	add	r2,r2,r3
   461c0:	10800017 	ldw	r2,0(r2)
   461c4:	1009883a 	mov	r4,r2
   461c8:	00497200 	call	49720 <strlen>
   461cc:	e0bffc15 	stw	r2,-16(fp)
                    memcpy(send_buffer + 1, sMI_0_3_F4724744_start[i], send_len);
   461d0:	00c001b4 	movhi	r3,6
   461d4:	18c81044 	addi	r3,r3,8257
   461d8:	008001b4 	movhi	r2,6
   461dc:	10b44404 	addi	r2,r2,-12016
   461e0:	e13ff817 	ldw	r4,-32(fp)
   461e4:	2109883a 	add	r4,r4,r4
   461e8:	2109883a 	add	r4,r4,r4
   461ec:	1105883a 	add	r2,r2,r4
   461f0:	10800017 	ldw	r2,0(r2)
   461f4:	e13ffc17 	ldw	r4,-16(fp)
   461f8:	200d883a 	mov	r6,r4
   461fc:	100b883a 	mov	r5,r2
   46200:	1809883a 	mov	r4,r3
   46204:	00493d40 	call	493d4 <memcpy>
                    send_buffer[0]            = 0x02;
   46208:	008001b4 	movhi	r2,6
   4620c:	10881004 	addi	r2,r2,8256
   46210:	00c00084 	movi	r3,2
   46214:	10c00005 	stb	r3,0(r2)
                    send_buffer[send_len + 1] = 0x03;
   46218:	e0bffc17 	ldw	r2,-16(fp)
   4621c:	10c00044 	addi	r3,r2,1
   46220:	008001b4 	movhi	r2,6
   46224:	10881004 	addi	r2,r2,8256
   46228:	10c5883a 	add	r2,r2,r3
   4622c:	00c000c4 	movi	r3,3
   46230:	10c00005 	stb	r3,0(r2)
                    send(s, send_buffer, send_len + 2);
   46234:	e0bffd03 	ldbu	r2,-12(fp)
   46238:	e0fffc17 	ldw	r3,-16(fp)
   4623c:	18c00084 	addi	r3,r3,2
   46240:	18ffffcc 	andi	r3,r3,65535
   46244:	180d883a 	mov	r6,r3
   46248:	014001b4 	movhi	r5,6
   4624c:	29481004 	addi	r5,r5,8256
   46250:	1009883a 	mov	r4,r2
   46254:	004709c0 	call	4709c <send>
         */
        if(strncmp((char *)recv_command, "sMI 0 3 F4724744", strlen((char *)"sMI 0 3 F4724744")) == 0)
        {
            if(SysPara.update_pos_flag == false)  //   没有上传数据时，sops软件电机点击stop measure响应下面数据
            {
                for(i = 0; i < 2; i++)
   46258:	e0bff817 	ldw	r2,-32(fp)
   4625c:	10800044 	addi	r2,r2,1
   46260:	e0bff815 	stw	r2,-32(fp)
   46264:	e0bff817 	ldw	r2,-32(fp)
   46268:	10800090 	cmplti	r2,r2,2
   4626c:	103fce1e 	bne	r2,zero,461a8 <__alt_mem_epcs_flash+0xfffc51a8>
   46270:	00010406 	br	46684 <sick_protocol_process+0x578>
                    send(s, send_buffer, send_len + 2);
                }
            }
            else  // 上传数据
            {
                for(i = 0; i < 4; i++)
   46274:	e03ff815 	stw	zero,-32(fp)
   46278:	00002f06 	br	46338 <sick_protocol_process+0x22c>
                {
                    send_len = strlen(sMI_0_3_F4724744_stop[i]);
   4627c:	008001b4 	movhi	r2,6
   46280:	10ad5d04 	addi	r2,r2,-19084
   46284:	e0fff817 	ldw	r3,-32(fp)
   46288:	18c7883a 	add	r3,r3,r3
   4628c:	18c7883a 	add	r3,r3,r3
   46290:	10c5883a 	add	r2,r2,r3
   46294:	10800017 	ldw	r2,0(r2)
   46298:	1009883a 	mov	r4,r2
   4629c:	00497200 	call	49720 <strlen>
   462a0:	e0bffc15 	stw	r2,-16(fp)
                    memcpy(send_buffer + 1, sMI_0_3_F4724744_stop[i], send_len);
   462a4:	00c001b4 	movhi	r3,6
   462a8:	18c81044 	addi	r3,r3,8257
   462ac:	008001b4 	movhi	r2,6
   462b0:	10ad5d04 	addi	r2,r2,-19084
   462b4:	e13ff817 	ldw	r4,-32(fp)
   462b8:	2109883a 	add	r4,r4,r4
   462bc:	2109883a 	add	r4,r4,r4
   462c0:	1105883a 	add	r2,r2,r4
   462c4:	10800017 	ldw	r2,0(r2)
   462c8:	e13ffc17 	ldw	r4,-16(fp)
   462cc:	200d883a 	mov	r6,r4
   462d0:	100b883a 	mov	r5,r2
   462d4:	1809883a 	mov	r4,r3
   462d8:	00493d40 	call	493d4 <memcpy>
                    send_buffer[0]            = 0x02;
   462dc:	008001b4 	movhi	r2,6
   462e0:	10881004 	addi	r2,r2,8256
   462e4:	00c00084 	movi	r3,2
   462e8:	10c00005 	stb	r3,0(r2)
                    send_buffer[send_len + 1] = 0x03;
   462ec:	e0bffc17 	ldw	r2,-16(fp)
   462f0:	10c00044 	addi	r3,r2,1
   462f4:	008001b4 	movhi	r2,6
   462f8:	10881004 	addi	r2,r2,8256
   462fc:	10c5883a 	add	r2,r2,r3
   46300:	00c000c4 	movi	r3,3
   46304:	10c00005 	stb	r3,0(r2)
                    send(s, send_buffer, send_len + 2);
   46308:	e0bffd03 	ldbu	r2,-12(fp)
   4630c:	e0fffc17 	ldw	r3,-16(fp)
   46310:	18c00084 	addi	r3,r3,2
   46314:	18ffffcc 	andi	r3,r3,65535
   46318:	180d883a 	mov	r6,r3
   4631c:	014001b4 	movhi	r5,6
   46320:	29481004 	addi	r5,r5,8256
   46324:	1009883a 	mov	r4,r2
   46328:	004709c0 	call	4709c <send>
                    send(s, send_buffer, send_len + 2);
                }
            }
            else  // 上传数据
            {
                for(i = 0; i < 4; i++)
   4632c:	e0bff817 	ldw	r2,-32(fp)
   46330:	10800044 	addi	r2,r2,1
   46334:	e0bff815 	stw	r2,-32(fp)
   46338:	e0bff817 	ldw	r2,-32(fp)
   4633c:	10800110 	cmplti	r2,r2,4
   46340:	103fce1e 	bne	r2,zero,4627c <__alt_mem_epcs_flash+0xfffc527c>
   46344:	0000cf06 	br	46684 <sick_protocol_process+0x578>
                    send(s, send_buffer, send_len + 2);
                }
            }
        }

        else if(strncmp((char *)recv_command, "sMI 2", strlen((char *)"sMI 2")) == 0)
   46348:	01800144 	movi	r6,5
   4634c:	01400174 	movhi	r5,5
   46350:	2974eb04 	addi	r5,r5,-11348
   46354:	e13ffa17 	ldw	r4,-24(fp)
   46358:	00497b80 	call	497b8 <strncmp>
   4635c:	1000621e 	bne	r2,zero,464e8 <sick_protocol_process+0x3dc>
        {
            // if(SysStatus.update_pos_flag == false)
            if(sMI_3E_flag == 1)
   46360:	d0a01703 	ldbu	r2,-32676(gp)
   46364:	10803fcc 	andi	r2,r2,255
   46368:	10800058 	cmpnei	r2,r2,1
   4636c:	1000371e 	bne	r2,zero,4644c <sick_protocol_process+0x340>
            {
                for(i = 0; i < 11; i++)
   46370:	e03ff815 	stw	zero,-32(fp)
   46374:	00002f06 	br	46434 <sick_protocol_process+0x328>
                {
                    send_len = strlen(sMI_reply[i]);
   46378:	008001b4 	movhi	r2,6
   4637c:	10ae7704 	addi	r2,r2,-17956
   46380:	e0fff817 	ldw	r3,-32(fp)
   46384:	18c7883a 	add	r3,r3,r3
   46388:	18c7883a 	add	r3,r3,r3
   4638c:	10c5883a 	add	r2,r2,r3
   46390:	10800017 	ldw	r2,0(r2)
   46394:	1009883a 	mov	r4,r2
   46398:	00497200 	call	49720 <strlen>
   4639c:	e0bffc15 	stw	r2,-16(fp)
                    memcpy(send_buffer + 1, sMI_reply[i], send_len);
   463a0:	00c001b4 	movhi	r3,6
   463a4:	18c81044 	addi	r3,r3,8257
   463a8:	008001b4 	movhi	r2,6
   463ac:	10ae7704 	addi	r2,r2,-17956
   463b0:	e13ff817 	ldw	r4,-32(fp)
   463b4:	2109883a 	add	r4,r4,r4
   463b8:	2109883a 	add	r4,r4,r4
   463bc:	1105883a 	add	r2,r2,r4
   463c0:	10800017 	ldw	r2,0(r2)
   463c4:	e13ffc17 	ldw	r4,-16(fp)
   463c8:	200d883a 	mov	r6,r4
   463cc:	100b883a 	mov	r5,r2
   463d0:	1809883a 	mov	r4,r3
   463d4:	00493d40 	call	493d4 <memcpy>
                    send_buffer[0]            = 0x02;
   463d8:	008001b4 	movhi	r2,6
   463dc:	10881004 	addi	r2,r2,8256
   463e0:	00c00084 	movi	r3,2
   463e4:	10c00005 	stb	r3,0(r2)
                    send_buffer[send_len + 1] = 0x03;
   463e8:	e0bffc17 	ldw	r2,-16(fp)
   463ec:	10c00044 	addi	r3,r2,1
   463f0:	008001b4 	movhi	r2,6
   463f4:	10881004 	addi	r2,r2,8256
   463f8:	10c5883a 	add	r2,r2,r3
   463fc:	00c000c4 	movi	r3,3
   46400:	10c00005 	stb	r3,0(r2)
                    send(s, send_buffer, send_len + 2);
   46404:	e0bffd03 	ldbu	r2,-12(fp)
   46408:	e0fffc17 	ldw	r3,-16(fp)
   4640c:	18c00084 	addi	r3,r3,2
   46410:	18ffffcc 	andi	r3,r3,65535
   46414:	180d883a 	mov	r6,r3
   46418:	014001b4 	movhi	r5,6
   4641c:	29481004 	addi	r5,r5,8256
   46420:	1009883a 	mov	r4,r2
   46424:	004709c0 	call	4709c <send>
        else if(strncmp((char *)recv_command, "sMI 2", strlen((char *)"sMI 2")) == 0)
        {
            // if(SysStatus.update_pos_flag == false)
            if(sMI_3E_flag == 1)
            {
                for(i = 0; i < 11; i++)
   46428:	e0bff817 	ldw	r2,-32(fp)
   4642c:	10800044 	addi	r2,r2,1
   46430:	e0bff815 	stw	r2,-32(fp)
   46434:	e0bff817 	ldw	r2,-32(fp)
   46438:	108002d0 	cmplti	r2,r2,11
   4643c:	103fce1e 	bne	r2,zero,46378 <__alt_mem_epcs_flash+0xfffc5378>
                    memcpy(send_buffer + 1, sMI_reply[i], send_len);
                    send_buffer[0]            = 0x02;
                    send_buffer[send_len + 1] = 0x03;
                    send(s, send_buffer, send_len + 2);
                }
                enable_flag = 1;
   46440:	00800044 	movi	r2,1
   46444:	e0bff905 	stb	r2,-28(fp)
   46448:	00008e06 	br	46684 <sick_protocol_process+0x578>
            }
            else
            {
                send_len = strlen(sMI_reply[0]);
   4644c:	008001b4 	movhi	r2,6
   46450:	10ae7704 	addi	r2,r2,-17956
   46454:	10800017 	ldw	r2,0(r2)
   46458:	1009883a 	mov	r4,r2
   4645c:	00497200 	call	49720 <strlen>
   46460:	e0bffc15 	stw	r2,-16(fp)
                memcpy(send_buffer + 1, sMI_reply[0], send_len);
   46464:	00c001b4 	movhi	r3,6
   46468:	18c81044 	addi	r3,r3,8257
   4646c:	008001b4 	movhi	r2,6
   46470:	10ae7704 	addi	r2,r2,-17956
   46474:	10800017 	ldw	r2,0(r2)
   46478:	e13ffc17 	ldw	r4,-16(fp)
   4647c:	200d883a 	mov	r6,r4
   46480:	100b883a 	mov	r5,r2
   46484:	1809883a 	mov	r4,r3
   46488:	00493d40 	call	493d4 <memcpy>
                send_buffer[0]            = 0x02;
   4648c:	008001b4 	movhi	r2,6
   46490:	10881004 	addi	r2,r2,8256
   46494:	00c00084 	movi	r3,2
   46498:	10c00005 	stb	r3,0(r2)
                send_buffer[send_len + 1] = 0x03;
   4649c:	e0bffc17 	ldw	r2,-16(fp)
   464a0:	10c00044 	addi	r3,r2,1
   464a4:	008001b4 	movhi	r2,6
   464a8:	10881004 	addi	r2,r2,8256
   464ac:	10c5883a 	add	r2,r2,r3
   464b0:	00c000c4 	movi	r3,3
   464b4:	10c00005 	stb	r3,0(r2)
                send(s, send_buffer, send_len + 2);
   464b8:	e0bffd03 	ldbu	r2,-12(fp)
   464bc:	e0fffc17 	ldw	r3,-16(fp)
   464c0:	18c00084 	addi	r3,r3,2
   464c4:	18ffffcc 	andi	r3,r3,65535
   464c8:	180d883a 	mov	r6,r3
   464cc:	014001b4 	movhi	r5,6
   464d0:	29481004 	addi	r5,r5,8256
   464d4:	1009883a 	mov	r4,r2
   464d8:	004709c0 	call	4709c <send>
                enable_flag = 2;
   464dc:	00800084 	movi	r2,2
   464e0:	e0bff905 	stb	r2,-28(fp)
   464e4:	00006706 	br	46684 <sick_protocol_process+0x578>
        }
        /*
         * 正常的tim561协议中，数据分成两种：ascii格式和hex格式
         * 只需要从对应的表中找到需要回复的字符串响应上去就可以了
         */
        else if(tim561_respons[pos][0] == 0x30)  // hex字符串
   464e8:	008001b4 	movhi	r2,6
   464ec:	10ab1704 	addi	r2,r2,-21412
   464f0:	e0fffb17 	ldw	r3,-20(fp)
   464f4:	18c7883a 	add	r3,r3,r3
   464f8:	18c7883a 	add	r3,r3,r3
   464fc:	10c5883a 	add	r2,r2,r3
   46500:	10800017 	ldw	r2,0(r2)
   46504:	10800003 	ldbu	r2,0(r2)
   46508:	10803fcc 	andi	r2,r2,255
   4650c:	1080201c 	xori	r2,r2,128
   46510:	10bfe004 	addi	r2,r2,-128
   46514:	10800c18 	cmpnei	r2,r2,48
   46518:	1000211e 	bne	r2,zero,465a0 <sick_protocol_process+0x494>
        {
            send_len = strlen(tim561_respons[pos]);
   4651c:	008001b4 	movhi	r2,6
   46520:	10ab1704 	addi	r2,r2,-21412
   46524:	e0fffb17 	ldw	r3,-20(fp)
   46528:	18c7883a 	add	r3,r3,r3
   4652c:	18c7883a 	add	r3,r3,r3
   46530:	10c5883a 	add	r2,r2,r3
   46534:	10800017 	ldw	r2,0(r2)
   46538:	1009883a 	mov	r4,r2
   4653c:	00497200 	call	49720 <strlen>
   46540:	e0bffc15 	stw	r2,-16(fp)
            string2hex(tim561_respons[pos], send_len, (char *)send_buffer);
   46544:	008001b4 	movhi	r2,6
   46548:	10ab1704 	addi	r2,r2,-21412
   4654c:	e0fffb17 	ldw	r3,-20(fp)
   46550:	18c7883a 	add	r3,r3,r3
   46554:	18c7883a 	add	r3,r3,r3
   46558:	10c5883a 	add	r2,r2,r3
   4655c:	10800017 	ldw	r2,0(r2)
   46560:	018001b4 	movhi	r6,6
   46564:	31881004 	addi	r6,r6,8256
   46568:	e17ffc17 	ldw	r5,-16(fp)
   4656c:	1009883a 	mov	r4,r2
   46570:	0045f9c0 	call	45f9c <string2hex>
            send(s, send_buffer, send_len / 2);
   46574:	e13ffd03 	ldbu	r4,-12(fp)
   46578:	e0bffc17 	ldw	r2,-16(fp)
   4657c:	1006d7fa 	srli	r3,r2,31
   46580:	1885883a 	add	r2,r3,r2
   46584:	1005d07a 	srai	r2,r2,1
   46588:	10bfffcc 	andi	r2,r2,65535
   4658c:	100d883a 	mov	r6,r2
   46590:	014001b4 	movhi	r5,6
   46594:	29481004 	addi	r5,r5,8256
   46598:	004709c0 	call	4709c <send>
   4659c:	00003906 	br	46684 <sick_protocol_process+0x578>
        }
        else if(tim561_respons[pos][0] == 0x73)  // 's' 开头， ascii字符串
   465a0:	008001b4 	movhi	r2,6
   465a4:	10ab1704 	addi	r2,r2,-21412
   465a8:	e0fffb17 	ldw	r3,-20(fp)
   465ac:	18c7883a 	add	r3,r3,r3
   465b0:	18c7883a 	add	r3,r3,r3
   465b4:	10c5883a 	add	r2,r2,r3
   465b8:	10800017 	ldw	r2,0(r2)
   465bc:	10800003 	ldbu	r2,0(r2)
   465c0:	10803fcc 	andi	r2,r2,255
   465c4:	1080201c 	xori	r2,r2,128
   465c8:	10bfe004 	addi	r2,r2,-128
   465cc:	10801cd8 	cmpnei	r2,r2,115
   465d0:	10002c1e 	bne	r2,zero,46684 <sick_protocol_process+0x578>
        {
            send_len = strlen(tim561_respons[pos]);
   465d4:	008001b4 	movhi	r2,6
   465d8:	10ab1704 	addi	r2,r2,-21412
   465dc:	e0fffb17 	ldw	r3,-20(fp)
   465e0:	18c7883a 	add	r3,r3,r3
   465e4:	18c7883a 	add	r3,r3,r3
   465e8:	10c5883a 	add	r2,r2,r3
   465ec:	10800017 	ldw	r2,0(r2)
   465f0:	1009883a 	mov	r4,r2
   465f4:	00497200 	call	49720 <strlen>
   465f8:	e0bffc15 	stw	r2,-16(fp)
            memcpy(send_buffer + 1, tim561_respons[pos], send_len);
   465fc:	00c001b4 	movhi	r3,6
   46600:	18c81044 	addi	r3,r3,8257
   46604:	008001b4 	movhi	r2,6
   46608:	10ab1704 	addi	r2,r2,-21412
   4660c:	e13ffb17 	ldw	r4,-20(fp)
   46610:	2109883a 	add	r4,r4,r4
   46614:	2109883a 	add	r4,r4,r4
   46618:	1105883a 	add	r2,r2,r4
   4661c:	10800017 	ldw	r2,0(r2)
   46620:	e13ffc17 	ldw	r4,-16(fp)
   46624:	200d883a 	mov	r6,r4
   46628:	100b883a 	mov	r5,r2
   4662c:	1809883a 	mov	r4,r3
   46630:	00493d40 	call	493d4 <memcpy>
            send_buffer[0]            = 0x02;
   46634:	008001b4 	movhi	r2,6
   46638:	10881004 	addi	r2,r2,8256
   4663c:	00c00084 	movi	r3,2
   46640:	10c00005 	stb	r3,0(r2)
            send_buffer[send_len + 1] = 0x03;
   46644:	e0bffc17 	ldw	r2,-16(fp)
   46648:	10c00044 	addi	r3,r2,1
   4664c:	008001b4 	movhi	r2,6
   46650:	10881004 	addi	r2,r2,8256
   46654:	10c5883a 	add	r2,r2,r3
   46658:	00c000c4 	movi	r3,3
   4665c:	10c00005 	stb	r3,0(r2)
            send(s, send_buffer, send_len + 2);
   46660:	e0bffd03 	ldbu	r2,-12(fp)
   46664:	e0fffc17 	ldw	r3,-16(fp)
   46668:	18c00084 	addi	r3,r3,2
   4666c:	18ffffcc 	andi	r3,r3,65535
   46670:	180d883a 	mov	r6,r3
   46674:	014001b4 	movhi	r5,6
   46678:	29481004 	addi	r5,r5,8256
   4667c:	1009883a 	mov	r4,r2
   46680:	004709c0 	call	4709c <send>
        }

        if(strncmp((char *)recv_command, "sMI 3E", strlen((char *)"sMI 3E")) == 0)
   46684:	01800184 	movi	r6,6
   46688:	01400174 	movhi	r5,5
   4668c:	2974ed04 	addi	r5,r5,-11340
   46690:	e13ffa17 	ldw	r4,-24(fp)
   46694:	00497b80 	call	497b8 <strncmp>
   46698:	1000031e 	bne	r2,zero,466a8 <sick_protocol_process+0x59c>
        {
            sMI_3E_flag = 1;
   4669c:	00800044 	movi	r2,1
   466a0:	d0a01705 	stb	r2,-32676(gp)
   466a4:	00000706 	br	466c4 <sick_protocol_process+0x5b8>
        }
        else if(strncmp((char *)recv_command, "sMI 3F", strlen((char *)"sMI 3F")) == 0)
   466a8:	01800184 	movi	r6,6
   466ac:	01400174 	movhi	r5,5
   466b0:	2974ef04 	addi	r5,r5,-11332
   466b4:	e13ffa17 	ldw	r4,-24(fp)
   466b8:	00497b80 	call	497b8 <strncmp>
   466bc:	1000011e 	bne	r2,zero,466c4 <sick_protocol_process+0x5b8>
        {
            sMI_3E_flag = 0;
   466c0:	d0201705 	stb	zero,-32676(gp)
        }

        if(strncmp((char *)recv_command, "sRI E6", strlen((char *)"sRI E6")) == 0)  // 长字符串，分开处理
   466c4:	01800184 	movi	r6,6
   466c8:	01400174 	movhi	r5,5
   466cc:	2974f104 	addi	r5,r5,-11324
   466d0:	e13ffa17 	ldw	r4,-24(fp)
   466d4:	00497b80 	call	497b8 <strncmp>
   466d8:	1000291e 	bne	r2,zero,46780 <sick_protocol_process+0x674>
        {
            for(i = 0; i < 5; i++)
   466dc:	e03ff815 	stw	zero,-32(fp)
   466e0:	00002306 	br	46770 <sick_protocol_process+0x664>
            {
                send_len = strlen(sRI_E6_reply[i]);
   466e4:	008001b4 	movhi	r2,6
   466e8:	10ad6104 	addi	r2,r2,-19068
   466ec:	e0fff817 	ldw	r3,-32(fp)
   466f0:	18c7883a 	add	r3,r3,r3
   466f4:	18c7883a 	add	r3,r3,r3
   466f8:	10c5883a 	add	r2,r2,r3
   466fc:	10800017 	ldw	r2,0(r2)
   46700:	1009883a 	mov	r4,r2
   46704:	00497200 	call	49720 <strlen>
   46708:	e0bffc15 	stw	r2,-16(fp)
                string2hex(sRI_E6_reply[i], send_len, (char *)send_buffer);
   4670c:	008001b4 	movhi	r2,6
   46710:	10ad6104 	addi	r2,r2,-19068
   46714:	e0fff817 	ldw	r3,-32(fp)
   46718:	18c7883a 	add	r3,r3,r3
   4671c:	18c7883a 	add	r3,r3,r3
   46720:	10c5883a 	add	r2,r2,r3
   46724:	10800017 	ldw	r2,0(r2)
   46728:	018001b4 	movhi	r6,6
   4672c:	31881004 	addi	r6,r6,8256
   46730:	e17ffc17 	ldw	r5,-16(fp)
   46734:	1009883a 	mov	r4,r2
   46738:	0045f9c0 	call	45f9c <string2hex>
                send(s, send_buffer, send_len / 2);
   4673c:	e13ffd03 	ldbu	r4,-12(fp)
   46740:	e0bffc17 	ldw	r2,-16(fp)
   46744:	1006d7fa 	srli	r3,r2,31
   46748:	1885883a 	add	r2,r3,r2
   4674c:	1005d07a 	srai	r2,r2,1
   46750:	10bfffcc 	andi	r2,r2,65535
   46754:	100d883a 	mov	r6,r2
   46758:	014001b4 	movhi	r5,6
   4675c:	29481004 	addi	r5,r5,8256
   46760:	004709c0 	call	4709c <send>
            sMI_3E_flag = 0;
        }

        if(strncmp((char *)recv_command, "sRI E6", strlen((char *)"sRI E6")) == 0)  // 长字符串，分开处理
        {
            for(i = 0; i < 5; i++)
   46764:	e0bff817 	ldw	r2,-32(fp)
   46768:	10800044 	addi	r2,r2,1
   4676c:	e0bff815 	stw	r2,-32(fp)
   46770:	e0bff817 	ldw	r2,-32(fp)
   46774:	10800150 	cmplti	r2,r2,5
   46778:	103fda1e 	bne	r2,zero,466e4 <__alt_mem_epcs_flash+0xfffc56e4>
   4677c:	00003506 	br	46854 <sick_protocol_process+0x748>
                send_len = strlen(sRI_E6_reply[i]);
                string2hex(sRI_E6_reply[i], send_len, (char *)send_buffer);
                send(s, send_buffer, send_len / 2);
            }
        }
        else if(strncmp((char *)recv_command, "sRI 15B", strlen((char *)"sRI 15B")) == 0)
   46780:	018001c4 	movi	r6,7
   46784:	01400174 	movhi	r5,5
   46788:	2974f304 	addi	r5,r5,-11316
   4678c:	e13ffa17 	ldw	r4,-24(fp)
   46790:	00497b80 	call	497b8 <strncmp>
   46794:	1000151e 	bne	r2,zero,467ec <sick_protocol_process+0x6e0>
        {
            send_len = strlen(sRI_15B_reply);
   46798:	010001b4 	movhi	r4,6
   4679c:	212d6604 	addi	r4,r4,-19048
   467a0:	00497200 	call	49720 <strlen>
   467a4:	e0bffc15 	stw	r2,-16(fp)
            string2hex(sRI_15B_reply, send_len, (char *)send_buffer);
   467a8:	018001b4 	movhi	r6,6
   467ac:	31881004 	addi	r6,r6,8256
   467b0:	e17ffc17 	ldw	r5,-16(fp)
   467b4:	010001b4 	movhi	r4,6
   467b8:	212d6604 	addi	r4,r4,-19048
   467bc:	0045f9c0 	call	45f9c <string2hex>
            send(s, send_buffer, send_len / 2);
   467c0:	e13ffd03 	ldbu	r4,-12(fp)
   467c4:	e0bffc17 	ldw	r2,-16(fp)
   467c8:	1006d7fa 	srli	r3,r2,31
   467cc:	1885883a 	add	r2,r3,r2
   467d0:	1005d07a 	srai	r2,r2,1
   467d4:	10bfffcc 	andi	r2,r2,65535
   467d8:	100d883a 	mov	r6,r2
   467dc:	014001b4 	movhi	r5,6
   467e0:	29481004 	addi	r5,r5,8256
   467e4:	004709c0 	call	4709c <send>
   467e8:	00001a06 	br	46854 <sick_protocol_process+0x748>
        }
        else if(strncmp((char *)recv_command, "sRI 1DC", strlen((char *)"sRI 1DC")) == 0)
   467ec:	018001c4 	movi	r6,7
   467f0:	01400174 	movhi	r5,5
   467f4:	2974f504 	addi	r5,r5,-11308
   467f8:	e13ffa17 	ldw	r4,-24(fp)
   467fc:	00497b80 	call	497b8 <strncmp>
   46800:	1000141e 	bne	r2,zero,46854 <sick_protocol_process+0x748>
        {
            send_len = strlen(sRI_1DC_reply);
   46804:	010001b4 	movhi	r4,6
   46808:	212e4a04 	addi	r4,r4,-18136
   4680c:	00497200 	call	49720 <strlen>
   46810:	e0bffc15 	stw	r2,-16(fp)
            string2hex(sRI_1DC_reply, send_len, (char *)send_buffer);
   46814:	018001b4 	movhi	r6,6
   46818:	31881004 	addi	r6,r6,8256
   4681c:	e17ffc17 	ldw	r5,-16(fp)
   46820:	010001b4 	movhi	r4,6
   46824:	212e4a04 	addi	r4,r4,-18136
   46828:	0045f9c0 	call	45f9c <string2hex>
            send(s, send_buffer, send_len / 2);
   4682c:	e13ffd03 	ldbu	r4,-12(fp)
   46830:	e0bffc17 	ldw	r2,-16(fp)
   46834:	1006d7fa 	srli	r3,r2,31
   46838:	1885883a 	add	r2,r3,r2
   4683c:	1005d07a 	srai	r2,r2,1
   46840:	10bfffcc 	andi	r2,r2,65535
   46844:	100d883a 	mov	r6,r2
   46848:	014001b4 	movhi	r5,6
   4684c:	29481004 	addi	r5,r5,8256
   46850:	004709c0 	call	4709c <send>
        }
    }

    if(enable_flag == 1)  // 上传数据
   46854:	e0bff903 	ldbu	r2,-28(fp)
   46858:	10800058 	cmpnei	r2,r2,1
   4685c:	10000b1e 	bne	r2,zero,4688c <sick_protocol_process+0x780>
    {
        enable_flag = 0;
   46860:	e03ff905 	stb	zero,-28(fp)
        set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, ENABLE);
   46864:	01844474 	movhi	r6,4369
   46868:	31844444 	addi	r6,r6,4369
   4686c:	016c0014 	movui	r5,45056
   46870:	d1201604 	addi	r4,gp,-32680
   46874:	0042fa00 	call	42fa0 <set_laser_paramter>
        SysPara.update_pos_flag = true;
   46878:	008001b4 	movhi	r2,6
   4687c:	10a56c04 	addi	r2,r2,-27216
   46880:	00c00044 	movi	r3,1
   46884:	10c00005 	stb	r3,0(r2)
    {
        enable_flag = 0;
        set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, DISABLE);
        SysPara.update_pos_flag = false;
    }
}
   46888:	00000c06 	br	468bc <sick_protocol_process+0x7b0>
    {
        enable_flag = 0;
        set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, ENABLE);
        SysPara.update_pos_flag = true;
    }
    else if(enable_flag == 2)
   4688c:	e0bff903 	ldbu	r2,-28(fp)
   46890:	10800098 	cmpnei	r2,r2,2
   46894:	1000091e 	bne	r2,zero,468bc <sick_protocol_process+0x7b0>
    {
        enable_flag = 0;
   46898:	e03ff905 	stb	zero,-28(fp)
        set_laser_paramter(&Nios2FPGA_pck, UPLOAD_EN, DISABLE);
   4689c:	018888b4 	movhi	r6,8738
   468a0:	31888884 	addi	r6,r6,8738
   468a4:	016c0014 	movui	r5,45056
   468a8:	d1201604 	addi	r4,gp,-32680
   468ac:	0042fa00 	call	42fa0 <set_laser_paramter>
        SysPara.update_pos_flag = false;
   468b0:	008001b4 	movhi	r2,6
   468b4:	10a56c04 	addi	r2,r2,-27216
   468b8:	10000005 	stb	zero,0(r2)
    }
}
   468bc:	0001883a 	nop
   468c0:	e037883a 	mov	sp,fp
   468c4:	dfc00117 	ldw	ra,4(sp)
   468c8:	df000017 	ldw	fp,0(sp)
   468cc:	dec00204 	addi	sp,sp,8
   468d0:	f800283a 	ret

000468d4 <sick_pos_packet>:

void sick_pos_packet(void)
{
   468d4:	defffc04 	addi	sp,sp,-16
   468d8:	dfc00315 	stw	ra,12(sp)
   468dc:	df000215 	stw	fp,8(sp)
   468e0:	df000204 	addi	fp,sp,8
    int offset = 0;
   468e4:	e03ffe15 	stw	zero,-8(fp)
    int len    = 0;
   468e8:	e03fff15 	stw	zero,-4(fp)
    memset(send_buffer, 0, 8448);
   468ec:	01884004 	movi	r6,8448
   468f0:	000b883a 	mov	r5,zero
   468f4:	010001b4 	movhi	r4,6
   468f8:	21081004 	addi	r4,r4,8256
   468fc:	004951c0 	call	4951c <memset>
    send_buffer[0] = 0x02;
   46900:	008001b4 	movhi	r2,6
   46904:	10881004 	addi	r2,r2,8256
   46908:	00c00084 	movi	r3,2
   4690c:	10c00005 	stb	r3,0(r2)

    len = strlen(frame_start);  // 108
   46910:	010001b4 	movhi	r4,6
   46914:	21278004 	addi	r4,r4,-25088
   46918:	00497200 	call	49720 <strlen>
   4691c:	e0bfff15 	stw	r2,-4(fp)
    memcpy(send_buffer + 1, frame_start, len);
   46920:	008001b4 	movhi	r2,6
   46924:	10881044 	addi	r2,r2,8257
   46928:	e0ffff17 	ldw	r3,-4(fp)
   4692c:	180d883a 	mov	r6,r3
   46930:	014001b4 	movhi	r5,6
   46934:	29678004 	addi	r5,r5,-25088
   46938:	1009883a 	mov	r4,r2
   4693c:	00493d40 	call	493d4 <memcpy>
    offset = offset + len + 1;
   46940:	e0fffe17 	ldw	r3,-8(fp)
   46944:	e0bfff17 	ldw	r2,-4(fp)
   46948:	1885883a 	add	r2,r3,r2
   4694c:	10800044 	addi	r2,r2,1
   46950:	e0bffe15 	stw	r2,-8(fp)

    memcpy(send_buffer + offset, CycleData.distance_data,
   46954:	e0fffe17 	ldw	r3,-8(fp)
   46958:	008001b4 	movhi	r2,6
   4695c:	10881004 	addi	r2,r2,8256
   46960:	1887883a 	add	r3,r3,r2
   46964:	008001b4 	movhi	r2,6
   46968:	10802104 	addi	r2,r2,132
   4696c:	10800117 	ldw	r2,4(r2)
   46970:	100d883a 	mov	r6,r2
   46974:	014001b4 	movhi	r5,6
   46978:	29402404 	addi	r5,r5,144
   4697c:	1809883a 	mov	r4,r3
   46980:	00493d40 	call	493d4 <memcpy>
           CycleData.distance_len);  // 4055
    offset = offset + CycleData.distance_len;
   46984:	008001b4 	movhi	r2,6
   46988:	10802104 	addi	r2,r2,132
   4698c:	10c00117 	ldw	r3,4(r2)
   46990:	e0bffe17 	ldw	r2,-8(fp)
   46994:	1885883a 	add	r2,r3,r2
   46998:	e0bffe15 	stw	r2,-8(fp)

    len = strlen(RSSI_Field_start);                       // 41
   4699c:	010001b4 	movhi	r4,6
   469a0:	21279c04 	addi	r4,r4,-24976
   469a4:	00497200 	call	49720 <strlen>
   469a8:	e0bfff15 	stw	r2,-4(fp)
    memcpy(send_buffer + offset, RSSI_Field_start, len);  // frame_end放到后面
   469ac:	e0fffe17 	ldw	r3,-8(fp)
   469b0:	008001b4 	movhi	r2,6
   469b4:	10881004 	addi	r2,r2,8256
   469b8:	1885883a 	add	r2,r3,r2
   469bc:	e0ffff17 	ldw	r3,-4(fp)
   469c0:	180d883a 	mov	r6,r3
   469c4:	014001b4 	movhi	r5,6
   469c8:	29679c04 	addi	r5,r5,-24976
   469cc:	1009883a 	mov	r4,r2
   469d0:	00493d40 	call	493d4 <memcpy>
    offset = offset + len;
   469d4:	e0fffe17 	ldw	r3,-8(fp)
   469d8:	e0bfff17 	ldw	r2,-4(fp)
   469dc:	1885883a 	add	r2,r3,r2
   469e0:	e0bffe15 	stw	r2,-8(fp)

    memcpy(send_buffer + offset, CycleData.gray_data,
   469e4:	e0fffe17 	ldw	r3,-8(fp)
   469e8:	008001b4 	movhi	r2,6
   469ec:	10881004 	addi	r2,r2,8256
   469f0:	1887883a 	add	r3,r3,r2
   469f4:	008001b4 	movhi	r2,6
   469f8:	10802104 	addi	r2,r2,132
   469fc:	10800217 	ldw	r2,8(r2)
   46a00:	100d883a 	mov	r6,r2
   46a04:	014001b4 	movhi	r5,6
   46a08:	294419c4 	addi	r5,r5,4199
   46a0c:	1809883a 	mov	r4,r3
   46a10:	00493d40 	call	493d4 <memcpy>
           CycleData.gray_len);  // 4055
    offset = offset + CycleData.gray_len;
   46a14:	008001b4 	movhi	r2,6
   46a18:	10802104 	addi	r2,r2,132
   46a1c:	10c00217 	ldw	r3,8(r2)
   46a20:	e0bffe17 	ldw	r2,-8(fp)
   46a24:	1885883a 	add	r2,r3,r2
   46a28:	e0bffe15 	stw	r2,-8(fp)

    len = strlen(RSSI_Field_end);                       // 12
   46a2c:	010001b4 	movhi	r4,6
   46a30:	2127a704 	addi	r4,r4,-24932
   46a34:	00497200 	call	49720 <strlen>
   46a38:	e0bfff15 	stw	r2,-4(fp)
    memcpy(send_buffer + offset, RSSI_Field_end, len);  // frame_end放到后面
   46a3c:	e0fffe17 	ldw	r3,-8(fp)
   46a40:	008001b4 	movhi	r2,6
   46a44:	10881004 	addi	r2,r2,8256
   46a48:	1885883a 	add	r2,r3,r2
   46a4c:	e0ffff17 	ldw	r3,-4(fp)
   46a50:	180d883a 	mov	r6,r3
   46a54:	014001b4 	movhi	r5,6
   46a58:	2967a704 	addi	r5,r5,-24932
   46a5c:	1009883a 	mov	r4,r2
   46a60:	00493d40 	call	493d4 <memcpy>
    offset = offset + len;
   46a64:	e0fffe17 	ldw	r3,-8(fp)
   46a68:	e0bfff17 	ldw	r2,-4(fp)
   46a6c:	1885883a 	add	r2,r3,r2
   46a70:	e0bffe15 	stw	r2,-8(fp)

    send_buffer[offset] = 0x03;
   46a74:	008001b4 	movhi	r2,6
   46a78:	10881004 	addi	r2,r2,8256
   46a7c:	e0fffe17 	ldw	r3,-8(fp)
   46a80:	10c5883a 	add	r2,r2,r3
   46a84:	00c000c4 	movi	r3,3
   46a88:	10c00005 	stb	r3,0(r2)
}
   46a8c:	0001883a 	nop
   46a90:	e037883a 	mov	sp,fp
   46a94:	dfc00117 	ldw	ra,4(sp)
   46a98:	df000017 	ldw	fp,0(sp)
   46a9c:	dec00204 	addi	sp,sp,8
   46aa0:	f800283a 	ret

00046aa4 <socket>:
/**
  @brief   This Socket function initialize the channel in perticular mode, and set the port and wait for W5200 done it.
  @return  1 for sucess else 0.
  */
uint8 socket(SOCKET s, uint8 protocol, uint16 port, uint8 flag)
{
   46aa4:	defff904 	addi	sp,sp,-28
   46aa8:	dfc00615 	stw	ra,24(sp)
   46aac:	df000515 	stw	fp,20(sp)
   46ab0:	df000504 	addi	fp,sp,20
   46ab4:	2011883a 	mov	r8,r4
   46ab8:	2809883a 	mov	r4,r5
   46abc:	3007883a 	mov	r3,r6
   46ac0:	3805883a 	mov	r2,r7
   46ac4:	e23ffc05 	stb	r8,-16(fp)
   46ac8:	e13ffd05 	stb	r4,-12(fp)
   46acc:	e0fffe0d 	sth	r3,-8(fp)
   46ad0:	e0bfff05 	stb	r2,-4(fp)
    uint8 ret;
    if (
            ((protocol&0x0F) == Sn_MR_TCP)    ||
   46ad4:	e0bffd03 	ldbu	r2,-12(fp)
   46ad8:	108003cc 	andi	r2,r2,15
  @return  1 for sucess else 0.
  */
uint8 socket(SOCKET s, uint8 protocol, uint16 port, uint8 flag)
{
    uint8 ret;
    if (
   46adc:	10800060 	cmpeqi	r2,r2,1
   46ae0:	1000101e 	bne	r2,zero,46b24 <socket+0x80>
            ((protocol&0x0F) == Sn_MR_TCP)    ||
            ((protocol&0x0F) == Sn_MR_UDP)    ||
   46ae4:	e0bffd03 	ldbu	r2,-12(fp)
   46ae8:	108003cc 	andi	r2,r2,15
  */
uint8 socket(SOCKET s, uint8 protocol, uint16 port, uint8 flag)
{
    uint8 ret;
    if (
            ((protocol&0x0F) == Sn_MR_TCP)    ||
   46aec:	108000a0 	cmpeqi	r2,r2,2
   46af0:	10000c1e 	bne	r2,zero,46b24 <socket+0x80>
            ((protocol&0x0F) == Sn_MR_UDP)    ||
            ((protocol&0x0F) == Sn_MR_IPRAW)  ||
   46af4:	e0bffd03 	ldbu	r2,-12(fp)
   46af8:	108003cc 	andi	r2,r2,15
uint8 socket(SOCKET s, uint8 protocol, uint16 port, uint8 flag)
{
    uint8 ret;
    if (
            ((protocol&0x0F) == Sn_MR_TCP)    ||
            ((protocol&0x0F) == Sn_MR_UDP)    ||
   46afc:	108000e0 	cmpeqi	r2,r2,3
   46b00:	1000081e 	bne	r2,zero,46b24 <socket+0x80>
            ((protocol&0x0F) == Sn_MR_IPRAW)  ||
            ((protocol&0x0F) == Sn_MR_MACRAW) ||
   46b04:	e0bffd03 	ldbu	r2,-12(fp)
   46b08:	108003cc 	andi	r2,r2,15
{
    uint8 ret;
    if (
            ((protocol&0x0F) == Sn_MR_TCP)    ||
            ((protocol&0x0F) == Sn_MR_UDP)    ||
            ((protocol&0x0F) == Sn_MR_IPRAW)  ||
   46b0c:	10800120 	cmpeqi	r2,r2,4
   46b10:	1000041e 	bne	r2,zero,46b24 <socket+0x80>
            ((protocol&0x0F) == Sn_MR_MACRAW) ||
            ((protocol&0x0F) == Sn_MR_PPPOE)
   46b14:	e0bffd03 	ldbu	r2,-12(fp)
   46b18:	108003cc 	andi	r2,r2,15
    uint8 ret;
    if (
            ((protocol&0x0F) == Sn_MR_TCP)    ||
            ((protocol&0x0F) == Sn_MR_UDP)    ||
            ((protocol&0x0F) == Sn_MR_IPRAW)  ||
            ((protocol&0x0F) == Sn_MR_MACRAW) ||
   46b1c:	10800158 	cmpnei	r2,r2,5
   46b20:	10004b1e 	bne	r2,zero,46c50 <socket+0x1ac>
            ((protocol&0x0F) == Sn_MR_PPPOE)
       )
    {
        close_socket(s);
   46b24:	e0bffc03 	ldbu	r2,-16(fp)
   46b28:	1009883a 	mov	r4,r2
   46b2c:	0046c6c0 	call	46c6c <close_socket>
        IINCHIP_WRITE(Sn_MR(s) ,protocol | flag);
   46b30:	e0bffc03 	ldbu	r2,-16(fp)
   46b34:	1004917a 	slli	r2,r2,5
   46b38:	10800204 	addi	r2,r2,8
   46b3c:	1009883a 	mov	r4,r2
   46b40:	e0fffd03 	ldbu	r3,-12(fp)
   46b44:	e0bfff03 	ldbu	r2,-4(fp)
   46b48:	1884b03a 	or	r2,r3,r2
   46b4c:	10803fcc 	andi	r2,r2,255
   46b50:	100b883a 	mov	r5,r2
   46b54:	00481840 	call	48184 <IINCHIP_WRITE>
        if (port != 0) {
   46b58:	e0bffe0b 	ldhu	r2,-8(fp)
   46b5c:	10001426 	beq	r2,zero,46bb0 <socket+0x10c>
            IINCHIP_WRITE( Sn_PORT0(s) ,(uint8)((port & 0xff00) >> 8));
   46b60:	e0bffc03 	ldbu	r2,-16(fp)
   46b64:	1004917a 	slli	r2,r2,5
   46b68:	10810204 	addi	r2,r2,1032
   46b6c:	1007883a 	mov	r3,r2
   46b70:	e0bffe0b 	ldhu	r2,-8(fp)
   46b74:	1004d23a 	srli	r2,r2,8
   46b78:	10803fcc 	andi	r2,r2,255
   46b7c:	100b883a 	mov	r5,r2
   46b80:	1809883a 	mov	r4,r3
   46b84:	00481840 	call	48184 <IINCHIP_WRITE>
            IINCHIP_WRITE( Sn_PORT1(s) ,(uint8)(port & 0x00ff));
   46b88:	e0bffc03 	ldbu	r2,-16(fp)
   46b8c:	1004917a 	slli	r2,r2,5
   46b90:	10814204 	addi	r2,r2,1288
   46b94:	1007883a 	mov	r3,r2
   46b98:	e0bffe0b 	ldhu	r2,-8(fp)
   46b9c:	10803fcc 	andi	r2,r2,255
   46ba0:	100b883a 	mov	r5,r2
   46ba4:	1809883a 	mov	r4,r3
   46ba8:	00481840 	call	48184 <IINCHIP_WRITE>
   46bac:	00001706 	br	46c0c <socket+0x168>
        } else {
            local_port++; // if don't set the source port, set local_port number.
   46bb0:	d0a0178b 	ldhu	r2,-32674(gp)
   46bb4:	10800044 	addi	r2,r2,1
   46bb8:	d0a0178d 	sth	r2,-32674(gp)
            IINCHIP_WRITE(Sn_PORT0(s) ,(uint8)((local_port & 0xff00) >> 8));
   46bbc:	e0bffc03 	ldbu	r2,-16(fp)
   46bc0:	1004917a 	slli	r2,r2,5
   46bc4:	10810204 	addi	r2,r2,1032
   46bc8:	1007883a 	mov	r3,r2
   46bcc:	d0a0178b 	ldhu	r2,-32674(gp)
   46bd0:	10bfffcc 	andi	r2,r2,65535
   46bd4:	1004d23a 	srli	r2,r2,8
   46bd8:	10803fcc 	andi	r2,r2,255
   46bdc:	100b883a 	mov	r5,r2
   46be0:	1809883a 	mov	r4,r3
   46be4:	00481840 	call	48184 <IINCHIP_WRITE>
            IINCHIP_WRITE(Sn_PORT1(s) ,(uint8)(local_port & 0x00ff));
   46be8:	e0bffc03 	ldbu	r2,-16(fp)
   46bec:	1004917a 	slli	r2,r2,5
   46bf0:	10814204 	addi	r2,r2,1288
   46bf4:	1007883a 	mov	r3,r2
   46bf8:	d0a0178b 	ldhu	r2,-32674(gp)
   46bfc:	10803fcc 	andi	r2,r2,255
   46c00:	100b883a 	mov	r5,r2
   46c04:	1809883a 	mov	r4,r3
   46c08:	00481840 	call	48184 <IINCHIP_WRITE>
        }
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_OPEN); // run sockinit Sn_CR
   46c0c:	e0bffc03 	ldbu	r2,-16(fp)
   46c10:	1004917a 	slli	r2,r2,5
   46c14:	10804204 	addi	r2,r2,264
   46c18:	01400044 	movi	r5,1
   46c1c:	1009883a 	mov	r4,r2
   46c20:	00481840 	call	48184 <IINCHIP_WRITE>

        /* wait to process the command... */
        while( IINCHIP_READ(Sn_CR(s)) )
   46c24:	0001883a 	nop
   46c28:	e0bffc03 	ldbu	r2,-16(fp)
   46c2c:	1004917a 	slli	r2,r2,5
   46c30:	10804204 	addi	r2,r2,264
   46c34:	1009883a 	mov	r4,r2
   46c38:	00482100 	call	48210 <IINCHIP_READ>
   46c3c:	10803fcc 	andi	r2,r2,255
   46c40:	103ff91e 	bne	r2,zero,46c28 <__alt_mem_epcs_flash+0xfffc5c28>
            ;
        /* ------- */
        ret = 1;
   46c44:	00800044 	movi	r2,1
   46c48:	e0bffb05 	stb	r2,-20(fp)
   46c4c:	00000106 	br	46c54 <socket+0x1b0>
    }
    else
    {
        ret = 0;
   46c50:	e03ffb05 	stb	zero,-20(fp)
    }
    return ret;
   46c54:	e0bffb03 	ldbu	r2,-20(fp)
}
   46c58:	e037883a 	mov	sp,fp
   46c5c:	dfc00117 	ldw	ra,4(sp)
   46c60:	df000017 	ldw	fp,0(sp)
   46c64:	dec00204 	addi	sp,sp,8
   46c68:	f800283a 	ret

00046c6c <close_socket>:

/**
  @brief   This function close_socket the socket and parameter is "s" which represent the socket number
  */
void close_socket(SOCKET s)
{
   46c6c:	defffd04 	addi	sp,sp,-12
   46c70:	dfc00215 	stw	ra,8(sp)
   46c74:	df000115 	stw	fp,4(sp)
   46c78:	df000104 	addi	fp,sp,4
   46c7c:	2005883a 	mov	r2,r4
   46c80:	e0bfff05 	stb	r2,-4(fp)

    IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_CLOSE);
   46c84:	e0bfff03 	ldbu	r2,-4(fp)
   46c88:	1004917a 	slli	r2,r2,5
   46c8c:	10804204 	addi	r2,r2,264
   46c90:	01400404 	movi	r5,16
   46c94:	1009883a 	mov	r4,r2
   46c98:	00481840 	call	48184 <IINCHIP_WRITE>

    /* wait to process the command... */
    while( IINCHIP_READ(Sn_CR(s) ) )
   46c9c:	0001883a 	nop
   46ca0:	e0bfff03 	ldbu	r2,-4(fp)
   46ca4:	1004917a 	slli	r2,r2,5
   46ca8:	10804204 	addi	r2,r2,264
   46cac:	1009883a 	mov	r4,r2
   46cb0:	00482100 	call	48210 <IINCHIP_READ>
   46cb4:	10803fcc 	andi	r2,r2,255
   46cb8:	103ff91e 	bne	r2,zero,46ca0 <__alt_mem_epcs_flash+0xfffc5ca0>
        ;
    /* ------- */
    /* all clear */
    IINCHIP_WRITE( Sn_IR(s) , 0xFF);
   46cbc:	e0bfff03 	ldbu	r2,-4(fp)
   46cc0:	1004917a 	slli	r2,r2,5
   46cc4:	10808204 	addi	r2,r2,520
   46cc8:	01403fc4 	movi	r5,255
   46ccc:	1009883a 	mov	r4,r2
   46cd0:	00481840 	call	48184 <IINCHIP_WRITE>
}
   46cd4:	0001883a 	nop
   46cd8:	e037883a 	mov	sp,fp
   46cdc:	dfc00117 	ldw	ra,4(sp)
   46ce0:	df000017 	ldw	fp,0(sp)
   46ce4:	dec00204 	addi	sp,sp,8
   46ce8:	f800283a 	ret

00046cec <listen>:
/**
  @brief   This function established  the connection for the channel in passive (server) mode. This function waits for the request from the peer.
  @return  1 for success else 0.
  */
uint8 listen(SOCKET s)
{
   46cec:	defffc04 	addi	sp,sp,-16
   46cf0:	dfc00315 	stw	ra,12(sp)
   46cf4:	df000215 	stw	fp,8(sp)
   46cf8:	df000204 	addi	fp,sp,8
   46cfc:	2005883a 	mov	r2,r4
   46d00:	e0bfff05 	stb	r2,-4(fp)
    uint8 ret;			// 定义一个监听标志位，若Sn_CR的LISTEN命令发送成功，其值为1，否则为0

    if (IINCHIP_READ( Sn_SR(s) ) == SOCK_INIT)		// 若Sn_SR处于初始化状态，进入循环
   46d04:	e0bfff03 	ldbu	r2,-4(fp)
   46d08:	1004917a 	slli	r2,r2,5
   46d0c:	1080c204 	addi	r2,r2,776
   46d10:	1009883a 	mov	r4,r2
   46d14:	00482100 	call	48210 <IINCHIP_READ>
   46d18:	10803fcc 	andi	r2,r2,255
   46d1c:	108004d8 	cmpnei	r2,r2,19
   46d20:	1000111e 	bne	r2,zero,46d68 <listen+0x7c>
    {
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_LISTEN);		// MCU配置W5500为监听状态
   46d24:	e0bfff03 	ldbu	r2,-4(fp)
   46d28:	1004917a 	slli	r2,r2,5
   46d2c:	10804204 	addi	r2,r2,264
   46d30:	01400084 	movi	r5,2
   46d34:	1009883a 	mov	r4,r2
   46d38:	00481840 	call	48184 <IINCHIP_WRITE>

        while( IINCHIP_READ(Sn_CR(s) ) )					// 配置完成，Sn_CR自动清零
   46d3c:	0001883a 	nop
   46d40:	e0bfff03 	ldbu	r2,-4(fp)
   46d44:	1004917a 	slli	r2,r2,5
   46d48:	10804204 	addi	r2,r2,264
   46d4c:	1009883a 	mov	r4,r2
   46d50:	00482100 	call	48210 <IINCHIP_READ>
   46d54:	10803fcc 	andi	r2,r2,255
   46d58:	103ff91e 	bne	r2,zero,46d40 <__alt_mem_epcs_flash+0xfffc5d40>
            ;
        ret = 1;																	// LISTEN命令发送成功，ret=1
   46d5c:	00800044 	movi	r2,1
   46d60:	e0bffe05 	stb	r2,-8(fp)
   46d64:	00000106 	br	46d6c <listen+0x80>
    }
    else
    {
        ret = 0;																	// 否则，ret=0
   46d68:	e03ffe05 	stb	zero,-8(fp)
    }
    return ret;
   46d6c:	e0bffe03 	ldbu	r2,-8(fp)
}
   46d70:	e037883a 	mov	sp,fp
   46d74:	dfc00117 	ldw	ra,4(sp)
   46d78:	df000017 	ldw	fp,0(sp)
   46d7c:	dec00204 	addi	sp,sp,8
   46d80:	f800283a 	ret

00046d84 <connect>:
  This function waits for the untill the connection is established.

  @return  1 for success else 0.
  */
uint8 connect(SOCKET s, uint8 * addr, uint16 port)
{
   46d84:	defffa04 	addi	sp,sp,-24
   46d88:	dfc00515 	stw	ra,20(sp)
   46d8c:	df000415 	stw	fp,16(sp)
   46d90:	df000404 	addi	fp,sp,16
   46d94:	2007883a 	mov	r3,r4
   46d98:	e17ffe15 	stw	r5,-8(fp)
   46d9c:	3005883a 	mov	r2,r6
   46da0:	e0fffd05 	stb	r3,-12(fp)
   46da4:	e0bfff0d 	sth	r2,-4(fp)
    uint8 ret;
    if
        (
         ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
   46da8:	e0bffe17 	ldw	r2,-8(fp)
   46dac:	10800003 	ldbu	r2,0(r2)
  */
uint8 connect(SOCKET s, uint8 * addr, uint16 port)
{
    uint8 ret;
    if
        (
   46db0:	10803fcc 	andi	r2,r2,255
   46db4:	10803fd8 	cmpnei	r2,r2,255
   46db8:	1000121e 	bne	r2,zero,46e04 <connect+0x80>
         ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
   46dbc:	e0bffe17 	ldw	r2,-8(fp)
   46dc0:	10800044 	addi	r2,r2,1
   46dc4:	10800003 	ldbu	r2,0(r2)
   46dc8:	10803fcc 	andi	r2,r2,255
   46dcc:	10803fd8 	cmpnei	r2,r2,255
   46dd0:	10000c1e 	bne	r2,zero,46e04 <connect+0x80>
   46dd4:	e0bffe17 	ldw	r2,-8(fp)
   46dd8:	10800084 	addi	r2,r2,2
   46ddc:	10800003 	ldbu	r2,0(r2)
   46de0:	10803fcc 	andi	r2,r2,255
   46de4:	10803fd8 	cmpnei	r2,r2,255
   46de8:	1000061e 	bne	r2,zero,46e04 <connect+0x80>
   46dec:	e0bffe17 	ldw	r2,-8(fp)
   46df0:	108000c4 	addi	r2,r2,3
   46df4:	10800003 	ldbu	r2,0(r2)
   46df8:	10803fcc 	andi	r2,r2,255
   46dfc:	10803fe0 	cmpeqi	r2,r2,255
   46e00:	1000151e 	bne	r2,zero,46e58 <connect+0xd4>
         ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
   46e04:	e0bffe17 	ldw	r2,-8(fp)
   46e08:	10800003 	ldbu	r2,0(r2)
uint8 connect(SOCKET s, uint8 * addr, uint16 port)
{
    uint8 ret;
    if
        (
         ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
   46e0c:	10803fcc 	andi	r2,r2,255
   46e10:	10000f1e 	bne	r2,zero,46e50 <connect+0xcc>
         ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
   46e14:	e0bffe17 	ldw	r2,-8(fp)
   46e18:	10800044 	addi	r2,r2,1
   46e1c:	10800003 	ldbu	r2,0(r2)
   46e20:	10803fcc 	andi	r2,r2,255
   46e24:	10000a1e 	bne	r2,zero,46e50 <connect+0xcc>
   46e28:	e0bffe17 	ldw	r2,-8(fp)
   46e2c:	10800084 	addi	r2,r2,2
   46e30:	10800003 	ldbu	r2,0(r2)
   46e34:	10803fcc 	andi	r2,r2,255
   46e38:	1000051e 	bne	r2,zero,46e50 <connect+0xcc>
   46e3c:	e0bffe17 	ldw	r2,-8(fp)
   46e40:	108000c4 	addi	r2,r2,3
   46e44:	10800003 	ldbu	r2,0(r2)
   46e48:	10803fcc 	andi	r2,r2,255
   46e4c:	10000226 	beq	r2,zero,46e58 <connect+0xd4>
   46e50:	e0bfff0b 	ldhu	r2,-4(fp)
   46e54:	1000021e 	bne	r2,zero,46e60 <connect+0xdc>
         (port == 0x00)
        )
        {
            ret = 0;
   46e58:	e03ffc05 	stb	zero,-16(fp)
   46e5c:	00006f06 	br	4701c <connect+0x298>
        }
    else
    {
        ret = 1;
   46e60:	00800044 	movi	r2,1
   46e64:	e0bffc05 	stb	r2,-16(fp)
        // set destination IP
        IINCHIP_WRITE( Sn_DIPR0(s), addr[0]);
   46e68:	e0bffd03 	ldbu	r2,-12(fp)
   46e6c:	1004917a 	slli	r2,r2,5
   46e70:	10830204 	addi	r2,r2,3080
   46e74:	1007883a 	mov	r3,r2
   46e78:	e0bffe17 	ldw	r2,-8(fp)
   46e7c:	10800003 	ldbu	r2,0(r2)
   46e80:	10803fcc 	andi	r2,r2,255
   46e84:	100b883a 	mov	r5,r2
   46e88:	1809883a 	mov	r4,r3
   46e8c:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DIPR1(s), addr[1]);
   46e90:	e0bffd03 	ldbu	r2,-12(fp)
   46e94:	1004917a 	slli	r2,r2,5
   46e98:	10834204 	addi	r2,r2,3336
   46e9c:	1007883a 	mov	r3,r2
   46ea0:	e0bffe17 	ldw	r2,-8(fp)
   46ea4:	10800044 	addi	r2,r2,1
   46ea8:	10800003 	ldbu	r2,0(r2)
   46eac:	10803fcc 	andi	r2,r2,255
   46eb0:	100b883a 	mov	r5,r2
   46eb4:	1809883a 	mov	r4,r3
   46eb8:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DIPR2(s), addr[2]);
   46ebc:	e0bffd03 	ldbu	r2,-12(fp)
   46ec0:	1004917a 	slli	r2,r2,5
   46ec4:	10838204 	addi	r2,r2,3592
   46ec8:	1007883a 	mov	r3,r2
   46ecc:	e0bffe17 	ldw	r2,-8(fp)
   46ed0:	10800084 	addi	r2,r2,2
   46ed4:	10800003 	ldbu	r2,0(r2)
   46ed8:	10803fcc 	andi	r2,r2,255
   46edc:	100b883a 	mov	r5,r2
   46ee0:	1809883a 	mov	r4,r3
   46ee4:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DIPR3(s), addr[3]);
   46ee8:	e0bffd03 	ldbu	r2,-12(fp)
   46eec:	1004917a 	slli	r2,r2,5
   46ef0:	1083c204 	addi	r2,r2,3848
   46ef4:	1007883a 	mov	r3,r2
   46ef8:	e0bffe17 	ldw	r2,-8(fp)
   46efc:	108000c4 	addi	r2,r2,3
   46f00:	10800003 	ldbu	r2,0(r2)
   46f04:	10803fcc 	andi	r2,r2,255
   46f08:	100b883a 	mov	r5,r2
   46f0c:	1809883a 	mov	r4,r3
   46f10:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DPORT0(s), (uint8)((port & 0xff00) >> 8));
   46f14:	e0bffd03 	ldbu	r2,-12(fp)
   46f18:	1004917a 	slli	r2,r2,5
   46f1c:	10840204 	addi	r2,r2,4104
   46f20:	1007883a 	mov	r3,r2
   46f24:	e0bfff0b 	ldhu	r2,-4(fp)
   46f28:	1004d23a 	srli	r2,r2,8
   46f2c:	10803fcc 	andi	r2,r2,255
   46f30:	100b883a 	mov	r5,r2
   46f34:	1809883a 	mov	r4,r3
   46f38:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DPORT1(s), (uint8)(port & 0x00ff));
   46f3c:	e0bffd03 	ldbu	r2,-12(fp)
   46f40:	1004917a 	slli	r2,r2,5
   46f44:	10844204 	addi	r2,r2,4360
   46f48:	1007883a 	mov	r3,r2
   46f4c:	e0bfff0b 	ldhu	r2,-4(fp)
   46f50:	10803fcc 	andi	r2,r2,255
   46f54:	100b883a 	mov	r5,r2
   46f58:	1809883a 	mov	r4,r3
   46f5c:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_CONNECT);
   46f60:	e0bffd03 	ldbu	r2,-12(fp)
   46f64:	1004917a 	slli	r2,r2,5
   46f68:	10804204 	addi	r2,r2,264
   46f6c:	01400104 	movi	r5,4
   46f70:	1009883a 	mov	r4,r2
   46f74:	00481840 	call	48184 <IINCHIP_WRITE>
        /* wait for completion */
        while ( IINCHIP_READ(Sn_CR(s) ) ) ;
   46f78:	0001883a 	nop
   46f7c:	e0bffd03 	ldbu	r2,-12(fp)
   46f80:	1004917a 	slli	r2,r2,5
   46f84:	10804204 	addi	r2,r2,264
   46f88:	1009883a 	mov	r4,r2
   46f8c:	00482100 	call	48210 <IINCHIP_READ>
   46f90:	10803fcc 	andi	r2,r2,255
   46f94:	103ff91e 	bne	r2,zero,46f7c <__alt_mem_epcs_flash+0xfffc5f7c>

        while ( IINCHIP_READ(Sn_SR(s)) != SOCK_SYNSENT )
   46f98:	00001606 	br	46ff4 <connect+0x270>
        {
            if(IINCHIP_READ(Sn_SR(s)) == SOCK_ESTABLISHED)
   46f9c:	e0bffd03 	ldbu	r2,-12(fp)
   46fa0:	1004917a 	slli	r2,r2,5
   46fa4:	1080c204 	addi	r2,r2,776
   46fa8:	1009883a 	mov	r4,r2
   46fac:	00482100 	call	48210 <IINCHIP_READ>
   46fb0:	10803fcc 	andi	r2,r2,255
   46fb4:	108005d8 	cmpnei	r2,r2,23
   46fb8:	10001726 	beq	r2,zero,47018 <connect+0x294>
            {
                break;
            }
            if (getSn_IR(s) & Sn_IR_TIMEOUT)
   46fbc:	e0bffd03 	ldbu	r2,-12(fp)
   46fc0:	1009883a 	mov	r4,r2
   46fc4:	0048d200 	call	48d20 <getSn_IR>
   46fc8:	10803fcc 	andi	r2,r2,255
   46fcc:	1080020c 	andi	r2,r2,8
   46fd0:	10000826 	beq	r2,zero,46ff4 <connect+0x270>
            {
                IINCHIP_WRITE(Sn_IR(s), (Sn_IR_TIMEOUT));  // clear TIMEOUT Interrupt
   46fd4:	e0bffd03 	ldbu	r2,-12(fp)
   46fd8:	1004917a 	slli	r2,r2,5
   46fdc:	10808204 	addi	r2,r2,520
   46fe0:	01400204 	movi	r5,8
   46fe4:	1009883a 	mov	r4,r2
   46fe8:	00481840 	call	48184 <IINCHIP_WRITE>
                ret = 0;
   46fec:	e03ffc05 	stb	zero,-16(fp)
                break;
   46ff0:	00000a06 	br	4701c <connect+0x298>
        IINCHIP_WRITE( Sn_DPORT1(s), (uint8)(port & 0x00ff));
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_CONNECT);
        /* wait for completion */
        while ( IINCHIP_READ(Sn_CR(s) ) ) ;

        while ( IINCHIP_READ(Sn_SR(s)) != SOCK_SYNSENT )
   46ff4:	e0bffd03 	ldbu	r2,-12(fp)
   46ff8:	1004917a 	slli	r2,r2,5
   46ffc:	1080c204 	addi	r2,r2,776
   47000:	1009883a 	mov	r4,r2
   47004:	00482100 	call	48210 <IINCHIP_READ>
   47008:	10803fcc 	andi	r2,r2,255
   4700c:	10800558 	cmpnei	r2,r2,21
   47010:	103fe21e 	bne	r2,zero,46f9c <__alt_mem_epcs_flash+0xfffc5f9c>
   47014:	00000106 	br	4701c <connect+0x298>
        {
            if(IINCHIP_READ(Sn_SR(s)) == SOCK_ESTABLISHED)
            {
                break;
   47018:	0001883a 	nop
                break;
            }
        }
    }

    return ret;
   4701c:	e0bffc03 	ldbu	r2,-16(fp)
}
   47020:	e037883a 	mov	sp,fp
   47024:	dfc00117 	ldw	ra,4(sp)
   47028:	df000017 	ldw	fp,0(sp)
   4702c:	dec00204 	addi	sp,sp,8
   47030:	f800283a 	ret

00047034 <disconnect>:
/**
  @brief   This function used for disconnect the socket and parameter is "s" which represent the socket number
  @return  1 for success else 0.
  */
void disconnect(SOCKET s)
{
   47034:	defffd04 	addi	sp,sp,-12
   47038:	dfc00215 	stw	ra,8(sp)
   4703c:	df000115 	stw	fp,4(sp)
   47040:	df000104 	addi	fp,sp,4
   47044:	2005883a 	mov	r2,r4
   47048:	e0bfff05 	stb	r2,-4(fp)
    IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_DISCON);
   4704c:	e0bfff03 	ldbu	r2,-4(fp)
   47050:	1004917a 	slli	r2,r2,5
   47054:	10804204 	addi	r2,r2,264
   47058:	01400204 	movi	r5,8
   4705c:	1009883a 	mov	r4,r2
   47060:	00481840 	call	48184 <IINCHIP_WRITE>

    /* wait to process the command... */
    while( IINCHIP_READ(Sn_CR(s) ) )
   47064:	0001883a 	nop
   47068:	e0bfff03 	ldbu	r2,-4(fp)
   4706c:	1004917a 	slli	r2,r2,5
   47070:	10804204 	addi	r2,r2,264
   47074:	1009883a 	mov	r4,r2
   47078:	00482100 	call	48210 <IINCHIP_READ>
   4707c:	10803fcc 	andi	r2,r2,255
   47080:	103ff91e 	bne	r2,zero,47068 <__alt_mem_epcs_flash+0xfffc6068>
        ;
    /* ------- */
}
   47084:	0001883a 	nop
   47088:	e037883a 	mov	sp,fp
   4708c:	dfc00117 	ldw	ra,4(sp)
   47090:	df000017 	ldw	fp,0(sp)
   47094:	dec00204 	addi	sp,sp,8
   47098:	f800283a 	ret

0004709c <send>:
/**
  @brief   This function used to send the data in TCP mode
  @return  1 for success else 0.
  */
uint16 send(SOCKET s, const uint8 * buf, uint16 len)
{
   4709c:	defff904 	addi	sp,sp,-28
   470a0:	dfc00615 	stw	ra,24(sp)
   470a4:	df000515 	stw	fp,20(sp)
   470a8:	df000504 	addi	fp,sp,20
   470ac:	2007883a 	mov	r3,r4
   470b0:	e17ffe15 	stw	r5,-8(fp)
   470b4:	3005883a 	mov	r2,r6
   470b8:	e0fffd05 	stb	r3,-12(fp)
   470bc:	e0bfff0d 	sth	r2,-4(fp)
    uint8 status=0;
   470c0:	e03ffb85 	stb	zero,-18(fp)
    uint16 ret=0;
   470c4:	e03ffb0d 	sth	zero,-20(fp)
    uint16 freesize=0;
   470c8:	e03ffc0d 	sth	zero,-16(fp)

    if (len > getIINCHIP_TxMAX(s))
   470cc:	e0bffd03 	ldbu	r2,-12(fp)
   470d0:	1009883a 	mov	r4,r2
   470d4:	00480740 	call	48074 <getIINCHIP_TxMAX>
   470d8:	10ffffcc 	andi	r3,r2,65535
   470dc:	e0bfff0b 	ldhu	r2,-4(fp)
   470e0:	1880052e 	bgeu	r3,r2,470f8 <send+0x5c>
    	ret = getIINCHIP_TxMAX(s);
   470e4:	e0bffd03 	ldbu	r2,-12(fp)
   470e8:	1009883a 	mov	r4,r2
   470ec:	00480740 	call	48074 <getIINCHIP_TxMAX>
   470f0:	e0bffb0d 	sth	r2,-20(fp)
   470f4:	00000206 	br	47100 <send+0x64>
    else
    	ret = len;
   470f8:	e0bfff0b 	ldhu	r2,-4(fp)
   470fc:	e0bffb0d 	sth	r2,-20(fp)

    do
    {
        freesize = getSn_TX_FSR(s);
   47100:	e0bffd03 	ldbu	r2,-12(fp)
   47104:	1009883a 	mov	r4,r2
   47108:	0048da00 	call	48da0 <getSn_TX_FSR>
   4710c:	e0bffc0d 	sth	r2,-16(fp)
        status = IINCHIP_READ(Sn_SR(s));
   47110:	e0bffd03 	ldbu	r2,-12(fp)
   47114:	1004917a 	slli	r2,r2,5
   47118:	1080c204 	addi	r2,r2,776
   4711c:	1009883a 	mov	r4,r2
   47120:	00482100 	call	48210 <IINCHIP_READ>
   47124:	e0bffb85 	stb	r2,-18(fp)
        if ((status != SOCK_ESTABLISHED) && (status != SOCK_CLOSE_WAIT))
   47128:	e0bffb83 	ldbu	r2,-18(fp)
   4712c:	108005e0 	cmpeqi	r2,r2,23
   47130:	1000051e 	bne	r2,zero,47148 <send+0xac>
   47134:	e0bffb83 	ldbu	r2,-18(fp)
   47138:	10800720 	cmpeqi	r2,r2,28
   4713c:	1000021e 	bne	r2,zero,47148 <send+0xac>
        {
            ret = 0;
   47140:	e03ffb0d 	sth	zero,-20(fp)
            break;
   47144:	00000306 	br	47154 <send+0xb8>
        }
    } while (freesize < ret);
   47148:	e0fffc0b 	ldhu	r3,-16(fp)
   4714c:	e0bffb0b 	ldhu	r2,-20(fp)
   47150:	18bfeb36 	bltu	r3,r2,47100 <__alt_mem_epcs_flash+0xfffc6100>

    send_data_processing(s, (uint8 *)buf, ret);
   47154:	e0bffd03 	ldbu	r2,-12(fp)
   47158:	e0fffb0b 	ldhu	r3,-20(fp)
   4715c:	180d883a 	mov	r6,r3
   47160:	e17ffe17 	ldw	r5,-8(fp)
   47164:	1009883a 	mov	r4,r2
   47168:	0048f680 	call	48f68 <send_data_processing>
    IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_SEND);
   4716c:	e0bffd03 	ldbu	r2,-12(fp)
   47170:	1004917a 	slli	r2,r2,5
   47174:	10804204 	addi	r2,r2,264
   47178:	01400804 	movi	r5,32
   4717c:	1009883a 	mov	r4,r2
   47180:	00481840 	call	48184 <IINCHIP_WRITE>

    while( IINCHIP_READ(Sn_CR(s) ) );
   47184:	0001883a 	nop
   47188:	e0bffd03 	ldbu	r2,-12(fp)
   4718c:	1004917a 	slli	r2,r2,5
   47190:	10804204 	addi	r2,r2,264
   47194:	1009883a 	mov	r4,r2
   47198:	00482100 	call	48210 <IINCHIP_READ>
   4719c:	10803fcc 	andi	r2,r2,255
   471a0:	103ff91e 	bne	r2,zero,47188 <__alt_mem_epcs_flash+0xfffc6188>

    while ( (IINCHIP_READ(Sn_IR(s) ) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK )
   471a4:	00001106 	br	471ec <send+0x150>
    {
        status = IINCHIP_READ(Sn_SR(s));
   471a8:	e0bffd03 	ldbu	r2,-12(fp)
   471ac:	1004917a 	slli	r2,r2,5
   471b0:	1080c204 	addi	r2,r2,776
   471b4:	1009883a 	mov	r4,r2
   471b8:	00482100 	call	48210 <IINCHIP_READ>
   471bc:	e0bffb85 	stb	r2,-18(fp)
        if ((status != SOCK_ESTABLISHED) && (status != SOCK_CLOSE_WAIT) )
   471c0:	e0bffb83 	ldbu	r2,-18(fp)
   471c4:	108005e0 	cmpeqi	r2,r2,23
   471c8:	1000081e 	bne	r2,zero,471ec <send+0x150>
   471cc:	e0bffb83 	ldbu	r2,-18(fp)
   471d0:	10800720 	cmpeqi	r2,r2,28
   471d4:	1000051e 	bne	r2,zero,471ec <send+0x150>
        {
            close_socket(s);
   471d8:	e0bffd03 	ldbu	r2,-12(fp)
   471dc:	1009883a 	mov	r4,r2
   471e0:	0046c6c0 	call	46c6c <close_socket>
            return 0;
   471e4:	0005883a 	mov	r2,zero
   471e8:	00001506 	br	47240 <send+0x1a4>
    send_data_processing(s, (uint8 *)buf, ret);
    IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_SEND);

    while( IINCHIP_READ(Sn_CR(s) ) );

    while ( (IINCHIP_READ(Sn_IR(s) ) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK )
   471ec:	e0bffd03 	ldbu	r2,-12(fp)
   471f0:	1004917a 	slli	r2,r2,5
   471f4:	10808204 	addi	r2,r2,520
   471f8:	1009883a 	mov	r4,r2
   471fc:	00482100 	call	48210 <IINCHIP_READ>
   47200:	10803fcc 	andi	r2,r2,255
   47204:	1080040c 	andi	r2,r2,16
   47208:	103fe726 	beq	r2,zero,471a8 <__alt_mem_epcs_flash+0xfffc61a8>
        {
            close_socket(s);
            return 0;
        }
    }
    IINCHIP_WRITE( Sn_IR(s) , Sn_IR_SEND_OK);
   4720c:	e0bffd03 	ldbu	r2,-12(fp)
   47210:	1004917a 	slli	r2,r2,5
   47214:	10808204 	addi	r2,r2,520
   47218:	01400404 	movi	r5,16
   4721c:	1009883a 	mov	r4,r2
   47220:	00481840 	call	48184 <IINCHIP_WRITE>

#ifdef __DEF_IINCHIP_INT__
    putISR(s, getISR(s) & (~Sn_IR_SEND_OK));
#else
    IINCHIP_WRITE( Sn_IR(s) , Sn_IR_SEND_OK);
   47224:	e0bffd03 	ldbu	r2,-12(fp)
   47228:	1004917a 	slli	r2,r2,5
   4722c:	10808204 	addi	r2,r2,520
   47230:	01400404 	movi	r5,16
   47234:	1009883a 	mov	r4,r2
   47238:	00481840 	call	48184 <IINCHIP_WRITE>
#endif

    return ret;
   4723c:	e0bffb0b 	ldhu	r2,-20(fp)
}
   47240:	e037883a 	mov	sp,fp
   47244:	dfc00117 	ldw	ra,4(sp)
   47248:	df000017 	ldw	fp,0(sp)
   4724c:	dec00204 	addi	sp,sp,8
   47250:	f800283a 	ret

00047254 <recv>:
  It continues to wait for data as much as the application wants to receive.

  @return  received data size for success else -1.
  */
uint16 recv(SOCKET s, uint8 * buf, uint16 len)
{
   47254:	defffa04 	addi	sp,sp,-24
   47258:	dfc00515 	stw	ra,20(sp)
   4725c:	df000415 	stw	fp,16(sp)
   47260:	df000404 	addi	fp,sp,16
   47264:	2007883a 	mov	r3,r4
   47268:	e17ffe15 	stw	r5,-8(fp)
   4726c:	3005883a 	mov	r2,r6
   47270:	e0fffd05 	stb	r3,-12(fp)
   47274:	e0bfff0d 	sth	r2,-4(fp)
    uint16 ret=0;
   47278:	e03ffc0d 	sth	zero,-16(fp)
    if ( len > 0 )
   4727c:	e0bfff0b 	ldhu	r2,-4(fp)
   47280:	10001626 	beq	r2,zero,472dc <recv+0x88>
    {
        recv_data_processing(s, buf, len);				// 数据接收进程：将通过Sockets的buf接受的长度为len的数据写入指针对应的MCU的缓存地址
   47284:	e0bffd03 	ldbu	r2,-12(fp)
   47288:	e0ffff0b 	ldhu	r3,-4(fp)
   4728c:	180d883a 	mov	r6,r3
   47290:	e17ffe17 	ldw	r5,-8(fp)
   47294:	1009883a 	mov	r4,r2
   47298:	00490980 	call	49098 <recv_data_processing>

        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_RECV);			// MCU配置Sn_CR为RECV
   4729c:	e0bffd03 	ldbu	r2,-12(fp)
   472a0:	1004917a 	slli	r2,r2,5
   472a4:	10804204 	addi	r2,r2,264
   472a8:	01401004 	movi	r5,64
   472ac:	1009883a 	mov	r4,r2
   472b0:	00481840 	call	48184 <IINCHIP_WRITE>

        while( IINCHIP_READ(Sn_CR(s) ));					// 配置完成，Sn_CR自动清零
   472b4:	0001883a 	nop
   472b8:	e0bffd03 	ldbu	r2,-12(fp)
   472bc:	1004917a 	slli	r2,r2,5
   472c0:	10804204 	addi	r2,r2,264
   472c4:	1009883a 	mov	r4,r2
   472c8:	00482100 	call	48210 <IINCHIP_READ>
   472cc:	10803fcc 	andi	r2,r2,255
   472d0:	103ff91e 	bne	r2,zero,472b8 <__alt_mem_epcs_flash+0xfffc62b8>

        ret = len;																// 将接收数据长度值赋给ret
   472d4:	e0bfff0b 	ldhu	r2,-4(fp)
   472d8:	e0bffc0d 	sth	r2,-16(fp)
    }
    return ret;																	// 返回ret的值。有返回值说明W5500有数据接收，并不断重复接收这一进程
   472dc:	e0bffc0b 	ldhu	r2,-16(fp)
}
   472e0:	e037883a 	mov	sp,fp
   472e4:	dfc00117 	ldw	ra,4(sp)
   472e8:	df000017 	ldw	fp,0(sp)
   472ec:	dec00204 	addi	sp,sp,8
   472f0:	f800283a 	ret

000472f4 <sendto>:
  Unlike TCP transmission, The peer's destination address and the port is needed.

  @return  This function return send data size for success else -1.
  */
uint16 sendto(SOCKET s, const uint8 * buf, uint16 len, uint8 * addr, uint16 port)
{
   472f4:	defff804 	addi	sp,sp,-32
   472f8:	dfc00715 	stw	ra,28(sp)
   472fc:	df000615 	stw	fp,24(sp)
   47300:	df000604 	addi	fp,sp,24
   47304:	e17ffc15 	stw	r5,-16(fp)
   47308:	3007883a 	mov	r3,r6
   4730c:	e1fffe15 	stw	r7,-8(fp)
   47310:	e0800217 	ldw	r2,8(fp)
   47314:	e13ffb05 	stb	r4,-20(fp)
   47318:	e0fffd0d 	sth	r3,-12(fp)
   4731c:	e0bfff0d 	sth	r2,-4(fp)
    uint16 ret=0;
   47320:	e03ffa0d 	sth	zero,-24(fp)

    if (len > getIINCHIP_TxMAX(s)) 
   47324:	e0bffb03 	ldbu	r2,-20(fp)
   47328:	1009883a 	mov	r4,r2
   4732c:	00480740 	call	48074 <getIINCHIP_TxMAX>
   47330:	10ffffcc 	andi	r3,r2,65535
   47334:	e0bffd0b 	ldhu	r2,-12(fp)
   47338:	1880052e 	bgeu	r3,r2,47350 <sendto+0x5c>
        ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
   4733c:	e0bffb03 	ldbu	r2,-20(fp)
   47340:	1009883a 	mov	r4,r2
   47344:	00480740 	call	48074 <getIINCHIP_TxMAX>
   47348:	e0bffa0d 	sth	r2,-24(fp)
   4734c:	00000206 	br	47358 <sendto+0x64>
    else ret = len;
   47350:	e0bffd0b 	ldhu	r2,-12(fp)
   47354:	e0bffa0d 	sth	r2,-24(fp)

    if( ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) || ((port == 0x00)) )//||(ret == 0) )
   47358:	e0bffe17 	ldw	r2,-8(fp)
   4735c:	10800003 	ldbu	r2,0(r2)
   47360:	10803fcc 	andi	r2,r2,255
   47364:	10000f1e 	bne	r2,zero,473a4 <sendto+0xb0>
   47368:	e0bffe17 	ldw	r2,-8(fp)
   4736c:	10800044 	addi	r2,r2,1
   47370:	10800003 	ldbu	r2,0(r2)
   47374:	10803fcc 	andi	r2,r2,255
   47378:	10000a1e 	bne	r2,zero,473a4 <sendto+0xb0>
   4737c:	e0bffe17 	ldw	r2,-8(fp)
   47380:	10800084 	addi	r2,r2,2
   47384:	10800003 	ldbu	r2,0(r2)
   47388:	10803fcc 	andi	r2,r2,255
   4738c:	1000051e 	bne	r2,zero,473a4 <sendto+0xb0>
   47390:	e0bffe17 	ldw	r2,-8(fp)
   47394:	108000c4 	addi	r2,r2,3
   47398:	10800003 	ldbu	r2,0(r2)
   4739c:	10803fcc 	andi	r2,r2,255
   473a0:	10000226 	beq	r2,zero,473ac <sendto+0xb8>
   473a4:	e0bfff0b 	ldhu	r2,-4(fp)
   473a8:	1000021e 	bne	r2,zero,473b4 <sendto+0xc0>
    {
        /* added return value */
        ret = 0;
   473ac:	e03ffa0d 	sth	zero,-24(fp)
   473b0:	00007106 	br	47578 <sendto+0x284>
    }
    else
    {
        IINCHIP_WRITE( Sn_DIPR0(s), addr[0]);
   473b4:	e0bffb03 	ldbu	r2,-20(fp)
   473b8:	1004917a 	slli	r2,r2,5
   473bc:	10830204 	addi	r2,r2,3080
   473c0:	1007883a 	mov	r3,r2
   473c4:	e0bffe17 	ldw	r2,-8(fp)
   473c8:	10800003 	ldbu	r2,0(r2)
   473cc:	10803fcc 	andi	r2,r2,255
   473d0:	100b883a 	mov	r5,r2
   473d4:	1809883a 	mov	r4,r3
   473d8:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DIPR1(s), addr[1]);
   473dc:	e0bffb03 	ldbu	r2,-20(fp)
   473e0:	1004917a 	slli	r2,r2,5
   473e4:	10834204 	addi	r2,r2,3336
   473e8:	1007883a 	mov	r3,r2
   473ec:	e0bffe17 	ldw	r2,-8(fp)
   473f0:	10800044 	addi	r2,r2,1
   473f4:	10800003 	ldbu	r2,0(r2)
   473f8:	10803fcc 	andi	r2,r2,255
   473fc:	100b883a 	mov	r5,r2
   47400:	1809883a 	mov	r4,r3
   47404:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DIPR2(s), addr[2]);
   47408:	e0bffb03 	ldbu	r2,-20(fp)
   4740c:	1004917a 	slli	r2,r2,5
   47410:	10838204 	addi	r2,r2,3592
   47414:	1007883a 	mov	r3,r2
   47418:	e0bffe17 	ldw	r2,-8(fp)
   4741c:	10800084 	addi	r2,r2,2
   47420:	10800003 	ldbu	r2,0(r2)
   47424:	10803fcc 	andi	r2,r2,255
   47428:	100b883a 	mov	r5,r2
   4742c:	1809883a 	mov	r4,r3
   47430:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DIPR3(s), addr[3]);
   47434:	e0bffb03 	ldbu	r2,-20(fp)
   47438:	1004917a 	slli	r2,r2,5
   4743c:	1083c204 	addi	r2,r2,3848
   47440:	1007883a 	mov	r3,r2
   47444:	e0bffe17 	ldw	r2,-8(fp)
   47448:	108000c4 	addi	r2,r2,3
   4744c:	10800003 	ldbu	r2,0(r2)
   47450:	10803fcc 	andi	r2,r2,255
   47454:	100b883a 	mov	r5,r2
   47458:	1809883a 	mov	r4,r3
   4745c:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DPORT0(s),(uint8)((port & 0xff00) >> 8));
   47460:	e0bffb03 	ldbu	r2,-20(fp)
   47464:	1004917a 	slli	r2,r2,5
   47468:	10840204 	addi	r2,r2,4104
   4746c:	1007883a 	mov	r3,r2
   47470:	e0bfff0b 	ldhu	r2,-4(fp)
   47474:	1004d23a 	srli	r2,r2,8
   47478:	10803fcc 	andi	r2,r2,255
   4747c:	100b883a 	mov	r5,r2
   47480:	1809883a 	mov	r4,r3
   47484:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( Sn_DPORT1(s),(uint8)(port & 0x00ff));
   47488:	e0bffb03 	ldbu	r2,-20(fp)
   4748c:	1004917a 	slli	r2,r2,5
   47490:	10844204 	addi	r2,r2,4360
   47494:	1007883a 	mov	r3,r2
   47498:	e0bfff0b 	ldhu	r2,-4(fp)
   4749c:	10803fcc 	andi	r2,r2,255
   474a0:	100b883a 	mov	r5,r2
   474a4:	1809883a 	mov	r4,r3
   474a8:	00481840 	call	48184 <IINCHIP_WRITE>
        // copy data
        send_data_processing(s, (uint8 *)buf, ret);
   474ac:	e0bffb03 	ldbu	r2,-20(fp)
   474b0:	e0fffa0b 	ldhu	r3,-24(fp)
   474b4:	180d883a 	mov	r6,r3
   474b8:	e17ffc17 	ldw	r5,-16(fp)
   474bc:	1009883a 	mov	r4,r2
   474c0:	0048f680 	call	48f68 <send_data_processing>
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_SEND);
   474c4:	e0bffb03 	ldbu	r2,-20(fp)
   474c8:	1004917a 	slli	r2,r2,5
   474cc:	10804204 	addi	r2,r2,264
   474d0:	01400804 	movi	r5,32
   474d4:	1009883a 	mov	r4,r2
   474d8:	00481840 	call	48184 <IINCHIP_WRITE>
        /* wait to process the command... */
        while( IINCHIP_READ( Sn_CR(s) ) )
   474dc:	0001883a 	nop
   474e0:	e0bffb03 	ldbu	r2,-20(fp)
   474e4:	1004917a 	slli	r2,r2,5
   474e8:	10804204 	addi	r2,r2,264
   474ec:	1009883a 	mov	r4,r2
   474f0:	00482100 	call	48210 <IINCHIP_READ>
   474f4:	10803fcc 	andi	r2,r2,255
   474f8:	103ff91e 	bne	r2,zero,474e0 <__alt_mem_epcs_flash+0xfffc64e0>
            ;
        /* ------- */
        while( (IINCHIP_READ( Sn_IR(s) ) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK )
   474fc:	00001006 	br	47540 <sendto+0x24c>
        {
            if (IINCHIP_READ( Sn_IR(s) ) & Sn_IR_TIMEOUT)
   47500:	e0bffb03 	ldbu	r2,-20(fp)
   47504:	1004917a 	slli	r2,r2,5
   47508:	10808204 	addi	r2,r2,520
   4750c:	1009883a 	mov	r4,r2
   47510:	00482100 	call	48210 <IINCHIP_READ>
   47514:	10803fcc 	andi	r2,r2,255
   47518:	1080020c 	andi	r2,r2,8
   4751c:	10000826 	beq	r2,zero,47540 <sendto+0x24c>
            {
                /* clear interrupt */
                IINCHIP_WRITE( Sn_IR(s) , (Sn_IR_SEND_OK | Sn_IR_TIMEOUT)); /* clear SEND_OK & TIMEOUT */
   47520:	e0bffb03 	ldbu	r2,-20(fp)
   47524:	1004917a 	slli	r2,r2,5
   47528:	10808204 	addi	r2,r2,520
   4752c:	01400604 	movi	r5,24
   47530:	1009883a 	mov	r4,r2
   47534:	00481840 	call	48184 <IINCHIP_WRITE>
                return 0;
   47538:	0005883a 	mov	r2,zero
   4753c:	00000f06 	br	4757c <sendto+0x288>
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_SEND);
        /* wait to process the command... */
        while( IINCHIP_READ( Sn_CR(s) ) )
            ;
        /* ------- */
        while( (IINCHIP_READ( Sn_IR(s) ) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK )
   47540:	e0bffb03 	ldbu	r2,-20(fp)
   47544:	1004917a 	slli	r2,r2,5
   47548:	10808204 	addi	r2,r2,520
   4754c:	1009883a 	mov	r4,r2
   47550:	00482100 	call	48210 <IINCHIP_READ>
   47554:	10803fcc 	andi	r2,r2,255
   47558:	1080040c 	andi	r2,r2,16
   4755c:	103fe826 	beq	r2,zero,47500 <__alt_mem_epcs_flash+0xfffc6500>
                /* clear interrupt */
                IINCHIP_WRITE( Sn_IR(s) , (Sn_IR_SEND_OK | Sn_IR_TIMEOUT)); /* clear SEND_OK & TIMEOUT */
                return 0;
            }
        }
        IINCHIP_WRITE( Sn_IR(s) , Sn_IR_SEND_OK);
   47560:	e0bffb03 	ldbu	r2,-20(fp)
   47564:	1004917a 	slli	r2,r2,5
   47568:	10808204 	addi	r2,r2,520
   4756c:	01400404 	movi	r5,16
   47570:	1009883a 	mov	r4,r2
   47574:	00481840 	call	48184 <IINCHIP_WRITE>
    }
    return ret;
   47578:	e0bffa0b 	ldhu	r2,-24(fp)
}
   4757c:	e037883a 	mov	sp,fp
   47580:	dfc00117 	ldw	ra,4(sp)
   47584:	df000017 	ldw	fp,0(sp)
   47588:	dec00204 	addi	sp,sp,8
   4758c:	f800283a 	ret

00047590 <recvfrom>:
  TCP mode. This function is used to receive UDP, IP_RAW and MAC_RAW mode, and handle the header as well.

  @return  This function return received data size for success else -1.
  */
uint16 recvfrom(SOCKET s, uint8 * buf, uint16 len, uint8 * addr, uint16 *port)
{
   47590:	defff504 	addi	sp,sp,-44
   47594:	dfc00a15 	stw	ra,40(sp)
   47598:	df000915 	stw	fp,36(sp)
   4759c:	dc000815 	stw	r16,32(sp)
   475a0:	df000904 	addi	fp,sp,36
   475a4:	2007883a 	mov	r3,r4
   475a8:	e17ffc15 	stw	r5,-16(fp)
   475ac:	3005883a 	mov	r2,r6
   475b0:	e1fffe15 	stw	r7,-8(fp)
   475b4:	e0fffb05 	stb	r3,-20(fp)
   475b8:	e0bffd0d 	sth	r2,-12(fp)
    uint8 head[8];
    uint16 data_len=0;
   475bc:	e03ff70d 	sth	zero,-36(fp)
    uint16 ptr=0;
   475c0:	e03ff78d 	sth	zero,-34(fp)
    uint32 addrbsb =0;
   475c4:	e03ff815 	stw	zero,-32(fp)
    if ( len > 0 )
   475c8:	e0bffd0b 	ldhu	r2,-12(fp)
   475cc:	10010c26 	beq	r2,zero,47a00 <recvfrom+0x470>
    {
        ptr     = IINCHIP_READ(Sn_RX_RD0(s) );
   475d0:	e0bffb03 	ldbu	r2,-20(fp)
   475d4:	1004917a 	slli	r2,r2,5
   475d8:	108a0204 	addi	r2,r2,10248
   475dc:	1009883a 	mov	r4,r2
   475e0:	00482100 	call	48210 <IINCHIP_READ>
   475e4:	10803fcc 	andi	r2,r2,255
   475e8:	e0bff78d 	sth	r2,-34(fp)
        ptr     = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_RX_RD1(s));
   475ec:	e0bff78b 	ldhu	r2,-34(fp)
   475f0:	1004923a 	slli	r2,r2,8
   475f4:	1021883a 	mov	r16,r2
   475f8:	e0bffb03 	ldbu	r2,-20(fp)
   475fc:	1004917a 	slli	r2,r2,5
   47600:	108a4204 	addi	r2,r2,10504
   47604:	1009883a 	mov	r4,r2
   47608:	00482100 	call	48210 <IINCHIP_READ>
   4760c:	10803fcc 	andi	r2,r2,255
   47610:	8085883a 	add	r2,r16,r2
   47614:	e0bff78d 	sth	r2,-34(fp)
        addrbsb = (uint32)(ptr<<8) +  (s<<5) + 0x18;
   47618:	e0bff78b 	ldhu	r2,-34(fp)
   4761c:	1004923a 	slli	r2,r2,8
   47620:	1007883a 	mov	r3,r2
   47624:	e0bffb03 	ldbu	r2,-20(fp)
   47628:	1004917a 	slli	r2,r2,5
   4762c:	1885883a 	add	r2,r3,r2
   47630:	10800604 	addi	r2,r2,24
   47634:	e0bff815 	stw	r2,-32(fp)

        switch (IINCHIP_READ(Sn_MR(s) ) & 0x07)
   47638:	e0bffb03 	ldbu	r2,-20(fp)
   4763c:	1004917a 	slli	r2,r2,5
   47640:	10800204 	addi	r2,r2,8
   47644:	1009883a 	mov	r4,r2
   47648:	00482100 	call	48210 <IINCHIP_READ>
   4764c:	10803fcc 	andi	r2,r2,255
   47650:	108001cc 	andi	r2,r2,7
   47654:	10c000e0 	cmpeqi	r3,r2,3
   47658:	1800591e 	bne	r3,zero,477c0 <recvfrom+0x230>
   4765c:	10c00120 	cmpeqi	r3,r2,4
   47660:	18009d1e 	bne	r3,zero,478d8 <recvfrom+0x348>
   47664:	108000a0 	cmpeqi	r2,r2,2
   47668:	1000011e 	bne	r2,zero,47670 <recvfrom+0xe0>
                IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));
                IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));
                break;

            default :
                break;
   4766c:	0000d606 	br	479c8 <recvfrom+0x438>
        addrbsb = (uint32)(ptr<<8) +  (s<<5) + 0x18;

        switch (IINCHIP_READ(Sn_MR(s) ) & 0x07)
        {
            case Sn_MR_UDP :
                wiz_read_buf(addrbsb, head, 0x08);        
   47670:	e0bff904 	addi	r2,fp,-28
   47674:	01800204 	movi	r6,8
   47678:	100b883a 	mov	r5,r2
   4767c:	e13ff817 	ldw	r4,-32(fp)
   47680:	00483780 	call	48378 <wiz_read_buf>
                ptr += 8;
   47684:	e0bff78b 	ldhu	r2,-34(fp)
   47688:	10800204 	addi	r2,r2,8
   4768c:	e0bff78d 	sth	r2,-34(fp)
                // read peer's IP address, port number.
                addr[0]  = head[0];
   47690:	e0fff903 	ldbu	r3,-28(fp)
   47694:	e0bffe17 	ldw	r2,-8(fp)
   47698:	10c00005 	stb	r3,0(r2)
                addr[1]  = head[1];
   4769c:	e0bffe17 	ldw	r2,-8(fp)
   476a0:	10800044 	addi	r2,r2,1
   476a4:	e0fff943 	ldbu	r3,-27(fp)
   476a8:	10c00005 	stb	r3,0(r2)
                addr[2]  = head[2];
   476ac:	e0bffe17 	ldw	r2,-8(fp)
   476b0:	10800084 	addi	r2,r2,2
   476b4:	e0fff983 	ldbu	r3,-26(fp)
   476b8:	10c00005 	stb	r3,0(r2)
                addr[3]  = head[3];
   476bc:	e0bffe17 	ldw	r2,-8(fp)
   476c0:	108000c4 	addi	r2,r2,3
   476c4:	e0fff9c3 	ldbu	r3,-25(fp)
   476c8:	10c00005 	stb	r3,0(r2)
                *port    = head[4];
   476cc:	e0bffa03 	ldbu	r2,-24(fp)
   476d0:	10c03fcc 	andi	r3,r2,255
   476d4:	e0800217 	ldw	r2,8(fp)
   476d8:	10c0000d 	sth	r3,0(r2)
                *port    = (*port << 8) + head[5];
   476dc:	e0800217 	ldw	r2,8(fp)
   476e0:	1080000b 	ldhu	r2,0(r2)
   476e4:	1004923a 	slli	r2,r2,8
   476e8:	1007883a 	mov	r3,r2
   476ec:	e0bffa43 	ldbu	r2,-23(fp)
   476f0:	10803fcc 	andi	r2,r2,255
   476f4:	1885883a 	add	r2,r3,r2
   476f8:	1007883a 	mov	r3,r2
   476fc:	e0800217 	ldw	r2,8(fp)
   47700:	10c0000d 	sth	r3,0(r2)
                data_len = head[6];
   47704:	e0bffa83 	ldbu	r2,-22(fp)
   47708:	10803fcc 	andi	r2,r2,255
   4770c:	e0bff70d 	sth	r2,-36(fp)
                data_len = (data_len << 8) + head[7];
   47710:	e0bff70b 	ldhu	r2,-36(fp)
   47714:	1004923a 	slli	r2,r2,8
   47718:	1007883a 	mov	r3,r2
   4771c:	e0bffac3 	ldbu	r2,-21(fp)
   47720:	10803fcc 	andi	r2,r2,255
   47724:	1885883a 	add	r2,r3,r2
   47728:	e0bff70d 	sth	r2,-36(fp)

                addrbsb = (uint32)(ptr<<8) +  (s<<5) + 0x18;
   4772c:	e0bff78b 	ldhu	r2,-34(fp)
   47730:	1004923a 	slli	r2,r2,8
   47734:	1007883a 	mov	r3,r2
   47738:	e0bffb03 	ldbu	r2,-20(fp)
   4773c:	1004917a 	slli	r2,r2,5
   47740:	1885883a 	add	r2,r3,r2
   47744:	10800604 	addi	r2,r2,24
   47748:	e0bff815 	stw	r2,-32(fp)
                wiz_read_buf(addrbsb, buf, data_len);                
   4774c:	e0bff70b 	ldhu	r2,-36(fp)
   47750:	100d883a 	mov	r6,r2
   47754:	e17ffc17 	ldw	r5,-16(fp)
   47758:	e13ff817 	ldw	r4,-32(fp)
   4775c:	00483780 	call	48378 <wiz_read_buf>
                ptr += data_len;
   47760:	e0fff78b 	ldhu	r3,-34(fp)
   47764:	e0bff70b 	ldhu	r2,-36(fp)
   47768:	1885883a 	add	r2,r3,r2
   4776c:	e0bff78d 	sth	r2,-34(fp)

                IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));
   47770:	e0bffb03 	ldbu	r2,-20(fp)
   47774:	1004917a 	slli	r2,r2,5
   47778:	108a0204 	addi	r2,r2,10248
   4777c:	1007883a 	mov	r3,r2
   47780:	e0bff78b 	ldhu	r2,-34(fp)
   47784:	1004d23a 	srli	r2,r2,8
   47788:	10803fcc 	andi	r2,r2,255
   4778c:	100b883a 	mov	r5,r2
   47790:	1809883a 	mov	r4,r3
   47794:	00481840 	call	48184 <IINCHIP_WRITE>
                IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));
   47798:	e0bffb03 	ldbu	r2,-20(fp)
   4779c:	1004917a 	slli	r2,r2,5
   477a0:	108a4204 	addi	r2,r2,10504
   477a4:	1007883a 	mov	r3,r2
   477a8:	e0bff78b 	ldhu	r2,-34(fp)
   477ac:	10803fcc 	andi	r2,r2,255
   477b0:	100b883a 	mov	r5,r2
   477b4:	1809883a 	mov	r4,r3
   477b8:	00481840 	call	48184 <IINCHIP_WRITE>
                break;
   477bc:	00008206 	br	479c8 <recvfrom+0x438>

            case Sn_MR_IPRAW :
                wiz_read_buf(addrbsb, head, 0x06);        
   477c0:	e0bff904 	addi	r2,fp,-28
   477c4:	01800184 	movi	r6,6
   477c8:	100b883a 	mov	r5,r2
   477cc:	e13ff817 	ldw	r4,-32(fp)
   477d0:	00483780 	call	48378 <wiz_read_buf>
                ptr += 6;
   477d4:	e0bff78b 	ldhu	r2,-34(fp)
   477d8:	10800184 	addi	r2,r2,6
   477dc:	e0bff78d 	sth	r2,-34(fp)
                addr[0]  = head[0];
   477e0:	e0fff903 	ldbu	r3,-28(fp)
   477e4:	e0bffe17 	ldw	r2,-8(fp)
   477e8:	10c00005 	stb	r3,0(r2)
                addr[1]  = head[1];
   477ec:	e0bffe17 	ldw	r2,-8(fp)
   477f0:	10800044 	addi	r2,r2,1
   477f4:	e0fff943 	ldbu	r3,-27(fp)
   477f8:	10c00005 	stb	r3,0(r2)
                addr[2]  = head[2];
   477fc:	e0bffe17 	ldw	r2,-8(fp)
   47800:	10800084 	addi	r2,r2,2
   47804:	e0fff983 	ldbu	r3,-26(fp)
   47808:	10c00005 	stb	r3,0(r2)
                addr[3]  = head[3];
   4780c:	e0bffe17 	ldw	r2,-8(fp)
   47810:	108000c4 	addi	r2,r2,3
   47814:	e0fff9c3 	ldbu	r3,-25(fp)
   47818:	10c00005 	stb	r3,0(r2)
                data_len = head[4];
   4781c:	e0bffa03 	ldbu	r2,-24(fp)
   47820:	10803fcc 	andi	r2,r2,255
   47824:	e0bff70d 	sth	r2,-36(fp)
                data_len = (data_len << 8) + head[5];
   47828:	e0bff70b 	ldhu	r2,-36(fp)
   4782c:	1004923a 	slli	r2,r2,8
   47830:	1007883a 	mov	r3,r2
   47834:	e0bffa43 	ldbu	r2,-23(fp)
   47838:	10803fcc 	andi	r2,r2,255
   4783c:	1885883a 	add	r2,r3,r2
   47840:	e0bff70d 	sth	r2,-36(fp)

                addrbsb  = (uint32)(ptr<<8) +  (s<<5) + 0x18;
   47844:	e0bff78b 	ldhu	r2,-34(fp)
   47848:	1004923a 	slli	r2,r2,8
   4784c:	1007883a 	mov	r3,r2
   47850:	e0bffb03 	ldbu	r2,-20(fp)
   47854:	1004917a 	slli	r2,r2,5
   47858:	1885883a 	add	r2,r3,r2
   4785c:	10800604 	addi	r2,r2,24
   47860:	e0bff815 	stw	r2,-32(fp)
                wiz_read_buf(addrbsb, buf, data_len);        
   47864:	e0bff70b 	ldhu	r2,-36(fp)
   47868:	100d883a 	mov	r6,r2
   4786c:	e17ffc17 	ldw	r5,-16(fp)
   47870:	e13ff817 	ldw	r4,-32(fp)
   47874:	00483780 	call	48378 <wiz_read_buf>
                ptr += data_len;
   47878:	e0fff78b 	ldhu	r3,-34(fp)
   4787c:	e0bff70b 	ldhu	r2,-36(fp)
   47880:	1885883a 	add	r2,r3,r2
   47884:	e0bff78d 	sth	r2,-34(fp)

                IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));
   47888:	e0bffb03 	ldbu	r2,-20(fp)
   4788c:	1004917a 	slli	r2,r2,5
   47890:	108a0204 	addi	r2,r2,10248
   47894:	1007883a 	mov	r3,r2
   47898:	e0bff78b 	ldhu	r2,-34(fp)
   4789c:	1004d23a 	srli	r2,r2,8
   478a0:	10803fcc 	andi	r2,r2,255
   478a4:	100b883a 	mov	r5,r2
   478a8:	1809883a 	mov	r4,r3
   478ac:	00481840 	call	48184 <IINCHIP_WRITE>
                IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));
   478b0:	e0bffb03 	ldbu	r2,-20(fp)
   478b4:	1004917a 	slli	r2,r2,5
   478b8:	108a4204 	addi	r2,r2,10504
   478bc:	1007883a 	mov	r3,r2
   478c0:	e0bff78b 	ldhu	r2,-34(fp)
   478c4:	10803fcc 	andi	r2,r2,255
   478c8:	100b883a 	mov	r5,r2
   478cc:	1809883a 	mov	r4,r3
   478d0:	00481840 	call	48184 <IINCHIP_WRITE>
                break;
   478d4:	00003c06 	br	479c8 <recvfrom+0x438>

            case Sn_MR_MACRAW :
                wiz_read_buf(addrbsb, head, 0x02);
   478d8:	e0bff904 	addi	r2,fp,-28
   478dc:	01800084 	movi	r6,2
   478e0:	100b883a 	mov	r5,r2
   478e4:	e13ff817 	ldw	r4,-32(fp)
   478e8:	00483780 	call	48378 <wiz_read_buf>
                ptr+=2;
   478ec:	e0bff78b 	ldhu	r2,-34(fp)
   478f0:	10800084 	addi	r2,r2,2
   478f4:	e0bff78d 	sth	r2,-34(fp)
                data_len = head[0];
   478f8:	e0bff903 	ldbu	r2,-28(fp)
   478fc:	10803fcc 	andi	r2,r2,255
   47900:	e0bff70d 	sth	r2,-36(fp)
                data_len = (data_len<<8) + head[1] - 2;
   47904:	e0bff70b 	ldhu	r2,-36(fp)
   47908:	1004923a 	slli	r2,r2,8
   4790c:	1007883a 	mov	r3,r2
   47910:	e0bff943 	ldbu	r2,-27(fp)
   47914:	10803fcc 	andi	r2,r2,255
   47918:	1885883a 	add	r2,r3,r2
   4791c:	10bfff84 	addi	r2,r2,-2
   47920:	e0bff70d 	sth	r2,-36(fp)
                if(data_len > 1514)
   47924:	e0bff70b 	ldhu	r2,-36(fp)
   47928:	10817af0 	cmpltui	r2,r2,1515
   4792c:	1000011e 	bne	r2,zero,47934 <recvfrom+0x3a4>
                {
                    while(1);
   47930:	003fff06 	br	47930 <__alt_mem_epcs_flash+0xfffc6930>
                }

                addrbsb  = (uint32)(ptr<<8) +  (s<<5) + 0x18;
   47934:	e0bff78b 	ldhu	r2,-34(fp)
   47938:	1004923a 	slli	r2,r2,8
   4793c:	1007883a 	mov	r3,r2
   47940:	e0bffb03 	ldbu	r2,-20(fp)
   47944:	1004917a 	slli	r2,r2,5
   47948:	1885883a 	add	r2,r3,r2
   4794c:	10800604 	addi	r2,r2,24
   47950:	e0bff815 	stw	r2,-32(fp)
                wiz_read_buf(addrbsb, buf, data_len);
   47954:	e0bff70b 	ldhu	r2,-36(fp)
   47958:	100d883a 	mov	r6,r2
   4795c:	e17ffc17 	ldw	r5,-16(fp)
   47960:	e13ff817 	ldw	r4,-32(fp)
   47964:	00483780 	call	48378 <wiz_read_buf>
                ptr += data_len;
   47968:	e0fff78b 	ldhu	r3,-34(fp)
   4796c:	e0bff70b 	ldhu	r2,-36(fp)
   47970:	1885883a 	add	r2,r3,r2
   47974:	e0bff78d 	sth	r2,-34(fp)

                IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));
   47978:	e0bffb03 	ldbu	r2,-20(fp)
   4797c:	1004917a 	slli	r2,r2,5
   47980:	108a0204 	addi	r2,r2,10248
   47984:	1007883a 	mov	r3,r2
   47988:	e0bff78b 	ldhu	r2,-34(fp)
   4798c:	1004d23a 	srli	r2,r2,8
   47990:	10803fcc 	andi	r2,r2,255
   47994:	100b883a 	mov	r5,r2
   47998:	1809883a 	mov	r4,r3
   4799c:	00481840 	call	48184 <IINCHIP_WRITE>
                IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));
   479a0:	e0bffb03 	ldbu	r2,-20(fp)
   479a4:	1004917a 	slli	r2,r2,5
   479a8:	108a4204 	addi	r2,r2,10504
   479ac:	1007883a 	mov	r3,r2
   479b0:	e0bff78b 	ldhu	r2,-34(fp)
   479b4:	10803fcc 	andi	r2,r2,255
   479b8:	100b883a 	mov	r5,r2
   479bc:	1809883a 	mov	r4,r3
   479c0:	00481840 	call	48184 <IINCHIP_WRITE>
                break;
   479c4:	0001883a 	nop

            default :
                break;
        }
        IINCHIP_WRITE( Sn_CR(s) ,Sn_CR_RECV);
   479c8:	e0bffb03 	ldbu	r2,-20(fp)
   479cc:	1004917a 	slli	r2,r2,5
   479d0:	10804204 	addi	r2,r2,264
   479d4:	01401004 	movi	r5,64
   479d8:	1009883a 	mov	r4,r2
   479dc:	00481840 	call	48184 <IINCHIP_WRITE>

        /* wait to process the command... */
        while( IINCHIP_READ( Sn_CR(s)) ) ;
   479e0:	0001883a 	nop
   479e4:	e0bffb03 	ldbu	r2,-20(fp)
   479e8:	1004917a 	slli	r2,r2,5
   479ec:	10804204 	addi	r2,r2,264
   479f0:	1009883a 	mov	r4,r2
   479f4:	00482100 	call	48210 <IINCHIP_READ>
   479f8:	10803fcc 	andi	r2,r2,255
   479fc:	103ff91e 	bne	r2,zero,479e4 <__alt_mem_epcs_flash+0xfffc69e4>
        /* ------- */
    }
    return data_len;
   47a00:	e0bff70b 	ldhu	r2,-36(fp)
}
   47a04:	e6ffff04 	addi	sp,fp,-4
   47a08:	dfc00217 	ldw	ra,8(sp)
   47a0c:	df000117 	ldw	fp,4(sp)
   47a10:	dc000017 	ldw	r16,0(sp)
   47a14:	dec00304 	addi	sp,sp,12
   47a18:	f800283a 	ret

00047a1c <find_index_old>:


// string
// return position
int find_index_old(char * str, char ** array, int length)
{
   47a1c:	defffa04 	addi	sp,sp,-24
   47a20:	dfc00515 	stw	ra,20(sp)
   47a24:	df000415 	stw	fp,16(sp)
   47a28:	df000404 	addi	fp,sp,16
   47a2c:	e13ffd15 	stw	r4,-12(fp)
   47a30:	e17ffe15 	stw	r5,-8(fp)
   47a34:	e1bfff15 	stw	r6,-4(fp)
    int i ;
    for (i = 0; i < length; i++)
   47a38:	e03ffc15 	stw	zero,-16(fp)
   47a3c:	00001006 	br	47a80 <find_index_old+0x64>
    {
        if (strcmp(str, array[i]) == 0)
   47a40:	e0bffc17 	ldw	r2,-16(fp)
   47a44:	1085883a 	add	r2,r2,r2
   47a48:	1085883a 	add	r2,r2,r2
   47a4c:	1007883a 	mov	r3,r2
   47a50:	e0bffe17 	ldw	r2,-8(fp)
   47a54:	10c5883a 	add	r2,r2,r3
   47a58:	10800017 	ldw	r2,0(r2)
   47a5c:	100b883a 	mov	r5,r2
   47a60:	e13ffd17 	ldw	r4,-12(fp)
   47a64:	00496440 	call	49644 <strcmp>
   47a68:	1000021e 	bne	r2,zero,47a74 <find_index_old+0x58>
            return i;
   47a6c:	e0bffc17 	ldw	r2,-16(fp)
   47a70:	00000706 	br	47a90 <find_index_old+0x74>
// string
// return position
int find_index_old(char * str, char ** array, int length)
{
    int i ;
    for (i = 0; i < length; i++)
   47a74:	e0bffc17 	ldw	r2,-16(fp)
   47a78:	10800044 	addi	r2,r2,1
   47a7c:	e0bffc15 	stw	r2,-16(fp)
   47a80:	e0fffc17 	ldw	r3,-16(fp)
   47a84:	e0bfff17 	ldw	r2,-4(fp)
   47a88:	18bfed16 	blt	r3,r2,47a40 <__alt_mem_epcs_flash+0xfffc6a40>
    {
        if (strcmp(str, array[i]) == 0)
            return i;
    }
    return -1;
   47a8c:	00bfffc4 	movi	r2,-1
}
   47a90:	e037883a 	mov	sp,fp
   47a94:	dfc00117 	ldw	ra,4(sp)
   47a98:	df000017 	ldw	fp,0(sp)
   47a9c:	dec00204 	addi	sp,sp,8
   47aa0:	f800283a 	ret

00047aa4 <timer_initial>:
#include "fpga2nios_protocol.h"
#include "nios2fpga_protocol.h"
alt_u32 timer_isr_context;

void timer_initial(void)
{
   47aa4:	defffc04 	addi	sp,sp,-16
   47aa8:	dfc00315 	stw	ra,12(sp)
   47aac:	df000215 	stw	fp,8(sp)
   47ab0:	df000204 	addi	fp,sp,8
    // 1s/8-1
    // 100ms/8-1 = 0xbebc1f
    // 10ms/8-1 = 0x1312cf
    // 1ms/10-1 = 0xf4240
    void *isr_context_ptr = (void *)&timer_isr_context;
   47ab4:	d0a01804 	addi	r2,gp,-32672
   47ab8:	e0bfff15 	stw	r2,-4(fp)
    IOWR_ALTERA_AVALON_TIMER_PERIODH(LED_TIMER_BASE, 0x000f);
   47abc:	00c003c4 	movi	r3,15
   47ac0:	00800234 	movhi	r2,8
   47ac4:	10882b04 	addi	r2,r2,8364
   47ac8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_TIMER_PERIODL(LED_TIMER_BASE, 0x4240);
   47acc:	00d09004 	movi	r3,16960
   47ad0:	00800234 	movhi	r2,8
   47ad4:	10882a04 	addi	r2,r2,8360
   47ad8:	10c00035 	stwio	r3,0(r2)

    IOWR_ALTERA_AVALON_TIMER_CONTROL(
   47adc:	00c001c4 	movi	r3,7
   47ae0:	00800234 	movhi	r2,8
   47ae4:	10882904 	addi	r2,r2,8356
   47ae8:	10c00035 	stwio	r3,0(r2)
        LED_TIMER_BASE,
        ALTERA_AVALON_TIMER_CONTROL_START_MSK |
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);

    alt_ic_isr_register(
   47aec:	d8000015 	stw	zero,0(sp)
   47af0:	e1ffff17 	ldw	r7,-4(fp)
   47af4:	01800134 	movhi	r6,4
   47af8:	319ec804 	addi	r6,r6,31520
   47afc:	01400084 	movi	r5,2
   47b00:	0009883a 	mov	r4,zero
   47b04:	00499440 	call	49944 <alt_ic_isr_register>
        LED_TIMER_IRQ_INTERRUPT_CONTROLLER_ID,
        LED_TIMER_IRQ,
        timer_isr_interrupt,
        isr_context_ptr,
        0x00);
}
   47b08:	0001883a 	nop
   47b0c:	e037883a 	mov	sp,fp
   47b10:	dfc00117 	ldw	ra,4(sp)
   47b14:	df000017 	ldw	fp,0(sp)
   47b18:	dec00204 	addi	sp,sp,8
   47b1c:	f800283a 	ret

00047b20 <timer_isr_interrupt>:

void timer_isr_interrupt(void *isr_context, alt_u32 id)
{
   47b20:	defffc04 	addi	sp,sp,-16
   47b24:	dfc00315 	stw	ra,12(sp)
   47b28:	df000215 	stw	fp,8(sp)
   47b2c:	df000204 	addi	fp,sp,8
   47b30:	e13ffe15 	stw	r4,-8(fp)
   47b34:	e17fff15 	stw	r5,-4(fp)
    IOWR_ALTERA_AVALON_TIMER_STATUS(LED_TIMER_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK);
   47b38:	00ffff84 	movi	r3,-2
   47b3c:	00800234 	movhi	r2,8
   47b40:	10882804 	addi	r2,r2,8352
   47b44:	10c00035 	stwio	r3,0(r2)

    if(led_time_flag.cnt_1s == 50)
   47b48:	008001b4 	movhi	r2,6
   47b4c:	10801d04 	addi	r2,r2,116
   47b50:	10800183 	ldbu	r2,6(r2)
   47b54:	10803fcc 	andi	r2,r2,255
   47b58:	10800c98 	cmpnei	r2,r2,50
   47b5c:	1000081e 	bne	r2,zero,47b80 <timer_isr_interrupt+0x60>
    {
        led_time_flag.cnt_1s             = 0;
   47b60:	008001b4 	movhi	r2,6
   47b64:	10801d04 	addi	r2,r2,116
   47b68:	10000185 	stb	zero,6(r2)
        led_time_flag.status_led_1s_flag = 0x01;
   47b6c:	008001b4 	movhi	r2,6
   47b70:	10801d04 	addi	r2,r2,116
   47b74:	00c00044 	movi	r3,1
   47b78:	10c001c5 	stb	r3,7(r2)
   47b7c:	00000806 	br	47ba0 <timer_isr_interrupt+0x80>
//        led_time_flag.power_led_value = (~led_time_flag.power_led_value) & 0x01;

//        led_power_light(led_time_flag.power_led_value);
    }
    else
        led_time_flag.cnt_1s++;
   47b80:	008001b4 	movhi	r2,6
   47b84:	10801d04 	addi	r2,r2,116
   47b88:	10800183 	ldbu	r2,6(r2)
   47b8c:	10800044 	addi	r2,r2,1
   47b90:	1007883a 	mov	r3,r2
   47b94:	008001b4 	movhi	r2,6
   47b98:	10801d04 	addi	r2,r2,116
   47b9c:	10c00185 	stb	r3,6(r2)

    if(led_time_flag.cnt_300ms == 15)
   47ba0:	008001b4 	movhi	r2,6
   47ba4:	10801d04 	addi	r2,r2,116
   47ba8:	108002c3 	ldbu	r2,11(r2)
   47bac:	10803fcc 	andi	r2,r2,255
   47bb0:	108003d8 	cmpnei	r2,r2,15
   47bb4:	1000081e 	bne	r2,zero,47bd8 <timer_isr_interrupt+0xb8>
        {
            led_time_flag.cnt_300ms             = 0;
   47bb8:	008001b4 	movhi	r2,6
   47bbc:	10801d04 	addi	r2,r2,116
   47bc0:	100002c5 	stb	zero,11(r2)
            led_time_flag.status_led_300ms_flag = 0x01;
   47bc4:	008001b4 	movhi	r2,6
   47bc8:	10801d04 	addi	r2,r2,116
   47bcc:	00c00044 	movi	r3,1
   47bd0:	10c00285 	stb	r3,10(r2)
   47bd4:	00000806 	br	47bf8 <timer_isr_interrupt+0xd8>
        }
        else
            led_time_flag.cnt_300ms++;
   47bd8:	008001b4 	movhi	r2,6
   47bdc:	10801d04 	addi	r2,r2,116
   47be0:	108002c3 	ldbu	r2,11(r2)
   47be4:	10800044 	addi	r2,r2,1
   47be8:	1007883a 	mov	r3,r2
   47bec:	008001b4 	movhi	r2,6
   47bf0:	10801d04 	addi	r2,r2,116
   47bf4:	10c002c5 	stb	r3,11(r2)


 //2sѡ
    if(led_time_flag.cnt_2s_p == 100)
   47bf8:	008001b4 	movhi	r2,6
   47bfc:	10801d04 	addi	r2,r2,116
   47c00:	10800083 	ldbu	r2,2(r2)
   47c04:	10803fcc 	andi	r2,r2,255
   47c08:	10801918 	cmpnei	r2,r2,100
   47c0c:	1000081e 	bne	r2,zero,47c30 <timer_isr_interrupt+0x110>
    {
        led_time_flag.cnt_2s_p             = 0;
   47c10:	008001b4 	movhi	r2,6
   47c14:	10801d04 	addi	r2,r2,116
   47c18:	10000085 	stb	zero,2(r2)
        led_time_flag.power_led_2s_flag = 0x01;
   47c1c:	008001b4 	movhi	r2,6
   47c20:	10801d04 	addi	r2,r2,116
   47c24:	00c00044 	movi	r3,1
   47c28:	10c000c5 	stb	r3,3(r2)
   47c2c:	00000806 	br	47c50 <timer_isr_interrupt+0x130>
    }
    else
        led_time_flag.cnt_2s_p++;
   47c30:	008001b4 	movhi	r2,6
   47c34:	10801d04 	addi	r2,r2,116
   47c38:	10800083 	ldbu	r2,2(r2)
   47c3c:	10800044 	addi	r2,r2,1
   47c40:	1007883a 	mov	r3,r2
   47c44:	008001b4 	movhi	r2,6
   47c48:	10801d04 	addi	r2,r2,116
   47c4c:	10c00085 	stb	r3,2(r2)

    if(led_time_flag.cnt_1s_p == 50)
   47c50:	008001b4 	movhi	r2,6
   47c54:	10801d04 	addi	r2,r2,116
   47c58:	10800143 	ldbu	r2,5(r2)
   47c5c:	10803fcc 	andi	r2,r2,255
   47c60:	10800c98 	cmpnei	r2,r2,50
   47c64:	1000081e 	bne	r2,zero,47c88 <timer_isr_interrupt+0x168>
    {
        led_time_flag.cnt_1s_p             = 0;
   47c68:	008001b4 	movhi	r2,6
   47c6c:	10801d04 	addi	r2,r2,116
   47c70:	10000145 	stb	zero,5(r2)
        led_time_flag.power_led_1s_flag = 0x01;
   47c74:	008001b4 	movhi	r2,6
   47c78:	10801d04 	addi	r2,r2,116
   47c7c:	00c00044 	movi	r3,1
   47c80:	10c00105 	stb	r3,4(r2)
   47c84:	00000806 	br	47ca8 <timer_isr_interrupt+0x188>
    }
    else
        led_time_flag.cnt_1s_p++;
   47c88:	008001b4 	movhi	r2,6
   47c8c:	10801d04 	addi	r2,r2,116
   47c90:	10800143 	ldbu	r2,5(r2)
   47c94:	10800044 	addi	r2,r2,1
   47c98:	1007883a 	mov	r3,r2
   47c9c:	008001b4 	movhi	r2,6
   47ca0:	10801d04 	addi	r2,r2,116
   47ca4:	10c00145 	stb	r3,5(r2)
    if(led_time_flag.cnt_300ms_p == 15)
   47ca8:	008001b4 	movhi	r2,6
   47cac:	10801d04 	addi	r2,r2,116
   47cb0:	10800243 	ldbu	r2,9(r2)
   47cb4:	10803fcc 	andi	r2,r2,255
   47cb8:	108003d8 	cmpnei	r2,r2,15
   47cbc:	1000081e 	bne	r2,zero,47ce0 <timer_isr_interrupt+0x1c0>
    {
        led_time_flag.cnt_300ms_p             = 0;
   47cc0:	008001b4 	movhi	r2,6
   47cc4:	10801d04 	addi	r2,r2,116
   47cc8:	10000245 	stb	zero,9(r2)
        led_time_flag.power_led_300ms_flag = 0x01;
   47ccc:	008001b4 	movhi	r2,6
   47cd0:	10801d04 	addi	r2,r2,116
   47cd4:	00c00044 	movi	r3,1
   47cd8:	10c00205 	stb	r3,8(r2)
   47cdc:	00000806 	br	47d00 <timer_isr_interrupt+0x1e0>
    }
    else
        led_time_flag.cnt_300ms_p++;
   47ce0:	008001b4 	movhi	r2,6
   47ce4:	10801d04 	addi	r2,r2,116
   47ce8:	10800243 	ldbu	r2,9(r2)
   47cec:	10800044 	addi	r2,r2,1
   47cf0:	1007883a 	mov	r3,r2
   47cf4:	008001b4 	movhi	r2,6
   47cf8:	10801d04 	addi	r2,r2,116
   47cfc:	10c00245 	stb	r3,9(r2)

    if(led_time_flag.cnt_30ms == 3)
   47d00:	008001b4 	movhi	r2,6
   47d04:	10801d04 	addi	r2,r2,116
   47d08:	10800303 	ldbu	r2,12(r2)
   47d0c:	10803fcc 	andi	r2,r2,255
   47d10:	108000d8 	cmpnei	r2,r2,3
   47d14:	1000221e 	bne	r2,zero,47da0 <timer_isr_interrupt+0x280>
        {
            alarm_region.last_io_value[0] = rd_switch_io_value();
   47d18:	0045d3c0 	call	45d3c <rd_switch_io_value>
   47d1c:	1007883a 	mov	r3,r2
   47d20:	008001b4 	movhi	r2,6
   47d24:	10a5c204 	addi	r2,r2,-26872
   47d28:	10c00005 	stb	r3,0(r2)
            if(alarm_region.last_io_value[0] != alarm_region.last_io_value[1])
   47d2c:	008001b4 	movhi	r2,6
   47d30:	10a5c204 	addi	r2,r2,-26872
   47d34:	10c00003 	ldbu	r3,0(r2)
   47d38:	008001b4 	movhi	r2,6
   47d3c:	10a5c204 	addi	r2,r2,-26872
   47d40:	10800043 	ldbu	r2,1(r2)
   47d44:	18c03fcc 	andi	r3,r3,255
   47d48:	10803fcc 	andi	r2,r2,255
   47d4c:	18800a26 	beq	r3,r2,47d78 <timer_isr_interrupt+0x258>
            {
                alarm_region.change_region_flag  = 0x01;
   47d50:	008001b4 	movhi	r2,6
   47d54:	10a5c204 	addi	r2,r2,-26872
   47d58:	00c00044 	movi	r3,1
   47d5c:	10c00085 	stb	r3,2(r2)
                alarm_region.change_region_value = alarm_region.last_io_value[0];
   47d60:	008001b4 	movhi	r2,6
   47d64:	10a5c204 	addi	r2,r2,-26872
   47d68:	10c00003 	ldbu	r3,0(r2)
   47d6c:	008001b4 	movhi	r2,6
   47d70:	10a5c204 	addi	r2,r2,-26872
   47d74:	10c000c5 	stb	r3,3(r2)
            }
            alarm_region.last_io_value[1] = alarm_region.last_io_value[0];
   47d78:	008001b4 	movhi	r2,6
   47d7c:	10a5c204 	addi	r2,r2,-26872
   47d80:	10c00003 	ldbu	r3,0(r2)
   47d84:	008001b4 	movhi	r2,6
   47d88:	10a5c204 	addi	r2,r2,-26872
   47d8c:	10c00045 	stb	r3,1(r2)
            led_time_flag.cnt_30ms        = 0;
   47d90:	008001b4 	movhi	r2,6
   47d94:	10801d04 	addi	r2,r2,116
   47d98:	10000305 	stb	zero,12(r2)
   47d9c:	00000806 	br	47dc0 <timer_isr_interrupt+0x2a0>
        }
        else
            led_time_flag.cnt_30ms++;
   47da0:	008001b4 	movhi	r2,6
   47da4:	10801d04 	addi	r2,r2,116
   47da8:	10800303 	ldbu	r2,12(r2)
   47dac:	10800044 	addi	r2,r2,1
   47db0:	1007883a 	mov	r3,r2
   47db4:	008001b4 	movhi	r2,6
   47db8:	10801d04 	addi	r2,r2,116
   47dbc:	10c00305 	stb	r3,12(r2)



       if(sys_warn.region_alarm)
   47dc0:	008001b4 	movhi	r2,6
   47dc4:	10b46104 	addi	r2,r2,-11900
   47dc8:	10800417 	ldw	r2,16(r2)
   47dcc:	10005a26 	beq	r2,zero,47f38 <timer_isr_interrupt+0x418>
       {

           if(sys_warn.region_alarm & 0x01)
   47dd0:	008001b4 	movhi	r2,6
   47dd4:	10b46104 	addi	r2,r2,-11900
   47dd8:	10800417 	ldw	r2,16(r2)
   47ddc:	1080004c 	andi	r2,r2,1
   47de0:	10001926 	beq	r2,zero,47e48 <timer_isr_interrupt+0x328>
           {
           	    if(led_time_flag.power_led_300ms_flag)
   47de4:	008001b4 	movhi	r2,6
   47de8:	10801d04 	addi	r2,r2,116
   47dec:	10800203 	ldbu	r2,8(r2)
   47df0:	10803fcc 	andi	r2,r2,255
   47df4:	10005a26 	beq	r2,zero,47f60 <timer_isr_interrupt+0x440>
           	    {
          	        led_time_flag.power_led_300ms_flag = 0x00;
   47df8:	008001b4 	movhi	r2,6
   47dfc:	10801d04 	addi	r2,r2,116
   47e00:	10000205 	stb	zero,8(r2)
           	        led_time_flag.power_led_value      = (~led_time_flag.power_led_value) & 0x01;
   47e04:	008001b4 	movhi	r2,6
   47e08:	10801d04 	addi	r2,r2,116
   47e0c:	10800003 	ldbu	r2,0(r2)
   47e10:	10803fcc 	andi	r2,r2,255
   47e14:	1080004c 	andi	r2,r2,1
   47e18:	1005003a 	cmpeq	r2,r2,zero
   47e1c:	1007883a 	mov	r3,r2
   47e20:	008001b4 	movhi	r2,6
   47e24:	10801d04 	addi	r2,r2,116
   47e28:	10c00005 	stb	r3,0(r2)
           	        led_power_light(led_time_flag.power_led_value);
   47e2c:	008001b4 	movhi	r2,6
   47e30:	10801d04 	addi	r2,r2,116
   47e34:	10800003 	ldbu	r2,0(r2)
   47e38:	10803fcc 	andi	r2,r2,255
   47e3c:	1009883a 	mov	r4,r2
   47e40:	00423bc0 	call	423bc <led_power_light>
       else if(~sys_warn.region_alarm |isPowerUp)
       {
       	   led_power_light(LED_ON);
       }

}
   47e44:	00004606 	br	47f60 <timer_isr_interrupt+0x440>
          	        led_time_flag.power_led_300ms_flag = 0x00;
           	        led_time_flag.power_led_value      = (~led_time_flag.power_led_value) & 0x01;
           	        led_power_light(led_time_flag.power_led_value);
           	    }
           }
           else if(sys_warn.region_alarm & 0x02)
   47e48:	008001b4 	movhi	r2,6
   47e4c:	10b46104 	addi	r2,r2,-11900
   47e50:	10800417 	ldw	r2,16(r2)
   47e54:	1080008c 	andi	r2,r2,2
   47e58:	10001926 	beq	r2,zero,47ec0 <timer_isr_interrupt+0x3a0>
           {
           	    if(led_time_flag.power_led_1s_flag)
   47e5c:	008001b4 	movhi	r2,6
   47e60:	10801d04 	addi	r2,r2,116
   47e64:	10800103 	ldbu	r2,4(r2)
   47e68:	10803fcc 	andi	r2,r2,255
   47e6c:	10003c26 	beq	r2,zero,47f60 <timer_isr_interrupt+0x440>
           	    {
           	        led_time_flag.power_led_1s_flag = 0x00;
   47e70:	008001b4 	movhi	r2,6
   47e74:	10801d04 	addi	r2,r2,116
   47e78:	10000105 	stb	zero,4(r2)
                	led_time_flag.power_led_value      = (~led_time_flag.power_led_value) & 0x01;
   47e7c:	008001b4 	movhi	r2,6
   47e80:	10801d04 	addi	r2,r2,116
   47e84:	10800003 	ldbu	r2,0(r2)
   47e88:	10803fcc 	andi	r2,r2,255
   47e8c:	1080004c 	andi	r2,r2,1
   47e90:	1005003a 	cmpeq	r2,r2,zero
   47e94:	1007883a 	mov	r3,r2
   47e98:	008001b4 	movhi	r2,6
   47e9c:	10801d04 	addi	r2,r2,116
   47ea0:	10c00005 	stb	r3,0(r2)
           	        led_power_light(led_time_flag.power_led_value);
   47ea4:	008001b4 	movhi	r2,6
   47ea8:	10801d04 	addi	r2,r2,116
   47eac:	10800003 	ldbu	r2,0(r2)
   47eb0:	10803fcc 	andi	r2,r2,255
   47eb4:	1009883a 	mov	r4,r2
   47eb8:	00423bc0 	call	423bc <led_power_light>
       else if(~sys_warn.region_alarm |isPowerUp)
       {
       	   led_power_light(LED_ON);
       }

}
   47ebc:	00002806 	br	47f60 <timer_isr_interrupt+0x440>
           	        led_time_flag.power_led_1s_flag = 0x00;
                	led_time_flag.power_led_value      = (~led_time_flag.power_led_value) & 0x01;
           	        led_power_light(led_time_flag.power_led_value);
           	    }
           }
           else if(sys_warn.region_alarm & 0x04)
   47ec0:	008001b4 	movhi	r2,6
   47ec4:	10b46104 	addi	r2,r2,-11900
   47ec8:	10800417 	ldw	r2,16(r2)
   47ecc:	1080010c 	andi	r2,r2,4
   47ed0:	10002326 	beq	r2,zero,47f60 <timer_isr_interrupt+0x440>
           {
           	    if(led_time_flag.power_led_2s_flag)
   47ed4:	008001b4 	movhi	r2,6
   47ed8:	10801d04 	addi	r2,r2,116
   47edc:	108000c3 	ldbu	r2,3(r2)
   47ee0:	10803fcc 	andi	r2,r2,255
   47ee4:	10001e26 	beq	r2,zero,47f60 <timer_isr_interrupt+0x440>
             	{
                   led_time_flag.power_led_2s_flag = 0x00;
   47ee8:	008001b4 	movhi	r2,6
   47eec:	10801d04 	addi	r2,r2,116
   47ef0:	100000c5 	stb	zero,3(r2)
                   led_time_flag.power_led_value      = (~led_time_flag.power_led_value) & 0x01;
   47ef4:	008001b4 	movhi	r2,6
   47ef8:	10801d04 	addi	r2,r2,116
   47efc:	10800003 	ldbu	r2,0(r2)
   47f00:	10803fcc 	andi	r2,r2,255
   47f04:	1080004c 	andi	r2,r2,1
   47f08:	1005003a 	cmpeq	r2,r2,zero
   47f0c:	1007883a 	mov	r3,r2
   47f10:	008001b4 	movhi	r2,6
   47f14:	10801d04 	addi	r2,r2,116
   47f18:	10c00005 	stb	r3,0(r2)
                   led_power_light(led_time_flag.power_led_value);
   47f1c:	008001b4 	movhi	r2,6
   47f20:	10801d04 	addi	r2,r2,116
   47f24:	10800003 	ldbu	r2,0(r2)
   47f28:	10803fcc 	andi	r2,r2,255
   47f2c:	1009883a 	mov	r4,r2
   47f30:	00423bc0 	call	423bc <led_power_light>
       else if(~sys_warn.region_alarm |isPowerUp)
       {
       	   led_power_light(LED_ON);
       }

}
   47f34:	00000a06 	br	47f60 <timer_isr_interrupt+0x440>
                   led_time_flag.power_led_value      = (~led_time_flag.power_led_value) & 0x01;
                   led_power_light(led_time_flag.power_led_value);
           	    }
           }
       }
       else if(~sys_warn.region_alarm |isPowerUp)
   47f38:	008001b4 	movhi	r2,6
   47f3c:	10b46104 	addi	r2,r2,-11900
   47f40:	10800417 	ldw	r2,16(r2)
   47f44:	0086303a 	nor	r3,zero,r2
   47f48:	d0a01503 	ldbu	r2,-32684(gp)
   47f4c:	10803fcc 	andi	r2,r2,255
   47f50:	1884b03a 	or	r2,r3,r2
   47f54:	10000226 	beq	r2,zero,47f60 <timer_isr_interrupt+0x440>
       {
       	   led_power_light(LED_ON);
   47f58:	0009883a 	mov	r4,zero
   47f5c:	00423bc0 	call	423bc <led_power_light>
       }

}
   47f60:	0001883a 	nop
   47f64:	e037883a 	mov	sp,fp
   47f68:	dfc00117 	ldw	ra,4(sp)
   47f6c:	df000017 	ldw	fp,0(sp)
   47f70:	dec00204 	addi	sp,sp,8
   47f74:	f800283a 	ret

00047f78 <watchdog_init>:
////    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(ALARM_SELECT_BASE, 0x00);
//    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ALARM_SELECT_BASE, 0xff);
//}

void watchdog_init(void)
{
   47f78:	deffff04 	addi	sp,sp,-4
   47f7c:	df000015 	stw	fp,0(sp)
   47f80:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_TIMER_CONTROL(WATCHDOG_BASE, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
   47f84:	00c00104 	movi	r3,4
   47f88:	00800234 	movhi	r2,8
   47f8c:	10882104 	addi	r2,r2,8324
   47f90:	10c00035 	stwio	r3,0(r2)
}
   47f94:	0001883a 	nop
   47f98:	e037883a 	mov	sp,fp
   47f9c:	df000017 	ldw	fp,0(sp)
   47fa0:	dec00104 	addi	sp,sp,4
   47fa4:	f800283a 	ret

00047fa8 <watchdog_feed>:

void watchdog_feed(void)
{
   47fa8:	deffff04 	addi	sp,sp,-4
   47fac:	df000015 	stw	fp,0(sp)
   47fb0:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_TIMER_PERIODL(WATCHDOG_BASE, 0x1234);
   47fb4:	00c48d04 	movi	r3,4660
   47fb8:	00800234 	movhi	r2,8
   47fbc:	10882204 	addi	r2,r2,8328
   47fc0:	10c00035 	stwio	r3,0(r2)
}
   47fc4:	0001883a 	nop
   47fc8:	e037883a 	mov	sp,fp
   47fcc:	df000017 	ldw	fp,0(sp)
   47fd0:	dec00104 	addi	sp,sp,4
   47fd4:	f800283a 	ret

00047fd8 <IINCHIP_CSoff>:

static uint16 SSIZE[MAX_SOCK_NUM]; /**< Max Tx buffer size by each channel */
static uint16 RSIZE[MAX_SOCK_NUM]; /**< Max Rx buffer size by each channel */

void IINCHIP_CSoff()
{
   47fd8:	deffff04 	addi	sp,sp,-4
   47fdc:	df000015 	stw	fp,0(sp)
   47fe0:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DATA(W5500_CS_BASE, 0);
   47fe4:	0007883a 	mov	r3,zero
   47fe8:	00800234 	movhi	r2,8
   47fec:	10886404 	addi	r2,r2,8592
   47ff0:	10c00035 	stwio	r3,0(r2)
}
   47ff4:	0001883a 	nop
   47ff8:	e037883a 	mov	sp,fp
   47ffc:	df000017 	ldw	fp,0(sp)
   48000:	dec00104 	addi	sp,sp,4
   48004:	f800283a 	ret

00048008 <IINCHIP_CSon>:

void IINCHIP_CSon()
{
   48008:	deffff04 	addi	sp,sp,-4
   4800c:	df000015 	stw	fp,0(sp)
   48010:	d839883a 	mov	fp,sp
    IOWR_ALTERA_AVALON_PIO_DATA(W5500_CS_BASE, 1);
   48014:	00c00044 	movi	r3,1
   48018:	00800234 	movhi	r2,8
   4801c:	10886404 	addi	r2,r2,8592
   48020:	10c00035 	stwio	r3,0(r2)
}
   48024:	0001883a 	nop
   48028:	e037883a 	mov	sp,fp
   4802c:	df000017 	ldw	fp,0(sp)
   48030:	dec00104 	addi	sp,sp,4
   48034:	f800283a 	ret

00048038 <getIINCHIP_RxMAX>:


uint16 getIINCHIP_RxMAX(uint8 s)
{
   48038:	defffe04 	addi	sp,sp,-8
   4803c:	df000115 	stw	fp,4(sp)
   48040:	df000104 	addi	fp,sp,4
   48044:	2005883a 	mov	r2,r4
   48048:	e0bfff05 	stb	r2,-4(fp)
    return RSIZE[s];
   4804c:	e0ffff03 	ldbu	r3,-4(fp)
   48050:	008001b4 	movhi	r2,6
   48054:	10b47f04 	addi	r2,r2,-11780
   48058:	18c7883a 	add	r3,r3,r3
   4805c:	10c5883a 	add	r2,r2,r3
   48060:	1080000b 	ldhu	r2,0(r2)
}
   48064:	e037883a 	mov	sp,fp
   48068:	df000017 	ldw	fp,0(sp)
   4806c:	dec00104 	addi	sp,sp,4
   48070:	f800283a 	ret

00048074 <getIINCHIP_TxMAX>:
uint16 getIINCHIP_TxMAX(uint8 s)
{
   48074:	defffe04 	addi	sp,sp,-8
   48078:	df000115 	stw	fp,4(sp)
   4807c:	df000104 	addi	fp,sp,4
   48080:	2005883a 	mov	r2,r4
   48084:	e0bfff05 	stb	r2,-4(fp)
    return SSIZE[s];
   48088:	e0ffff03 	ldbu	r3,-4(fp)
   4808c:	008001b4 	movhi	r2,6
   48090:	10b47b04 	addi	r2,r2,-11796
   48094:	18c7883a 	add	r3,r3,r3
   48098:	10c5883a 	add	r2,r2,r3
   4809c:	1080000b 	ldhu	r2,0(r2)
}
   480a0:	e037883a 	mov	sp,fp
   480a4:	df000017 	ldw	fp,0(sp)
   480a8:	dec00104 	addi	sp,sp,4
   480ac:	f800283a 	ret

000480b0 <IINCHIP_SpiSendData>:

unsigned char IINCHIP_SpiSendData(uint16 dat)
{
   480b0:	defffd04 	addi	sp,sp,-12
   480b4:	dfc00215 	stw	ra,8(sp)
   480b8:	df000115 	stw	fp,4(sp)
   480bc:	df000104 	addi	fp,sp,4
   480c0:	2005883a 	mov	r2,r4
   480c4:	e0bfff0d 	sth	r2,-4(fp)
    // return(alt_avalon_spi_command(SPI_BASE, 0, 1, &dat, 0, NULL, 0));
    altera_avalon_fifo_write_fifo(SPIWR_FIFO_IN_BASE, SPIWR_FIFO_IN_CSR_BASE, (dat>>16) + (dat<<16));
   480c8:	e0bfff0b 	ldhu	r2,-4(fp)
   480cc:	1007d43a 	srai	r3,r2,16
   480d0:	e0bfff0b 	ldhu	r2,-4(fp)
   480d4:	1004943a 	slli	r2,r2,16
   480d8:	1885883a 	add	r2,r3,r2
   480dc:	100d883a 	mov	r6,r2
   480e0:	01400234 	movhi	r5,8
   480e4:	29483804 	addi	r5,r5,8416
   480e8:	01000234 	movhi	r4,8
   480ec:	21087804 	addi	r4,r4,8672
   480f0:	004ad040 	call	4ad04 <altera_avalon_fifo_write_fifo>
    return 0;
   480f4:	0005883a 	mov	r2,zero
}
   480f8:	e037883a 	mov	sp,fp
   480fc:	dfc00117 	ldw	ra,4(sp)
   48100:	df000017 	ldw	fp,0(sp)
   48104:	dec00204 	addi	sp,sp,8
   48108:	f800283a 	ret

0004810c <SPI_I2S_ReceiveData>:

unsigned char SPI_I2S_ReceiveData()
{
   4810c:	defffb04 	addi	sp,sp,-20
   48110:	dfc00415 	stw	ra,16(sp)
   48114:	df000315 	stw	fp,12(sp)
   48118:	df000304 	addi	fp,sp,12
    //unsigned char rxbuf = 0;
    //alt_avalon_spi_command(SPI_BASE, 0, 0, NULL, 1, &rxbuf, 0);
    //return rxbuf;
	int num;
	unsigned int data;
	unsigned char rxbuf = 0;
   4811c:	e03ffd05 	stb	zero,-12(fp)
	num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);
   48120:	01000234 	movhi	r4,8
   48124:	21083004 	addi	r4,r4,8384
   48128:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   4812c:	e0bffe15 	stw	r2,-8(fp)
	if(num > 0)
   48130:	e0bffe17 	ldw	r2,-8(fp)
   48134:	0080090e 	bge	zero,r2,4815c <SPI_I2S_ReceiveData+0x50>
	{
		data = altera_avalon_fifo_read_fifo(SPIRD_FIFO_OUT_BASE, SPIRD_FIFO_IN_CSR_BASE);
   48138:	01400234 	movhi	r5,8
   4813c:	29483004 	addi	r5,r5,8384
   48140:	01000234 	movhi	r4,8
   48144:	21087604 	addi	r4,r4,8664
   48148:	004adc80 	call	4adc8 <altera_avalon_fifo_read_fifo>
   4814c:	e0bfff15 	stw	r2,-4(fp)
		rxbuf = (unsigned char)( ((data>>16) + (data<<16))& 0xff);
   48150:	e0bfff17 	ldw	r2,-4(fp)
   48154:	1004d43a 	srli	r2,r2,16
   48158:	e0bffd05 	stb	r2,-12(fp)
	}

	num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);
   4815c:	01000234 	movhi	r4,8
   48160:	21083004 	addi	r4,r4,8384
   48164:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   48168:	e0bffe15 	stw	r2,-8(fp)
	return rxbuf;
   4816c:	e0bffd03 	ldbu	r2,-12(fp)
}
   48170:	e037883a 	mov	sp,fp
   48174:	dfc00117 	ldw	ra,4(sp)
   48178:	df000017 	ldw	fp,0(sp)
   4817c:	dec00204 	addi	sp,sp,8
   48180:	f800283a 	ret

00048184 <IINCHIP_WRITE>:

void IINCHIP_WRITE( uint32 addrbsb,  uint8 data)
{
   48184:	defffc04 	addi	sp,sp,-16
   48188:	dfc00315 	stw	ra,12(sp)
   4818c:	df000215 	stw	fp,8(sp)
   48190:	df000204 	addi	fp,sp,8
   48194:	e13ffe15 	stw	r4,-8(fp)
   48198:	2805883a 	mov	r2,r5
   4819c:	e0bfff05 	stb	r2,-4(fp)
    IINCHIP_ISR_DISABLE();                        // Interrupt Service Routine Disable
    IINCHIP_CSoff();                              // CS=0, SPI start
   481a0:	0047fd80 	call	47fd8 <IINCHIP_CSoff>
    IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
   481a4:	e0bffe17 	ldw	r2,-8(fp)
   481a8:	10803fec 	andhi	r2,r2,255
   481ac:	1004d43a 	srli	r2,r2,16
   481b0:	1009883a 	mov	r4,r2
   481b4:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
   481b8:	e0bffe17 	ldw	r2,-8(fp)
   481bc:	10bfc00c 	andi	r2,r2,65280
   481c0:	1004d23a 	srli	r2,r2,8
   481c4:	10bfffcc 	andi	r2,r2,65535
   481c8:	1009883a 	mov	r4,r2
   481cc:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x000000F8) + 4);    // Data write command and Write data length 1
   481d0:	e0bffe17 	ldw	r2,-8(fp)
   481d4:	10803e0c 	andi	r2,r2,248
   481d8:	10800104 	addi	r2,r2,4
   481dc:	10bfffcc 	andi	r2,r2,65535
   481e0:	1009883a 	mov	r4,r2
   481e4:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData(data);                    // Data write (write 1byte data)
   481e8:	e0bfff03 	ldbu	r2,-4(fp)
   481ec:	1009883a 	mov	r4,r2
   481f0:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_CSon();                               // CS=1,  SPI end
   481f4:	00480080 	call	48008 <IINCHIP_CSon>
    IINCHIP_ISR_ENABLE();                         // Interrupt Service Routine Enable
}
   481f8:	0001883a 	nop
   481fc:	e037883a 	mov	sp,fp
   48200:	dfc00117 	ldw	ra,4(sp)
   48204:	df000017 	ldw	fp,0(sp)
   48208:	dec00204 	addi	sp,sp,8
   4820c:	f800283a 	ret

00048210 <IINCHIP_READ>:

uint8 IINCHIP_READ(uint32 addrbsb)
{
   48210:	defffc04 	addi	sp,sp,-16
   48214:	dfc00315 	stw	ra,12(sp)
   48218:	df000215 	stw	fp,8(sp)
   4821c:	df000204 	addi	fp,sp,8
   48220:	e13fff15 	stw	r4,-4(fp)
	uint16 num;
    uint8 data = 0;
   48224:	e03ffe85 	stb	zero,-6(fp)
    IINCHIP_ISR_DISABLE();                        // Interrupt Service Routine Disable
    IINCHIP_CSoff();                              // CS=0, SPI start
   48228:	0047fd80 	call	47fd8 <IINCHIP_CSoff>
    IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
   4822c:	e0bfff17 	ldw	r2,-4(fp)
   48230:	10803fec 	andhi	r2,r2,255
   48234:	1004d43a 	srli	r2,r2,16
   48238:	1009883a 	mov	r4,r2
   4823c:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
   48240:	e0bfff17 	ldw	r2,-4(fp)
   48244:	10bfc00c 	andi	r2,r2,65280
   48248:	1004d23a 	srli	r2,r2,8
   4824c:	10bfffcc 	andi	r2,r2,65535
   48250:	1009883a 	mov	r4,r2
   48254:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x000000F8))    ;// Data read command and Read data length 1
   48258:	e0bfff17 	ldw	r2,-4(fp)
   4825c:	10803e0c 	andi	r2,r2,248
   48260:	1009883a 	mov	r4,r2
   48264:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData(1);
   48268:	01000044 	movi	r4,1
   4826c:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    for( num = 0; num < 2; num++ ) ;
   48270:	e03ffe0d 	sth	zero,-8(fp)
   48274:	00000306 	br	48284 <IINCHIP_READ+0x74>
   48278:	e0bffe0b 	ldhu	r2,-8(fp)
   4827c:	10800044 	addi	r2,r2,1
   48280:	e0bffe0d 	sth	r2,-8(fp)
   48284:	e0bffe0b 	ldhu	r2,-8(fp)
   48288:	108000b0 	cmpltui	r2,r2,2
   4828c:	103ffa1e 	bne	r2,zero,48278 <__alt_mem_epcs_flash+0xfffc7278>
    data = SPI_I2S_ReceiveData();
   48290:	004810c0 	call	4810c <SPI_I2S_ReceiveData>
   48294:	e0bffe85 	stb	r2,-6(fp)
    IINCHIP_CSon();                               // CS=1,  SPI end
   48298:	00480080 	call	48008 <IINCHIP_CSon>
    IINCHIP_ISR_ENABLE();                         // Interrupt Service Routine Enable
    return data;
   4829c:	e0bffe83 	ldbu	r2,-6(fp)
}
   482a0:	e037883a 	mov	sp,fp
   482a4:	dfc00117 	ldw	ra,4(sp)
   482a8:	df000017 	ldw	fp,0(sp)
   482ac:	dec00204 	addi	sp,sp,8
   482b0:	f800283a 	ret

000482b4 <wiz_write_buf>:

uint16 wiz_write_buf(uint32 addrbsb, uint8* buf,uint16 len)
{
   482b4:	defffa04 	addi	sp,sp,-24
   482b8:	dfc00515 	stw	ra,20(sp)
   482bc:	df000415 	stw	fp,16(sp)
   482c0:	df000404 	addi	fp,sp,16
   482c4:	e13ffd15 	stw	r4,-12(fp)
   482c8:	e17ffe15 	stw	r5,-8(fp)
   482cc:	3005883a 	mov	r2,r6
   482d0:	e0bfff0d 	sth	r2,-4(fp)
    uint16 idx = 0;
   482d4:	e03ffc0d 	sth	zero,-16(fp)
    // send_buf[0] = (addrbsb & 0x00FF0000)>>16;
    // send_buf[1] = (addrbsb & 0x0000FF00)>> 8;
    // send_buf[2] = (addrbsb & 0x000000F8) + 4;

    IINCHIP_ISR_DISABLE();
    IINCHIP_CSoff();
   482d8:	0047fd80 	call	47fd8 <IINCHIP_CSoff>
                             // CS=0, SPI start
    IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
   482dc:	e0bffd17 	ldw	r2,-12(fp)
   482e0:	10803fec 	andhi	r2,r2,255
   482e4:	1004d43a 	srli	r2,r2,16
   482e8:	1009883a 	mov	r4,r2
   482ec:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
   482f0:	e0bffd17 	ldw	r2,-12(fp)
   482f4:	10bfc00c 	andi	r2,r2,65280
   482f8:	1004d23a 	srli	r2,r2,8
   482fc:	10bfffcc 	andi	r2,r2,65535
   48300:	1009883a 	mov	r4,r2
   48304:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x000000F8) + 4);    // Data write command and Write data length 1
   48308:	e0bffd17 	ldw	r2,-12(fp)
   4830c:	10803e0c 	andi	r2,r2,248
   48310:	10800104 	addi	r2,r2,4
   48314:	10bfffcc 	andi	r2,r2,65535
   48318:	1009883a 	mov	r4,r2
   4831c:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    for(idx = 0; idx < len; idx++)                // Write data in loop
   48320:	e03ffc0d 	sth	zero,-16(fp)
   48324:	00000a06 	br	48350 <wiz_write_buf+0x9c>
    {
        IINCHIP_SpiSendData(buf[idx]);
   48328:	e0bffc0b 	ldhu	r2,-16(fp)
   4832c:	e0fffe17 	ldw	r3,-8(fp)
   48330:	1885883a 	add	r2,r3,r2
   48334:	10800003 	ldbu	r2,0(r2)
   48338:	10803fcc 	andi	r2,r2,255
   4833c:	1009883a 	mov	r4,r2
   48340:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_CSoff();
                             // CS=0, SPI start
    IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
    IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
    IINCHIP_SpiSendData( (addrbsb & 0x000000F8) + 4);    // Data write command and Write data length 1
    for(idx = 0; idx < len; idx++)                // Write data in loop
   48344:	e0bffc0b 	ldhu	r2,-16(fp)
   48348:	10800044 	addi	r2,r2,1
   4834c:	e0bffc0d 	sth	r2,-16(fp)
   48350:	e0fffc0b 	ldhu	r3,-16(fp)
   48354:	e0bfff0b 	ldhu	r2,-4(fp)
   48358:	18bff336 	bltu	r3,r2,48328 <__alt_mem_epcs_flash+0xfffc7328>
//		alt_avalon_dma_tx_ioctl(tx, ALT_DMA_TX_ONLY_ON, (void*)(SPI_BASE+4));
//		idx = alt_avalon_dma_send(tx, buf, (len<<1), NULL, NULL);
//	}
    // alt_avalon_spi_command(SPI_BASE, 0, 3, send_buf, 0, NULL, 0);
    // alt_avalon_spi_command(SPI_BASE, 0, len, buf, 0, NULL, 0);
    IINCHIP_CSon();                               // CS=1, SPI end
   4835c:	00480080 	call	48008 <IINCHIP_CSon>
    IINCHIP_ISR_ENABLE();                         // Interrupt Service Routine Enable

    return len;
   48360:	e0bfff0b 	ldhu	r2,-4(fp)
}
   48364:	e037883a 	mov	sp,fp
   48368:	dfc00117 	ldw	ra,4(sp)
   4836c:	df000017 	ldw	fp,0(sp)
   48370:	dec00204 	addi	sp,sp,8
   48374:	f800283a 	ret

00048378 <wiz_read_buf>:


uint16 wiz_read_buf(uint32 addrbsb, uint8* buf,uint16 len)
{
   48378:	defff904 	addi	sp,sp,-28
   4837c:	dfc00615 	stw	ra,24(sp)
   48380:	df000515 	stw	fp,20(sp)
   48384:	dc000415 	stw	r16,16(sp)
   48388:	df000504 	addi	fp,sp,20
   4838c:	e13ffc15 	stw	r4,-16(fp)
   48390:	e17ffd15 	stw	r5,-12(fp)
   48394:	3005883a 	mov	r2,r6
   48398:	e0bffe0d 	sth	r2,-8(fp)
    uint16 idx = 0;
   4839c:	e03ffb0d 	sth	zero,-20(fp)
    uint16 num = 0;
   483a0:	e03ffb8d 	sth	zero,-18(fp)
//    uint8 send_buf[3];
//    send_buf[0] = (addrbsb & 0x00FF0000)>>16;
//    send_buf[1] = (addrbsb & 0x0000FF00)>> 8;
//    send_buf[2] = (addrbsb & 0x000000F8);

    num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);  // 清空数据
   483a4:	01000234 	movhi	r4,8
   483a8:	21083004 	addi	r4,r4,8384
   483ac:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   483b0:	e0bffb8d 	sth	r2,-18(fp)
    while(num > 0)
   483b4:	00000a06 	br	483e0 <wiz_read_buf+0x68>
    {
        num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);
   483b8:	01000234 	movhi	r4,8
   483bc:	21083004 	addi	r4,r4,8384
   483c0:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   483c4:	e0bffb8d 	sth	r2,-18(fp)
        idx = altera_avalon_fifo_read_fifo(SPIRD_FIFO_OUT_BASE, SPIRD_FIFO_IN_CSR_BASE);
   483c8:	01400234 	movhi	r5,8
   483cc:	29483004 	addi	r5,r5,8384
   483d0:	01000234 	movhi	r4,8
   483d4:	21087604 	addi	r4,r4,8664
   483d8:	004adc80 	call	4adc8 <altera_avalon_fifo_read_fifo>
   483dc:	e0bffb0d 	sth	r2,-20(fp)
//    send_buf[0] = (addrbsb & 0x00FF0000)>>16;
//    send_buf[1] = (addrbsb & 0x0000FF00)>> 8;
//    send_buf[2] = (addrbsb & 0x000000F8);

    num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);  // 清空数据
    while(num > 0)
   483e0:	e0bffb8b 	ldhu	r2,-18(fp)
   483e4:	103ff41e 	bne	r2,zero,483b8 <__alt_mem_epcs_flash+0xfffc73b8>
    {
        num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);
        idx = altera_avalon_fifo_read_fifo(SPIRD_FIFO_OUT_BASE, SPIRD_FIFO_IN_CSR_BASE);
    }

    IINCHIP_CSoff();                                      // CS=0, SPI开启
   483e8:	0047fd80 	call	47fd8 <IINCHIP_CSoff>
//    alt_avalon_spi_command(SPI_BASE, 0, 3, send_buf, len, buf, 0);
    IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);		// 通过SPI发送16位地址段给MCU
   483ec:	e0bffc17 	ldw	r2,-16(fp)
   483f0:	10803fec 	andhi	r2,r2,255
   483f4:	1004d43a 	srli	r2,r2,16
   483f8:	1009883a 	mov	r4,r2
   483fc:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);		//
   48400:	e0bffc17 	ldw	r2,-16(fp)
   48404:	10bfc00c 	andi	r2,r2,65280
   48408:	1004d23a 	srli	r2,r2,8
   4840c:	10bfffcc 	andi	r2,r2,65535
   48410:	1009883a 	mov	r4,r2
   48414:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    IINCHIP_SpiSendData( (addrbsb & 0x000000F8));    		// 设置SPI为读操作
   48418:	e0bffc17 	ldw	r2,-16(fp)
   4841c:	10803e0c 	andi	r2,r2,248
   48420:	1009883a 	mov	r4,r2
   48424:	00480b00 	call	480b0 <IINCHIP_SpiSendData>

    IINCHIP_SpiSendData(len);
   48428:	e0bffe0b 	ldhu	r2,-8(fp)
   4842c:	1009883a 	mov	r4,r2
   48430:	00480b00 	call	480b0 <IINCHIP_SpiSendData>
    for( num = 0; num < 4; num++ )
   48434:	e03ffb8d 	sth	zero,-18(fp)
   48438:	00000306 	br	48448 <wiz_read_buf+0xd0>
   4843c:	e0bffb8b 	ldhu	r2,-18(fp)
   48440:	10800044 	addi	r2,r2,1
   48444:	e0bffb8d 	sth	r2,-18(fp)
   48448:	e0bffb8b 	ldhu	r2,-18(fp)
   4844c:	10800130 	cmpltui	r2,r2,4
   48450:	103ffa1e 	bne	r2,zero,4843c <__alt_mem_epcs_flash+0xfffc743c>
    {
        ;
    }
    for(idx = 0; idx < len; idx++)                    	// 将buf中的数据通过SPI发送给MCU
   48454:	e03ffb0d 	sth	zero,-20(fp)
   48458:	00000806 	br	4847c <wiz_read_buf+0x104>
    {
        //buf[idx] = IINCHIP_SpiSendData(0x00);
        buf[idx] = SPI_I2S_ReceiveData();
   4845c:	e0bffb0b 	ldhu	r2,-20(fp)
   48460:	e0fffd17 	ldw	r3,-12(fp)
   48464:	18a1883a 	add	r16,r3,r2
   48468:	004810c0 	call	4810c <SPI_I2S_ReceiveData>
   4846c:	80800005 	stb	r2,0(r16)
    IINCHIP_SpiSendData(len);
    for( num = 0; num < 4; num++ )
    {
        ;
    }
    for(idx = 0; idx < len; idx++)                    	// 将buf中的数据通过SPI发送给MCU
   48470:	e0bffb0b 	ldhu	r2,-20(fp)
   48474:	10800044 	addi	r2,r2,1
   48478:	e0bffb0d 	sth	r2,-20(fp)
   4847c:	e0fffb0b 	ldhu	r3,-20(fp)
   48480:	e0bffe0b 	ldhu	r2,-8(fp)
   48484:	18bff536 	bltu	r3,r2,4845c <__alt_mem_epcs_flash+0xfffc745c>
    {
        //buf[idx] = IINCHIP_SpiSendData(0x00);
        buf[idx] = SPI_I2S_ReceiveData();
    }

    num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);  // 清空数据
   48488:	01000234 	movhi	r4,8
   4848c:	21083004 	addi	r4,r4,8384
   48490:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   48494:	e0bffb8d 	sth	r2,-18(fp)
    while(num > 0)
   48498:	00000a06 	br	484c4 <wiz_read_buf+0x14c>
    {
        num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);
   4849c:	01000234 	movhi	r4,8
   484a0:	21083004 	addi	r4,r4,8384
   484a4:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   484a8:	e0bffb8d 	sth	r2,-18(fp)
        idx = altera_avalon_fifo_read_fifo(SPIRD_FIFO_OUT_BASE, SPIRD_FIFO_IN_CSR_BASE);
   484ac:	01400234 	movhi	r5,8
   484b0:	29483004 	addi	r5,r5,8384
   484b4:	01000234 	movhi	r4,8
   484b8:	21087604 	addi	r4,r4,8664
   484bc:	004adc80 	call	4adc8 <altera_avalon_fifo_read_fifo>
   484c0:	e0bffb0d 	sth	r2,-20(fp)
        //buf[idx] = IINCHIP_SpiSendData(0x00);
        buf[idx] = SPI_I2S_ReceiveData();
    }

    num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);  // 清空数据
    while(num > 0)
   484c4:	e0bffb8b 	ldhu	r2,-18(fp)
   484c8:	103ff41e 	bne	r2,zero,4849c <__alt_mem_epcs_flash+0xfffc749c>
    {
        num = altera_avalon_fifo_read_level(SPIRD_FIFO_IN_CSR_BASE);
        idx = altera_avalon_fifo_read_fifo(SPIRD_FIFO_OUT_BASE, SPIRD_FIFO_IN_CSR_BASE);
    }
    IINCHIP_CSon();                                       // CS=1, SPI关闭
   484cc:	00480080 	call	48008 <IINCHIP_CSon>

    return len;                                                                                                                                                                   // 返回已接收数据的长度值
   484d0:	e0bffe0b 	ldhu	r2,-8(fp)
}
   484d4:	e6ffff04 	addi	sp,fp,-4
   484d8:	dfc00217 	ldw	ra,8(sp)
   484dc:	df000117 	ldw	fp,4(sp)
   484e0:	dc000017 	ldw	r16,0(sp)
   484e4:	dec00304 	addi	sp,sp,12
   484e8:	f800283a 	ret

000484ec <iinchip_init>:

/**
  @brief  This function is for resetting of the iinchip. Initializes the iinchip to work in whether DIRECT or INDIRECT mode
  */
void iinchip_init(void)
{
   484ec:	defffe04 	addi	sp,sp,-8
   484f0:	dfc00115 	stw	ra,4(sp)
   484f4:	df000015 	stw	fp,0(sp)
   484f8:	d839883a 	mov	fp,sp
    setMR( MR_RST );
   484fc:	01002004 	movi	r4,128
   48500:	0048b380 	call	48b38 <setMR>
}
   48504:	0001883a 	nop
   48508:	e037883a 	mov	sp,fp
   4850c:	dfc00117 	ldw	ra,4(sp)
   48510:	df000017 	ldw	fp,0(sp)
   48514:	dec00204 	addi	sp,sp,8
   48518:	f800283a 	ret

0004851c <sysinit>:
  other 3 channels couldn't be used, for there's no available memory.\n
  If two 4KBytes memory are assigned to two each channels, \n
  other 2 channels couldn't be used, for there's no available memory.\n
  */
void sysinit( uint8 * tx_size, uint8 * rx_size  )
{
   4851c:	defff904 	addi	sp,sp,-28
   48520:	dfc00615 	stw	ra,24(sp)
   48524:	df000515 	stw	fp,20(sp)
   48528:	df000504 	addi	fp,sp,20
   4852c:	e13ffe15 	stw	r4,-8(fp)
   48530:	e17fff15 	stw	r5,-4(fp)
    int16 i;
    int16 ssum,rsum;

    ssum = 0;
   48534:	e03ffc15 	stw	zero,-16(fp)
    rsum = 0;
   48538:	e03ffd15 	stw	zero,-12(fp)

    for (i = 0 ; i < MAX_SOCK_NUM; i++)       // Set the size, masking and base address of Tx & Rx memory by each channel
   4853c:	e03ffb15 	stw	zero,-20(fp)
   48540:	0000db06 	br	488b0 <sysinit+0x394>
    {
        IINCHIP_WRITE( (Sn_TXMEM_SIZE(i)), tx_size[i]);
   48544:	e0bffb17 	ldw	r2,-20(fp)
   48548:	1004917a 	slli	r2,r2,5
   4854c:	1087c204 	addi	r2,r2,7944
   48550:	1009883a 	mov	r4,r2
   48554:	e0bffb17 	ldw	r2,-20(fp)
   48558:	e0fffe17 	ldw	r3,-8(fp)
   4855c:	1885883a 	add	r2,r3,r2
   48560:	10800003 	ldbu	r2,0(r2)
   48564:	10803fcc 	andi	r2,r2,255
   48568:	100b883a 	mov	r5,r2
   4856c:	00481840 	call	48184 <IINCHIP_WRITE>
        IINCHIP_WRITE( (Sn_RXMEM_SIZE(i)), rx_size[i]);
   48570:	e0bffb17 	ldw	r2,-20(fp)
   48574:	1004917a 	slli	r2,r2,5
   48578:	10878204 	addi	r2,r2,7688
   4857c:	1009883a 	mov	r4,r2
   48580:	e0bffb17 	ldw	r2,-20(fp)
   48584:	e0ffff17 	ldw	r3,-4(fp)
   48588:	1885883a 	add	r2,r3,r2
   4858c:	10800003 	ldbu	r2,0(r2)
   48590:	10803fcc 	andi	r2,r2,255
   48594:	100b883a 	mov	r5,r2
   48598:	00481840 	call	48184 <IINCHIP_WRITE>
        SSIZE[i] = (int16)(0);
   4859c:	008001b4 	movhi	r2,6
   485a0:	10b47b04 	addi	r2,r2,-11796
   485a4:	e0fffb17 	ldw	r3,-20(fp)
   485a8:	18c7883a 	add	r3,r3,r3
   485ac:	10c5883a 	add	r2,r2,r3
   485b0:	1000000d 	sth	zero,0(r2)
        RSIZE[i] = (int16)(0);
   485b4:	008001b4 	movhi	r2,6
   485b8:	10b47f04 	addi	r2,r2,-11780
   485bc:	e0fffb17 	ldw	r3,-20(fp)
   485c0:	18c7883a 	add	r3,r3,r3
   485c4:	10c5883a 	add	r2,r2,r3
   485c8:	1000000d 	sth	zero,0(r2)

        // W5500有8个Socket，每个Socket有对应独立的收发缓存区。
        // 每个Socket的发送/接收缓存区都在一个16KB的物理发送内存中，初始化分配为2KB。
        // 无论给每个Socket分配多大的收/发缓存，都必须在16KB以内。

        if (ssum <= 16384)                                                                          // 设置Socket发送缓存空间的大小
   485cc:	e0bffc17 	ldw	r2,-16(fp)
   485d0:	10900048 	cmpgei	r2,r2,16385
   485d4:	10004e1e 	bne	r2,zero,48710 <sysinit+0x1f4>
        {
            switch( tx_size[i] )
   485d8:	e0bffb17 	ldw	r2,-20(fp)
   485dc:	e0fffe17 	ldw	r3,-8(fp)
   485e0:	1885883a 	add	r2,r3,r2
   485e4:	10800003 	ldbu	r2,0(r2)
   485e8:	10803fcc 	andi	r2,r2,255
   485ec:	10c00468 	cmpgeui	r3,r2,17
   485f0:	18003f1e 	bne	r3,zero,486f0 <sysinit+0x1d4>
   485f4:	100690ba 	slli	r3,r2,2
   485f8:	00800174 	movhi	r2,5
   485fc:	10a18304 	addi	r2,r2,-31220
   48600:	1885883a 	add	r2,r3,r2
   48604:	10800017 	ldw	r2,0(r2)
   48608:	1000683a 	jmp	r2
   4860c:	000486f0 	cmpltui	zero,zero,4635
   48610:	00048650 	cmplti	zero,zero,4633
   48614:	00048670 	cmpltui	zero,zero,4633
   48618:	000486f0 	cmpltui	zero,zero,4635
   4861c:	00048690 	cmplti	zero,zero,4634
   48620:	000486f0 	cmpltui	zero,zero,4635
   48624:	000486f0 	cmpltui	zero,zero,4635
   48628:	000486f0 	cmpltui	zero,zero,4635
   4862c:	000486b0 	cmpltui	zero,zero,4634
   48630:	000486f0 	cmpltui	zero,zero,4635
   48634:	000486f0 	cmpltui	zero,zero,4635
   48638:	000486f0 	cmpltui	zero,zero,4635
   4863c:	000486f0 	cmpltui	zero,zero,4635
   48640:	000486f0 	cmpltui	zero,zero,4635
   48644:	000486f0 	cmpltui	zero,zero,4635
   48648:	000486f0 	cmpltui	zero,zero,4635
   4864c:	000486d0 	cmplti	zero,zero,4635
            {
                case 1:
                    SSIZE[i] = (int16)(1024);                       // i=1，tx_size=1KB
   48650:	008001b4 	movhi	r2,6
   48654:	10b47b04 	addi	r2,r2,-11796
   48658:	e0fffb17 	ldw	r3,-20(fp)
   4865c:	18c7883a 	add	r3,r3,r3
   48660:	10c5883a 	add	r2,r2,r3
   48664:	00c10004 	movi	r3,1024
   48668:	10c0000d 	sth	r3,0(r2)
                    break;
   4866c:	00002806 	br	48710 <sysinit+0x1f4>
                case 2:
                    SSIZE[i] = (int16)(2048);                       // i=2，tx_size=2KB
   48670:	008001b4 	movhi	r2,6
   48674:	10b47b04 	addi	r2,r2,-11796
   48678:	e0fffb17 	ldw	r3,-20(fp)
   4867c:	18c7883a 	add	r3,r3,r3
   48680:	10c5883a 	add	r2,r2,r3
   48684:	00c20004 	movi	r3,2048
   48688:	10c0000d 	sth	r3,0(r2)
                    break;
   4868c:	00002006 	br	48710 <sysinit+0x1f4>
                case 4:
                    SSIZE[i] = (int16)(4096);                       // i=4，tx_size=4KB
   48690:	008001b4 	movhi	r2,6
   48694:	10b47b04 	addi	r2,r2,-11796
   48698:	e0fffb17 	ldw	r3,-20(fp)
   4869c:	18c7883a 	add	r3,r3,r3
   486a0:	10c5883a 	add	r2,r2,r3
   486a4:	00c40004 	movi	r3,4096
   486a8:	10c0000d 	sth	r3,0(r2)
                    break;
   486ac:	00001806 	br	48710 <sysinit+0x1f4>
                case 8:
                    SSIZE[i] = (int16)(8192);                       // i=8，tx_size=8KB
   486b0:	008001b4 	movhi	r2,6
   486b4:	10b47b04 	addi	r2,r2,-11796
   486b8:	e0fffb17 	ldw	r3,-20(fp)
   486bc:	18c7883a 	add	r3,r3,r3
   486c0:	10c5883a 	add	r2,r2,r3
   486c4:	00c80004 	movi	r3,8192
   486c8:	10c0000d 	sth	r3,0(r2)
                    break;
   486cc:	00001006 	br	48710 <sysinit+0x1f4>
                case 16:
                    SSIZE[i] = (int16)(16384);              // i=16，tx_size=16KB
   486d0:	008001b4 	movhi	r2,6
   486d4:	10b47b04 	addi	r2,r2,-11796
   486d8:	e0fffb17 	ldw	r3,-20(fp)
   486dc:	18c7883a 	add	r3,r3,r3
   486e0:	10c5883a 	add	r2,r2,r3
   486e4:	00d00004 	movi	r3,16384
   486e8:	10c0000d 	sth	r3,0(r2)
                    break;
   486ec:	00000806 	br	48710 <sysinit+0x1f4>
                default :
                    RSIZE[i] = (int16)(2048);                       // 默认i=2，tx_size=2KB
   486f0:	008001b4 	movhi	r2,6
   486f4:	10b47f04 	addi	r2,r2,-11780
   486f8:	e0fffb17 	ldw	r3,-20(fp)
   486fc:	18c7883a 	add	r3,r3,r3
   48700:	10c5883a 	add	r2,r2,r3
   48704:	00c20004 	movi	r3,2048
   48708:	10c0000d 	sth	r3,0(r2)
                    break;
   4870c:	0001883a 	nop
            }
        }

        if (rsum <= 16384)                                                                      // 设置Socket接收缓存空间的大小
   48710:	e0bffd17 	ldw	r2,-12(fp)
   48714:	10900048 	cmpgei	r2,r2,16385
   48718:	10004e1e 	bne	r2,zero,48854 <sysinit+0x338>
        {
            switch( rx_size[i] )
   4871c:	e0bffb17 	ldw	r2,-20(fp)
   48720:	e0ffff17 	ldw	r3,-4(fp)
   48724:	1885883a 	add	r2,r3,r2
   48728:	10800003 	ldbu	r2,0(r2)
   4872c:	10803fcc 	andi	r2,r2,255
   48730:	10c00468 	cmpgeui	r3,r2,17
   48734:	18003f1e 	bne	r3,zero,48834 <sysinit+0x318>
   48738:	100690ba 	slli	r3,r2,2
   4873c:	00800174 	movhi	r2,5
   48740:	10a1d404 	addi	r2,r2,-30896
   48744:	1885883a 	add	r2,r3,r2
   48748:	10800017 	ldw	r2,0(r2)
   4874c:	1000683a 	jmp	r2
   48750:	00048834 	movhi	zero,4640
   48754:	00048794 	movui	zero,4638
   48758:	000487b4 	movhi	zero,4638
   4875c:	00048834 	movhi	zero,4640
   48760:	000487d4 	movui	zero,4639
   48764:	00048834 	movhi	zero,4640
   48768:	00048834 	movhi	zero,4640
   4876c:	00048834 	movhi	zero,4640
   48770:	000487f4 	movhi	zero,4639
   48774:	00048834 	movhi	zero,4640
   48778:	00048834 	movhi	zero,4640
   4877c:	00048834 	movhi	zero,4640
   48780:	00048834 	movhi	zero,4640
   48784:	00048834 	movhi	zero,4640
   48788:	00048834 	movhi	zero,4640
   4878c:	00048834 	movhi	zero,4640
   48790:	00048814 	movui	zero,4640
            {
                case 1:
                    RSIZE[i] = (int16)(1024);               // i=1，rx_size=1KB
   48794:	008001b4 	movhi	r2,6
   48798:	10b47f04 	addi	r2,r2,-11780
   4879c:	e0fffb17 	ldw	r3,-20(fp)
   487a0:	18c7883a 	add	r3,r3,r3
   487a4:	10c5883a 	add	r2,r2,r3
   487a8:	00c10004 	movi	r3,1024
   487ac:	10c0000d 	sth	r3,0(r2)
                    break;
   487b0:	00002806 	br	48854 <sysinit+0x338>
                case 2:
                    RSIZE[i] = (int16)(2048);               // i=2，rx_size=2KB
   487b4:	008001b4 	movhi	r2,6
   487b8:	10b47f04 	addi	r2,r2,-11780
   487bc:	e0fffb17 	ldw	r3,-20(fp)
   487c0:	18c7883a 	add	r3,r3,r3
   487c4:	10c5883a 	add	r2,r2,r3
   487c8:	00c20004 	movi	r3,2048
   487cc:	10c0000d 	sth	r3,0(r2)
                    break;
   487d0:	00002006 	br	48854 <sysinit+0x338>
                case 4:
                    RSIZE[i] = (int16)(4096);               // i=4，rx_size=4KB
   487d4:	008001b4 	movhi	r2,6
   487d8:	10b47f04 	addi	r2,r2,-11780
   487dc:	e0fffb17 	ldw	r3,-20(fp)
   487e0:	18c7883a 	add	r3,r3,r3
   487e4:	10c5883a 	add	r2,r2,r3
   487e8:	00c40004 	movi	r3,4096
   487ec:	10c0000d 	sth	r3,0(r2)
                    break;
   487f0:	00001806 	br	48854 <sysinit+0x338>
                case 8:
                    RSIZE[i] = (int16)(8192);               // i=8，rx_size=8KB
   487f4:	008001b4 	movhi	r2,6
   487f8:	10b47f04 	addi	r2,r2,-11780
   487fc:	e0fffb17 	ldw	r3,-20(fp)
   48800:	18c7883a 	add	r3,r3,r3
   48804:	10c5883a 	add	r2,r2,r3
   48808:	00c80004 	movi	r3,8192
   4880c:	10c0000d 	sth	r3,0(r2)
                    break;
   48810:	00001006 	br	48854 <sysinit+0x338>
                case 16:
                    RSIZE[i] = (int16)(16384);      // i=16，rx_size=16KB
   48814:	008001b4 	movhi	r2,6
   48818:	10b47f04 	addi	r2,r2,-11780
   4881c:	e0fffb17 	ldw	r3,-20(fp)
   48820:	18c7883a 	add	r3,r3,r3
   48824:	10c5883a 	add	r2,r2,r3
   48828:	00d00004 	movi	r3,16384
   4882c:	10c0000d 	sth	r3,0(r2)
                    break;
   48830:	00000806 	br	48854 <sysinit+0x338>
                default :
                    RSIZE[i] = (int16)(2048);               // 默认i=2，rx_size=2K
   48834:	008001b4 	movhi	r2,6
   48838:	10b47f04 	addi	r2,r2,-11780
   4883c:	e0fffb17 	ldw	r3,-20(fp)
   48840:	18c7883a 	add	r3,r3,r3
   48844:	10c5883a 	add	r2,r2,r3
   48848:	00c20004 	movi	r3,2048
   4884c:	10c0000d 	sth	r3,0(r2)
                    break;
   48850:	0001883a 	nop
            }
        }
        ssum += SSIZE[i];
   48854:	008001b4 	movhi	r2,6
   48858:	10b47b04 	addi	r2,r2,-11796
   4885c:	e0fffb17 	ldw	r3,-20(fp)
   48860:	18c7883a 	add	r3,r3,r3
   48864:	10c5883a 	add	r2,r2,r3
   48868:	1080000b 	ldhu	r2,0(r2)
   4886c:	10bfffcc 	andi	r2,r2,65535
   48870:	e0fffc17 	ldw	r3,-16(fp)
   48874:	1885883a 	add	r2,r3,r2
   48878:	e0bffc15 	stw	r2,-16(fp)
        rsum += RSIZE[i];
   4887c:	008001b4 	movhi	r2,6
   48880:	10b47f04 	addi	r2,r2,-11780
   48884:	e0fffb17 	ldw	r3,-20(fp)
   48888:	18c7883a 	add	r3,r3,r3
   4888c:	10c5883a 	add	r2,r2,r3
   48890:	1080000b 	ldhu	r2,0(r2)
   48894:	10bfffcc 	andi	r2,r2,65535
   48898:	e0fffd17 	ldw	r3,-12(fp)
   4889c:	1885883a 	add	r2,r3,r2
   488a0:	e0bffd15 	stw	r2,-12(fp)
    int16 ssum,rsum;

    ssum = 0;
    rsum = 0;

    for (i = 0 ; i < MAX_SOCK_NUM; i++)       // Set the size, masking and base address of Tx & Rx memory by each channel
   488a4:	e0bffb17 	ldw	r2,-20(fp)
   488a8:	10800044 	addi	r2,r2,1
   488ac:	e0bffb15 	stw	r2,-20(fp)
   488b0:	e0bffb17 	ldw	r2,-20(fp)
   488b4:	10800210 	cmplti	r2,r2,8
   488b8:	103f221e 	bne	r2,zero,48544 <__alt_mem_epcs_flash+0xfffc7544>
            }
        }
        ssum += SSIZE[i];
        rsum += RSIZE[i];
    }
}
   488bc:	0001883a 	nop
   488c0:	e037883a 	mov	sp,fp
   488c4:	dfc00117 	ldw	ra,4(sp)
   488c8:	df000017 	ldw	fp,0(sp)
   488cc:	dec00204 	addi	sp,sp,8
   488d0:	f800283a 	ret

000488d4 <setGAR>:
  @brief  This function sets up gateway IP address.
  */
void setGAR(
        uint8 * addr  /**< a pointer to a 4 -byte array responsible to set the Gateway IP address. */
        )
{
   488d4:	defffd04 	addi	sp,sp,-12
   488d8:	dfc00215 	stw	ra,8(sp)
   488dc:	df000115 	stw	fp,4(sp)
   488e0:	df000104 	addi	fp,sp,4
   488e4:	e13fff15 	stw	r4,-4(fp)
    wiz_write_buf(GAR0, addr, 4);
   488e8:	01800104 	movi	r6,4
   488ec:	e17fff17 	ldw	r5,-4(fp)
   488f0:	01004004 	movi	r4,256
   488f4:	00482b40 	call	482b4 <wiz_write_buf>
}
   488f8:	0001883a 	nop
   488fc:	e037883a 	mov	sp,fp
   48900:	dfc00117 	ldw	ra,4(sp)
   48904:	df000017 	ldw	fp,0(sp)
   48908:	dec00204 	addi	sp,sp,8
   4890c:	f800283a 	ret

00048910 <getGWIP>:
void getGWIP(uint8 * addr)
{
   48910:	defffd04 	addi	sp,sp,-12
   48914:	dfc00215 	stw	ra,8(sp)
   48918:	df000115 	stw	fp,4(sp)
   4891c:	df000104 	addi	fp,sp,4
   48920:	e13fff15 	stw	r4,-4(fp)
    wiz_read_buf(GAR0, addr, 4);
   48924:	01800104 	movi	r6,4
   48928:	e17fff17 	ldw	r5,-4(fp)
   4892c:	01004004 	movi	r4,256
   48930:	00483780 	call	48378 <wiz_read_buf>
}
   48934:	0001883a 	nop
   48938:	e037883a 	mov	sp,fp
   4893c:	dfc00117 	ldw	ra,4(sp)
   48940:	df000017 	ldw	fp,0(sp)
   48944:	dec00204 	addi	sp,sp,8
   48948:	f800283a 	ret

0004894c <setSUBR>:

/**
  @brief  It sets up SubnetMask address
  */
void setSUBR(uint8 * addr)
{
   4894c:	defffd04 	addi	sp,sp,-12
   48950:	dfc00215 	stw	ra,8(sp)
   48954:	df000115 	stw	fp,4(sp)
   48958:	df000104 	addi	fp,sp,4
   4895c:	e13fff15 	stw	r4,-4(fp)
    wiz_write_buf(SUBR0, addr, 4);
   48960:	01800104 	movi	r6,4
   48964:	e17fff17 	ldw	r5,-4(fp)
   48968:	01014004 	movi	r4,1280
   4896c:	00482b40 	call	482b4 <wiz_write_buf>
}
   48970:	0001883a 	nop
   48974:	e037883a 	mov	sp,fp
   48978:	dfc00117 	ldw	ra,4(sp)
   4897c:	df000017 	ldw	fp,0(sp)
   48980:	dec00204 	addi	sp,sp,8
   48984:	f800283a 	ret

00048988 <setSHAR>:
  @brief  This function sets up MAC address.
  */
void setSHAR(
        uint8 * addr  /**< a pointer to a 6 -byte array responsible to set the MAC address. */
        )
{
   48988:	defffd04 	addi	sp,sp,-12
   4898c:	dfc00215 	stw	ra,8(sp)
   48990:	df000115 	stw	fp,4(sp)
   48994:	df000104 	addi	fp,sp,4
   48998:	e13fff15 	stw	r4,-4(fp)
    wiz_write_buf(SHAR0, addr, 6);
   4899c:	01800184 	movi	r6,6
   489a0:	e17fff17 	ldw	r5,-4(fp)
   489a4:	01024004 	movi	r4,2304
   489a8:	00482b40 	call	482b4 <wiz_write_buf>
}
   489ac:	0001883a 	nop
   489b0:	e037883a 	mov	sp,fp
   489b4:	dfc00117 	ldw	ra,4(sp)
   489b8:	df000017 	ldw	fp,0(sp)
   489bc:	dec00204 	addi	sp,sp,8
   489c0:	f800283a 	ret

000489c4 <setSIPR>:
  @brief  This function sets up Source IP address.
  */
void setSIPR(
        uint8 * addr  /**< a pointer to a 4 -byte array responsible to set the Source IP address. */
        )
{
   489c4:	defffd04 	addi	sp,sp,-12
   489c8:	dfc00215 	stw	ra,8(sp)
   489cc:	df000115 	stw	fp,4(sp)
   489d0:	df000104 	addi	fp,sp,4
   489d4:	e13fff15 	stw	r4,-4(fp)
    wiz_write_buf(SIPR0, addr, 4);
   489d8:	01800104 	movi	r6,4
   489dc:	e17fff17 	ldw	r5,-4(fp)
   489e0:	0103c004 	movi	r4,3840
   489e4:	00482b40 	call	482b4 <wiz_write_buf>
}
   489e8:	0001883a 	nop
   489ec:	e037883a 	mov	sp,fp
   489f0:	dfc00117 	ldw	ra,4(sp)
   489f4:	df000017 	ldw	fp,0(sp)
   489f8:	dec00204 	addi	sp,sp,8
   489fc:	f800283a 	ret

00048a00 <setkeepalive>:

/**
  @brief  W5500心跳检测程序，设置Socket在线时间寄存器Sn_KPALVTR，单位为5s
  */
void setkeepalive(SOCKET s)
{
   48a00:	defffd04 	addi	sp,sp,-12
   48a04:	dfc00215 	stw	ra,8(sp)
   48a08:	df000115 	stw	fp,4(sp)
   48a0c:	df000104 	addi	fp,sp,4
   48a10:	2005883a 	mov	r2,r4
   48a14:	e0bfff05 	stb	r2,-4(fp)
    IINCHIP_WRITE(Sn_KPALVTR(s),0x02);
   48a18:	e0bfff03 	ldbu	r2,-4(fp)
   48a1c:	1004917a 	slli	r2,r2,5
   48a20:	108bc204 	addi	r2,r2,12040
   48a24:	01400084 	movi	r5,2
   48a28:	1009883a 	mov	r4,r2
   48a2c:	00481840 	call	48184 <IINCHIP_WRITE>
}
   48a30:	0001883a 	nop
   48a34:	e037883a 	mov	sp,fp
   48a38:	dfc00117 	ldw	ra,4(sp)
   48a3c:	df000017 	ldw	fp,0(sp)
   48a40:	dec00204 	addi	sp,sp,8
   48a44:	f800283a 	ret

00048a48 <getGAR>:

/**
  @brief  This function sets up Source IP address.
  */
void getGAR(uint8 * addr)
{
   48a48:	defffd04 	addi	sp,sp,-12
   48a4c:	dfc00215 	stw	ra,8(sp)
   48a50:	df000115 	stw	fp,4(sp)
   48a54:	df000104 	addi	fp,sp,4
   48a58:	e13fff15 	stw	r4,-4(fp)
    wiz_read_buf(GAR0, addr, 4);
   48a5c:	01800104 	movi	r6,4
   48a60:	e17fff17 	ldw	r5,-4(fp)
   48a64:	01004004 	movi	r4,256
   48a68:	00483780 	call	48378 <wiz_read_buf>
}
   48a6c:	0001883a 	nop
   48a70:	e037883a 	mov	sp,fp
   48a74:	dfc00117 	ldw	ra,4(sp)
   48a78:	df000017 	ldw	fp,0(sp)
   48a7c:	dec00204 	addi	sp,sp,8
   48a80:	f800283a 	ret

00048a84 <getSUBR>:
void getSUBR(uint8 * addr)
{
   48a84:	defffd04 	addi	sp,sp,-12
   48a88:	dfc00215 	stw	ra,8(sp)
   48a8c:	df000115 	stw	fp,4(sp)
   48a90:	df000104 	addi	fp,sp,4
   48a94:	e13fff15 	stw	r4,-4(fp)
    wiz_read_buf(SUBR0, addr, 4);
   48a98:	01800104 	movi	r6,4
   48a9c:	e17fff17 	ldw	r5,-4(fp)
   48aa0:	01014004 	movi	r4,1280
   48aa4:	00483780 	call	48378 <wiz_read_buf>
}
   48aa8:	0001883a 	nop
   48aac:	e037883a 	mov	sp,fp
   48ab0:	dfc00117 	ldw	ra,4(sp)
   48ab4:	df000017 	ldw	fp,0(sp)
   48ab8:	dec00204 	addi	sp,sp,8
   48abc:	f800283a 	ret

00048ac0 <getSHAR>:
void getSHAR(uint8 * addr)
{
   48ac0:	defffd04 	addi	sp,sp,-12
   48ac4:	dfc00215 	stw	ra,8(sp)
   48ac8:	df000115 	stw	fp,4(sp)
   48acc:	df000104 	addi	fp,sp,4
   48ad0:	e13fff15 	stw	r4,-4(fp)
    wiz_read_buf(SHAR0, addr, 6);
   48ad4:	01800184 	movi	r6,6
   48ad8:	e17fff17 	ldw	r5,-4(fp)
   48adc:	01024004 	movi	r4,2304
   48ae0:	00483780 	call	48378 <wiz_read_buf>
}
   48ae4:	0001883a 	nop
   48ae8:	e037883a 	mov	sp,fp
   48aec:	dfc00117 	ldw	ra,4(sp)
   48af0:	df000017 	ldw	fp,0(sp)
   48af4:	dec00204 	addi	sp,sp,8
   48af8:	f800283a 	ret

00048afc <getSIPR>:
void getSIPR(uint8 * addr)
{
   48afc:	defffd04 	addi	sp,sp,-12
   48b00:	dfc00215 	stw	ra,8(sp)
   48b04:	df000115 	stw	fp,4(sp)
   48b08:	df000104 	addi	fp,sp,4
   48b0c:	e13fff15 	stw	r4,-4(fp)
    wiz_read_buf(SIPR0, addr, 4);
   48b10:	01800104 	movi	r6,4
   48b14:	e17fff17 	ldw	r5,-4(fp)
   48b18:	0103c004 	movi	r4,3840
   48b1c:	00483780 	call	48378 <wiz_read_buf>
}
   48b20:	0001883a 	nop
   48b24:	e037883a 	mov	sp,fp
   48b28:	dfc00117 	ldw	ra,4(sp)
   48b2c:	df000017 	ldw	fp,0(sp)
   48b30:	dec00204 	addi	sp,sp,8
   48b34:	f800283a 	ret

00048b38 <setMR>:

void setMR(uint8 val)
{
   48b38:	defffd04 	addi	sp,sp,-12
   48b3c:	dfc00215 	stw	ra,8(sp)
   48b40:	df000115 	stw	fp,4(sp)
   48b44:	df000104 	addi	fp,sp,4
   48b48:	2005883a 	mov	r2,r4
   48b4c:	e0bfff05 	stb	r2,-4(fp)
    IINCHIP_WRITE(MR,val);
   48b50:	e0bfff03 	ldbu	r2,-4(fp)
   48b54:	100b883a 	mov	r5,r2
   48b58:	0009883a 	mov	r4,zero
   48b5c:	00481840 	call	48184 <IINCHIP_WRITE>
}
   48b60:	0001883a 	nop
   48b64:	e037883a 	mov	sp,fp
   48b68:	dfc00117 	ldw	ra,4(sp)
   48b6c:	df000017 	ldw	fp,0(sp)
   48b70:	dec00204 	addi	sp,sp,8
   48b74:	f800283a 	ret

00048b78 <getIR>:

/**
  @brief  This function gets Interrupt register in common register.
  */
uint8 getIR( void )
{
   48b78:	defffe04 	addi	sp,sp,-8
   48b7c:	dfc00115 	stw	ra,4(sp)
   48b80:	df000015 	stw	fp,0(sp)
   48b84:	d839883a 	mov	fp,sp
    return IINCHIP_READ(IR);
   48b88:	01054004 	movi	r4,5376
   48b8c:	00482100 	call	48210 <IINCHIP_READ>
}
   48b90:	e037883a 	mov	sp,fp
   48b94:	dfc00117 	ldw	ra,4(sp)
   48b98:	df000017 	ldw	fp,0(sp)
   48b9c:	dec00204 	addi	sp,sp,8
   48ba0:	f800283a 	ret

00048ba4 <setRTR>:

  If there is no response from the peer or delay in response then retransmission
  will be there as per RTR (Retry Time-value Register)setting
  */
void setRTR(uint16 timeout)
{
   48ba4:	defffd04 	addi	sp,sp,-12
   48ba8:	dfc00215 	stw	ra,8(sp)
   48bac:	df000115 	stw	fp,4(sp)
   48bb0:	df000104 	addi	fp,sp,4
   48bb4:	2005883a 	mov	r2,r4
   48bb8:	e0bfff0d 	sth	r2,-4(fp)
    IINCHIP_WRITE(RTR0,(uint8)((timeout & 0xff00) >> 8));
   48bbc:	e0bfff0b 	ldhu	r2,-4(fp)
   48bc0:	1004d23a 	srli	r2,r2,8
   48bc4:	10803fcc 	andi	r2,r2,255
   48bc8:	100b883a 	mov	r5,r2
   48bcc:	01064004 	movi	r4,6400
   48bd0:	00481840 	call	48184 <IINCHIP_WRITE>
    IINCHIP_WRITE(RTR1,(uint8)(timeout & 0x00ff));
   48bd4:	e0bfff0b 	ldhu	r2,-4(fp)
   48bd8:	10803fcc 	andi	r2,r2,255
   48bdc:	100b883a 	mov	r5,r2
   48be0:	01068004 	movi	r4,6656
   48be4:	00481840 	call	48184 <IINCHIP_WRITE>
}
   48be8:	0001883a 	nop
   48bec:	e037883a 	mov	sp,fp
   48bf0:	dfc00117 	ldw	ra,4(sp)
   48bf4:	df000017 	ldw	fp,0(sp)
   48bf8:	dec00204 	addi	sp,sp,8
   48bfc:	f800283a 	ret

00048c00 <setRCR>:

  If there is no response from the peer or delay in response then recorded time
  as per RTR & RCR register seeting then time out will occur.
  */
void setRCR(uint8 retry)
{
   48c00:	defffd04 	addi	sp,sp,-12
   48c04:	dfc00215 	stw	ra,8(sp)
   48c08:	df000115 	stw	fp,4(sp)
   48c0c:	df000104 	addi	fp,sp,4
   48c10:	2005883a 	mov	r2,r4
   48c14:	e0bfff05 	stb	r2,-4(fp)
    IINCHIP_WRITE(WIZ_RCR,retry);
   48c18:	e0bfff03 	ldbu	r2,-4(fp)
   48c1c:	100b883a 	mov	r5,r2
   48c20:	0106c004 	movi	r4,6912
   48c24:	00481840 	call	48184 <IINCHIP_WRITE>
}
   48c28:	0001883a 	nop
   48c2c:	e037883a 	mov	sp,fp
   48c30:	dfc00117 	ldw	ra,4(sp)
   48c34:	df000017 	ldw	fp,0(sp)
   48c38:	dec00204 	addi	sp,sp,8
   48c3c:	f800283a 	ret

00048c40 <clearIR>:

  If any bit in IMR is set as '0' then there is not interrupt signal though the bit is
  set in IR register.
  */
void clearIR(uint8 mask)
{
   48c40:	defffc04 	addi	sp,sp,-16
   48c44:	dfc00315 	stw	ra,12(sp)
   48c48:	df000215 	stw	fp,8(sp)
   48c4c:	dc000115 	stw	r16,4(sp)
   48c50:	df000204 	addi	fp,sp,8
   48c54:	2005883a 	mov	r2,r4
   48c58:	e0bffe05 	stb	r2,-8(fp)
    IINCHIP_WRITE(IR, ~mask | getIR() ); // must be setted 0x10.
   48c5c:	e0bffe03 	ldbu	r2,-8(fp)
   48c60:	0084303a 	nor	r2,zero,r2
   48c64:	1021883a 	mov	r16,r2
   48c68:	0048b780 	call	48b78 <getIR>
   48c6c:	8084b03a 	or	r2,r16,r2
   48c70:	10803fcc 	andi	r2,r2,255
   48c74:	100b883a 	mov	r5,r2
   48c78:	01054004 	movi	r4,5376
   48c7c:	00481840 	call	48184 <IINCHIP_WRITE>
}
   48c80:	0001883a 	nop
   48c84:	e6ffff04 	addi	sp,fp,-4
   48c88:	dfc00217 	ldw	ra,8(sp)
   48c8c:	df000117 	ldw	fp,4(sp)
   48c90:	dc000017 	ldw	r16,0(sp)
   48c94:	dec00304 	addi	sp,sp,12
   48c98:	f800283a 	ret

00048c9c <setSn_MSS>:

/**
  @brief  This sets the maximum segment size of TCP in Active Mode), while in Passive Mode this is set by peer
  */
void setSn_MSS(SOCKET s, uint16 Sn_MSSR)
{
   48c9c:	defffc04 	addi	sp,sp,-16
   48ca0:	dfc00315 	stw	ra,12(sp)
   48ca4:	df000215 	stw	fp,8(sp)
   48ca8:	df000204 	addi	fp,sp,8
   48cac:	2007883a 	mov	r3,r4
   48cb0:	2805883a 	mov	r2,r5
   48cb4:	e0fffe05 	stb	r3,-8(fp)
   48cb8:	e0bfff0d 	sth	r2,-4(fp)
    IINCHIP_WRITE( Sn_MSSR0(s), (uint8)((Sn_MSSR & 0xff00) >> 8));
   48cbc:	e0bffe03 	ldbu	r2,-8(fp)
   48cc0:	1004917a 	slli	r2,r2,5
   48cc4:	10848204 	addi	r2,r2,4616
   48cc8:	1007883a 	mov	r3,r2
   48ccc:	e0bfff0b 	ldhu	r2,-4(fp)
   48cd0:	1004d23a 	srli	r2,r2,8
   48cd4:	10803fcc 	andi	r2,r2,255
   48cd8:	100b883a 	mov	r5,r2
   48cdc:	1809883a 	mov	r4,r3
   48ce0:	00481840 	call	48184 <IINCHIP_WRITE>
    IINCHIP_WRITE( Sn_MSSR1(s), (uint8)(Sn_MSSR & 0x00ff));
   48ce4:	e0bffe03 	ldbu	r2,-8(fp)
   48ce8:	1004917a 	slli	r2,r2,5
   48cec:	1084c204 	addi	r2,r2,4872
   48cf0:	1007883a 	mov	r3,r2
   48cf4:	e0bfff0b 	ldhu	r2,-4(fp)
   48cf8:	10803fcc 	andi	r2,r2,255
   48cfc:	100b883a 	mov	r5,r2
   48d00:	1809883a 	mov	r4,r3
   48d04:	00481840 	call	48184 <IINCHIP_WRITE>
}
   48d08:	0001883a 	nop
   48d0c:	e037883a 	mov	sp,fp
   48d10:	dfc00117 	ldw	ra,4(sp)
   48d14:	df000017 	ldw	fp,0(sp)
   48d18:	dec00204 	addi	sp,sp,8
   48d1c:	f800283a 	ret

00048d20 <getSn_IR>:
  @brief  get socket interrupt status

  These below functions are used to read the Interrupt & Soket Status register
  */
uint8 getSn_IR(SOCKET s)
{
   48d20:	defffd04 	addi	sp,sp,-12
   48d24:	dfc00215 	stw	ra,8(sp)
   48d28:	df000115 	stw	fp,4(sp)
   48d2c:	df000104 	addi	fp,sp,4
   48d30:	2005883a 	mov	r2,r4
   48d34:	e0bfff05 	stb	r2,-4(fp)
    return IINCHIP_READ(Sn_IR(s));
   48d38:	e0bfff03 	ldbu	r2,-4(fp)
   48d3c:	1004917a 	slli	r2,r2,5
   48d40:	10808204 	addi	r2,r2,520
   48d44:	1009883a 	mov	r4,r2
   48d48:	00482100 	call	48210 <IINCHIP_READ>
}
   48d4c:	e037883a 	mov	sp,fp
   48d50:	dfc00117 	ldw	ra,4(sp)
   48d54:	df000017 	ldw	fp,0(sp)
   48d58:	dec00204 	addi	sp,sp,8
   48d5c:	f800283a 	ret

00048d60 <getSn_SR>:

/**
  @brief   get socket status
  */
uint8 getSn_SR(SOCKET s)
{
   48d60:	defffd04 	addi	sp,sp,-12
   48d64:	dfc00215 	stw	ra,8(sp)
   48d68:	df000115 	stw	fp,4(sp)
   48d6c:	df000104 	addi	fp,sp,4
   48d70:	2005883a 	mov	r2,r4
   48d74:	e0bfff05 	stb	r2,-4(fp)
    return IINCHIP_READ(Sn_SR(s));
   48d78:	e0bfff03 	ldbu	r2,-4(fp)
   48d7c:	1004917a 	slli	r2,r2,5
   48d80:	1080c204 	addi	r2,r2,776
   48d84:	1009883a 	mov	r4,r2
   48d88:	00482100 	call	48210 <IINCHIP_READ>
}
   48d8c:	e037883a 	mov	sp,fp
   48d90:	dfc00117 	ldw	ra,4(sp)
   48d94:	df000017 	ldw	fp,0(sp)
   48d98:	dec00204 	addi	sp,sp,8
   48d9c:	f800283a 	ret

00048da0 <getSn_TX_FSR>:

  This gives free buffer size of transmit buffer. This is the data size that user can transmit.
  User shuold check this value first and control the size of transmitting data
  */
uint16 getSn_TX_FSR(SOCKET s)
{
   48da0:	defffb04 	addi	sp,sp,-20
   48da4:	dfc00415 	stw	ra,16(sp)
   48da8:	df000315 	stw	fp,12(sp)
   48dac:	dc000215 	stw	r16,8(sp)
   48db0:	df000304 	addi	fp,sp,12
   48db4:	2005883a 	mov	r2,r4
   48db8:	e0bffe05 	stb	r2,-8(fp)
    uint16 val=0,val1=0;
   48dbc:	e03ffd0d 	sth	zero,-12(fp)
   48dc0:	e03ffd8d 	sth	zero,-10(fp)
    do
    {
        val1 = IINCHIP_READ(Sn_TX_FSR0(s));
   48dc4:	e0bffe03 	ldbu	r2,-8(fp)
   48dc8:	1004917a 	slli	r2,r2,5
   48dcc:	10880204 	addi	r2,r2,8200
   48dd0:	1009883a 	mov	r4,r2
   48dd4:	00482100 	call	48210 <IINCHIP_READ>
   48dd8:	10803fcc 	andi	r2,r2,255
   48ddc:	e0bffd8d 	sth	r2,-10(fp)
        val1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
   48de0:	e0bffd8b 	ldhu	r2,-10(fp)
   48de4:	1004923a 	slli	r2,r2,8
   48de8:	1021883a 	mov	r16,r2
   48dec:	e0bffe03 	ldbu	r2,-8(fp)
   48df0:	1004917a 	slli	r2,r2,5
   48df4:	10884204 	addi	r2,r2,8456
   48df8:	1009883a 	mov	r4,r2
   48dfc:	00482100 	call	48210 <IINCHIP_READ>
   48e00:	10803fcc 	andi	r2,r2,255
   48e04:	8085883a 	add	r2,r16,r2
   48e08:	e0bffd8d 	sth	r2,-10(fp)
        if (val1 != 0)
   48e0c:	e0bffd8b 	ldhu	r2,-10(fp)
   48e10:	10001226 	beq	r2,zero,48e5c <getSn_TX_FSR+0xbc>
        {
            val = IINCHIP_READ(Sn_TX_FSR0(s));
   48e14:	e0bffe03 	ldbu	r2,-8(fp)
   48e18:	1004917a 	slli	r2,r2,5
   48e1c:	10880204 	addi	r2,r2,8200
   48e20:	1009883a 	mov	r4,r2
   48e24:	00482100 	call	48210 <IINCHIP_READ>
   48e28:	10803fcc 	andi	r2,r2,255
   48e2c:	e0bffd0d 	sth	r2,-12(fp)
            val = (val << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
   48e30:	e0bffd0b 	ldhu	r2,-12(fp)
   48e34:	1004923a 	slli	r2,r2,8
   48e38:	1021883a 	mov	r16,r2
   48e3c:	e0bffe03 	ldbu	r2,-8(fp)
   48e40:	1004917a 	slli	r2,r2,5
   48e44:	10884204 	addi	r2,r2,8456
   48e48:	1009883a 	mov	r4,r2
   48e4c:	00482100 	call	48210 <IINCHIP_READ>
   48e50:	10803fcc 	andi	r2,r2,255
   48e54:	8085883a 	add	r2,r16,r2
   48e58:	e0bffd0d 	sth	r2,-12(fp)
        }
    } while (val != val1);
   48e5c:	e0fffd0b 	ldhu	r3,-12(fp)
   48e60:	e0bffd8b 	ldhu	r2,-10(fp)
   48e64:	18bfd71e 	bne	r3,r2,48dc4 <__alt_mem_epcs_flash+0xfffc7dc4>
    return val;
   48e68:	e0bffd0b 	ldhu	r2,-12(fp)
}
   48e6c:	e6ffff04 	addi	sp,fp,-4
   48e70:	dfc00217 	ldw	ra,8(sp)
   48e74:	df000117 	ldw	fp,4(sp)
   48e78:	dc000017 	ldw	r16,0(sp)
   48e7c:	dec00304 	addi	sp,sp,12
   48e80:	f800283a 	ret

00048e84 <getSn_RX_RSR>:
  @brief   get socket RX recv buf size

  This gives size of received data in receive buffer.
  */
uint16 getSn_RX_RSR(SOCKET s)                                                                                                           // 获取空闲接收缓存寄存器的值
{
   48e84:	defffb04 	addi	sp,sp,-20
   48e88:	dfc00415 	stw	ra,16(sp)
   48e8c:	df000315 	stw	fp,12(sp)
   48e90:	dc000215 	stw	r16,8(sp)
   48e94:	df000304 	addi	fp,sp,12
   48e98:	2005883a 	mov	r2,r4
   48e9c:	e0bffe05 	stb	r2,-8(fp)
    uint16 val=0,val1=0;
   48ea0:	e03ffd0d 	sth	zero,-12(fp)
   48ea4:	e03ffd8d 	sth	zero,-10(fp)
    do
    {
        val1 = IINCHIP_READ(Sn_RX_RSR0(s));                                                                 // MCU读Sn_RX_RSR的低8位，并赋给val1
   48ea8:	e0bffe03 	ldbu	r2,-8(fp)
   48eac:	1004917a 	slli	r2,r2,5
   48eb0:	10898204 	addi	r2,r2,9736
   48eb4:	1009883a 	mov	r4,r2
   48eb8:	00482100 	call	48210 <IINCHIP_READ>
   48ebc:	10803fcc 	andi	r2,r2,255
   48ec0:	e0bffd8d 	sth	r2,-10(fp)
        val1 = (val1 << 8) + IINCHIP_READ(Sn_RX_RSR1(s));           // 读高8位，并与低8位相加赋给val1
   48ec4:	e0bffd8b 	ldhu	r2,-10(fp)
   48ec8:	1004923a 	slli	r2,r2,8
   48ecc:	1021883a 	mov	r16,r2
   48ed0:	e0bffe03 	ldbu	r2,-8(fp)
   48ed4:	1004917a 	slli	r2,r2,5
   48ed8:	1089c204 	addi	r2,r2,9992
   48edc:	1009883a 	mov	r4,r2
   48ee0:	00482100 	call	48210 <IINCHIP_READ>
   48ee4:	10803fcc 	andi	r2,r2,255
   48ee8:	8085883a 	add	r2,r16,r2
   48eec:	e0bffd8d 	sth	r2,-10(fp)
        if(val1 != 0)                                                                                                                                                               // 若Sn_RX_RSR的值不为0，将其赋给val
   48ef0:	e0bffd8b 	ldhu	r2,-10(fp)
   48ef4:	10001226 	beq	r2,zero,48f40 <getSn_RX_RSR+0xbc>
        {
            val = IINCHIP_READ(Sn_RX_RSR0(s));
   48ef8:	e0bffe03 	ldbu	r2,-8(fp)
   48efc:	1004917a 	slli	r2,r2,5
   48f00:	10898204 	addi	r2,r2,9736
   48f04:	1009883a 	mov	r4,r2
   48f08:	00482100 	call	48210 <IINCHIP_READ>
   48f0c:	10803fcc 	andi	r2,r2,255
   48f10:	e0bffd0d 	sth	r2,-12(fp)
            val = (val << 8) + IINCHIP_READ(Sn_RX_RSR1(s));
   48f14:	e0bffd0b 	ldhu	r2,-12(fp)
   48f18:	1004923a 	slli	r2,r2,8
   48f1c:	1021883a 	mov	r16,r2
   48f20:	e0bffe03 	ldbu	r2,-8(fp)
   48f24:	1004917a 	slli	r2,r2,5
   48f28:	1089c204 	addi	r2,r2,9992
   48f2c:	1009883a 	mov	r4,r2
   48f30:	00482100 	call	48210 <IINCHIP_READ>
   48f34:	10803fcc 	andi	r2,r2,255
   48f38:	8085883a 	add	r2,r16,r2
   48f3c:	e0bffd0d 	sth	r2,-12(fp)
        }
    } while (val != val1);                                                                                                                                // 判断val与val1是否相等，若不等，重新返回do循环，若相等，跳出循环
   48f40:	e0fffd0b 	ldhu	r3,-12(fp)
   48f44:	e0bffd8b 	ldhu	r2,-10(fp)
   48f48:	18bfd71e 	bne	r3,r2,48ea8 <__alt_mem_epcs_flash+0xfffc7ea8>
    return val;                                                                                                                                                                  // 将val的值返回给getSn_RX_RSR
   48f4c:	e0bffd0b 	ldhu	r2,-12(fp)
}
   48f50:	e6ffff04 	addi	sp,fp,-4
   48f54:	dfc00217 	ldw	ra,8(sp)
   48f58:	df000117 	ldw	fp,4(sp)
   48f5c:	dc000017 	ldw	r16,0(sp)
   48f60:	dec00304 	addi	sp,sp,12
   48f64:	f800283a 	ret

00048f68 <send_data_processing>:

  This function read the Tx write pointer register and after copy the data in buffer update the Tx write pointer
  register. User should read upper byte first and lower byte later to get proper value.
  */
void send_data_processing(SOCKET s, uint8 *data, uint16 len)
{
   48f68:	defff804 	addi	sp,sp,-32
   48f6c:	dfc00715 	stw	ra,28(sp)
   48f70:	df000615 	stw	fp,24(sp)
   48f74:	dc000515 	stw	r16,20(sp)
   48f78:	df000604 	addi	fp,sp,24
   48f7c:	2007883a 	mov	r3,r4
   48f80:	e17ffd15 	stw	r5,-12(fp)
   48f84:	3005883a 	mov	r2,r6
   48f88:	e0fffc05 	stb	r3,-16(fp)
   48f8c:	e0bffe0d 	sth	r2,-8(fp)
    uint16 ptr =0;
   48f90:	e03ffa0d 	sth	zero,-24(fp)
    uint32 addrbsb =0;
   48f94:	e03ffb15 	stw	zero,-20(fp)
    if(len == 0)
   48f98:	e0bffe0b 	ldhu	r2,-8(fp)
   48f9c:	10003726 	beq	r2,zero,4907c <send_data_processing+0x114>
    {
        return;
    }


    ptr = IINCHIP_READ( Sn_TX_WR0(s) );
   48fa0:	e0bffc03 	ldbu	r2,-16(fp)
   48fa4:	1004917a 	slli	r2,r2,5
   48fa8:	10890204 	addi	r2,r2,9224
   48fac:	1009883a 	mov	r4,r2
   48fb0:	00482100 	call	48210 <IINCHIP_READ>
   48fb4:	10803fcc 	andi	r2,r2,255
   48fb8:	e0bffa0d 	sth	r2,-24(fp)
    ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_TX_WR1(s));
   48fbc:	e0bffa0b 	ldhu	r2,-24(fp)
   48fc0:	1004923a 	slli	r2,r2,8
   48fc4:	1021883a 	mov	r16,r2
   48fc8:	e0bffc03 	ldbu	r2,-16(fp)
   48fcc:	1004917a 	slli	r2,r2,5
   48fd0:	10894204 	addi	r2,r2,9480
   48fd4:	1009883a 	mov	r4,r2
   48fd8:	00482100 	call	48210 <IINCHIP_READ>
   48fdc:	10803fcc 	andi	r2,r2,255
   48fe0:	8085883a 	add	r2,r16,r2
   48fe4:	e0bffa0d 	sth	r2,-24(fp)

    addrbsb = (uint32)(ptr<<8) + (s<<5) + 0x10;
   48fe8:	e0bffa0b 	ldhu	r2,-24(fp)
   48fec:	1004923a 	slli	r2,r2,8
   48ff0:	1007883a 	mov	r3,r2
   48ff4:	e0bffc03 	ldbu	r2,-16(fp)
   48ff8:	1004917a 	slli	r2,r2,5
   48ffc:	1885883a 	add	r2,r3,r2
   49000:	10800404 	addi	r2,r2,16
   49004:	e0bffb15 	stw	r2,-20(fp)
    wiz_write_buf(addrbsb, data, len);
   49008:	e0bffe0b 	ldhu	r2,-8(fp)
   4900c:	100d883a 	mov	r6,r2
   49010:	e17ffd17 	ldw	r5,-12(fp)
   49014:	e13ffb17 	ldw	r4,-20(fp)
   49018:	00482b40 	call	482b4 <wiz_write_buf>

    ptr += len;
   4901c:	e0fffa0b 	ldhu	r3,-24(fp)
   49020:	e0bffe0b 	ldhu	r2,-8(fp)
   49024:	1885883a 	add	r2,r3,r2
   49028:	e0bffa0d 	sth	r2,-24(fp)
    IINCHIP_WRITE( Sn_TX_WR0(s) ,(uint8)((ptr & 0xff00) >> 8));
   4902c:	e0bffc03 	ldbu	r2,-16(fp)
   49030:	1004917a 	slli	r2,r2,5
   49034:	10890204 	addi	r2,r2,9224
   49038:	1007883a 	mov	r3,r2
   4903c:	e0bffa0b 	ldhu	r2,-24(fp)
   49040:	1004d23a 	srli	r2,r2,8
   49044:	10803fcc 	andi	r2,r2,255
   49048:	100b883a 	mov	r5,r2
   4904c:	1809883a 	mov	r4,r3
   49050:	00481840 	call	48184 <IINCHIP_WRITE>
    IINCHIP_WRITE( Sn_TX_WR1(s),(uint8)(ptr & 0x00ff));
   49054:	e0bffc03 	ldbu	r2,-16(fp)
   49058:	1004917a 	slli	r2,r2,5
   4905c:	10894204 	addi	r2,r2,9480
   49060:	1007883a 	mov	r3,r2
   49064:	e0bffa0b 	ldhu	r2,-24(fp)
   49068:	10803fcc 	andi	r2,r2,255
   4906c:	100b883a 	mov	r5,r2
   49070:	1809883a 	mov	r4,r3
   49074:	00481840 	call	48184 <IINCHIP_WRITE>
   49078:	00000106 	br	49080 <send_data_processing+0x118>
{
    uint16 ptr =0;
    uint32 addrbsb =0;
    if(len == 0)
    {
        return;
   4907c:	0001883a 	nop
    wiz_write_buf(addrbsb, data, len);

    ptr += len;
    IINCHIP_WRITE( Sn_TX_WR0(s) ,(uint8)((ptr & 0xff00) >> 8));
    IINCHIP_WRITE( Sn_TX_WR1(s),(uint8)(ptr & 0x00ff));
}
   49080:	e6ffff04 	addi	sp,fp,-4
   49084:	dfc00217 	ldw	ra,8(sp)
   49088:	df000117 	ldw	fp,4(sp)
   4908c:	dc000017 	ldw	r16,0(sp)
   49090:	dec00304 	addi	sp,sp,12
   49094:	f800283a 	ret

00049098 <recv_data_processing>:
  This function read the Rx read pointer register
  and after copy the data from receive buffer update the Rx write pointer register.
  User should read upper byte first and lower byte later to get proper value.
  */
void recv_data_processing(SOCKET s, uint8 *data, uint16 len)
{
   49098:	defff804 	addi	sp,sp,-32
   4909c:	dfc00715 	stw	ra,28(sp)
   490a0:	df000615 	stw	fp,24(sp)
   490a4:	dc000515 	stw	r16,20(sp)
   490a8:	df000604 	addi	fp,sp,24
   490ac:	2007883a 	mov	r3,r4
   490b0:	e17ffd15 	stw	r5,-12(fp)
   490b4:	3005883a 	mov	r2,r6
   490b8:	e0fffc05 	stb	r3,-16(fp)
   490bc:	e0bffe0d 	sth	r2,-8(fp)
    uint16 ptr = 0;
   490c0:	e03ffa0d 	sth	zero,-24(fp)
    uint32 addrbsb = 0;
   490c4:	e03ffb15 	stw	zero,-20(fp)

    if(len == 0)                                          // 若接收数据的长度为0，则串口打印“"CH: 0 Unexpected2 length 0”
   490c8:	e0bffe0b 	ldhu	r2,-8(fp)
   490cc:	10003726 	beq	r2,zero,491ac <recv_data_processing+0x114>
        return;
    }

    // MCU读取Sn_RX_RD接收写指针寄存器的值，并赋给ptr
    // Sn_RX_RD保存接收缓存中数据的首地址，若有数据接收，则接收完后该寄存器值要更新
    ptr = IINCHIP_READ( Sn_RX_RD0(s) );
   490d0:	e0bffc03 	ldbu	r2,-16(fp)
   490d4:	1004917a 	slli	r2,r2,5
   490d8:	108a0204 	addi	r2,r2,10248
   490dc:	1009883a 	mov	r4,r2
   490e0:	00482100 	call	48210 <IINCHIP_READ>
   490e4:	10803fcc 	andi	r2,r2,255
   490e8:	e0bffa0d 	sth	r2,-24(fp)
    ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ( Sn_RX_RD1(s) );
   490ec:	e0bffa0b 	ldhu	r2,-24(fp)
   490f0:	1004923a 	slli	r2,r2,8
   490f4:	1021883a 	mov	r16,r2
   490f8:	e0bffc03 	ldbu	r2,-16(fp)
   490fc:	1004917a 	slli	r2,r2,5
   49100:	108a4204 	addi	r2,r2,10504
   49104:	1009883a 	mov	r4,r2
   49108:	00482100 	call	48210 <IINCHIP_READ>
   4910c:	10803fcc 	andi	r2,r2,255
   49110:	8085883a 	add	r2,r16,r2
   49114:	e0bffa0d 	sth	r2,-24(fp)

    addrbsb = (uint32)(ptr<<8) + (s<<5) + 0x18;           // 获取接收到的数据的绝对地址
   49118:	e0bffa0b 	ldhu	r2,-24(fp)
   4911c:	1004923a 	slli	r2,r2,8
   49120:	1007883a 	mov	r3,r2
   49124:	e0bffc03 	ldbu	r2,-16(fp)
   49128:	1004917a 	slli	r2,r2,5
   4912c:	1885883a 	add	r2,r3,r2
   49130:	10800604 	addi	r2,r2,24
   49134:	e0bffb15 	stw	r2,-20(fp)
    wiz_read_buf(addrbsb, data, len);                                                     // 通过绝对地址，将接收到的数据发给MCU
   49138:	e0bffe0b 	ldhu	r2,-8(fp)
   4913c:	100d883a 	mov	r6,r2
   49140:	e17ffd17 	ldw	r5,-12(fp)
   49144:	e13ffb17 	ldw	r4,-20(fp)
   49148:	00483780 	call	48378 <wiz_read_buf>

    // 更新Sn_RX_RD寄存器的值
    ptr += len;                                                                                                             //
   4914c:	e0fffa0b 	ldhu	r3,-24(fp)
   49150:	e0bffe0b 	ldhu	r2,-8(fp)
   49154:	1885883a 	add	r2,r3,r2
   49158:	e0bffa0d 	sth	r2,-24(fp)
    IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));
   4915c:	e0bffc03 	ldbu	r2,-16(fp)
   49160:	1004917a 	slli	r2,r2,5
   49164:	108a0204 	addi	r2,r2,10248
   49168:	1007883a 	mov	r3,r2
   4916c:	e0bffa0b 	ldhu	r2,-24(fp)
   49170:	1004d23a 	srli	r2,r2,8
   49174:	10803fcc 	andi	r2,r2,255
   49178:	100b883a 	mov	r5,r2
   4917c:	1809883a 	mov	r4,r3
   49180:	00481840 	call	48184 <IINCHIP_WRITE>
    IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));
   49184:	e0bffc03 	ldbu	r2,-16(fp)
   49188:	1004917a 	slli	r2,r2,5
   4918c:	108a4204 	addi	r2,r2,10504
   49190:	1007883a 	mov	r3,r2
   49194:	e0bffa0b 	ldhu	r2,-24(fp)
   49198:	10803fcc 	andi	r2,r2,255
   4919c:	100b883a 	mov	r5,r2
   491a0:	1809883a 	mov	r4,r3
   491a4:	00481840 	call	48184 <IINCHIP_WRITE>
   491a8:	00000106 	br	491b0 <recv_data_processing+0x118>
    uint16 ptr = 0;
    uint32 addrbsb = 0;

    if(len == 0)                                          // 若接收数据的长度为0，则串口打印“"CH: 0 Unexpected2 length 0”
    {
        return;
   491ac:	0001883a 	nop

    // 更新Sn_RX_RD寄存器的值
    ptr += len;                                                                                                             //
    IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));
    IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));
}
   491b0:	e6ffff04 	addi	sp,fp,-4
   491b4:	dfc00217 	ldw	ra,8(sp)
   491b8:	df000117 	ldw	fp,4(sp)
   491bc:	dc000017 	ldw	r16,0(sp)
   491c0:	dec00304 	addi	sp,sp,12
   491c4:	f800283a 	ret

000491c8 <setSn_IR>:

void setSn_IR(uint8 s, uint8 val)
{
   491c8:	defffc04 	addi	sp,sp,-16
   491cc:	dfc00315 	stw	ra,12(sp)
   491d0:	df000215 	stw	fp,8(sp)
   491d4:	df000204 	addi	fp,sp,8
   491d8:	2007883a 	mov	r3,r4
   491dc:	2805883a 	mov	r2,r5
   491e0:	e0fffe05 	stb	r3,-8(fp)
   491e4:	e0bfff05 	stb	r2,-4(fp)
    IINCHIP_WRITE(Sn_IR(s), val);
   491e8:	e0bffe03 	ldbu	r2,-8(fp)
   491ec:	1004917a 	slli	r2,r2,5
   491f0:	10808204 	addi	r2,r2,520
   491f4:	1007883a 	mov	r3,r2
   491f8:	e0bfff03 	ldbu	r2,-4(fp)
   491fc:	100b883a 	mov	r5,r2
   49200:	1809883a 	mov	r4,r3
   49204:	00481840 	call	48184 <IINCHIP_WRITE>
}
   49208:	0001883a 	nop
   4920c:	e037883a 	mov	sp,fp
   49210:	dfc00117 	ldw	ra,4(sp)
   49214:	df000017 	ldw	fp,0(sp)
   49218:	dec00204 	addi	sp,sp,8
   4921c:	f800283a 	ret

00049220 <__divsi3>:
   49220:	20001b16 	blt	r4,zero,49290 <__divsi3+0x70>
   49224:	000f883a 	mov	r7,zero
   49228:	28001616 	blt	r5,zero,49284 <__divsi3+0x64>
   4922c:	200d883a 	mov	r6,r4
   49230:	29001a2e 	bgeu	r5,r4,4929c <__divsi3+0x7c>
   49234:	00800804 	movi	r2,32
   49238:	00c00044 	movi	r3,1
   4923c:	00000106 	br	49244 <__divsi3+0x24>
   49240:	10000d26 	beq	r2,zero,49278 <__divsi3+0x58>
   49244:	294b883a 	add	r5,r5,r5
   49248:	10bfffc4 	addi	r2,r2,-1
   4924c:	18c7883a 	add	r3,r3,r3
   49250:	293ffb36 	bltu	r5,r4,49240 <__alt_mem_epcs_flash+0xfffc8240>
   49254:	0005883a 	mov	r2,zero
   49258:	18000726 	beq	r3,zero,49278 <__divsi3+0x58>
   4925c:	0005883a 	mov	r2,zero
   49260:	31400236 	bltu	r6,r5,4926c <__divsi3+0x4c>
   49264:	314dc83a 	sub	r6,r6,r5
   49268:	10c4b03a 	or	r2,r2,r3
   4926c:	1806d07a 	srli	r3,r3,1
   49270:	280ad07a 	srli	r5,r5,1
   49274:	183ffa1e 	bne	r3,zero,49260 <__alt_mem_epcs_flash+0xfffc8260>
   49278:	38000126 	beq	r7,zero,49280 <__divsi3+0x60>
   4927c:	0085c83a 	sub	r2,zero,r2
   49280:	f800283a 	ret
   49284:	014bc83a 	sub	r5,zero,r5
   49288:	39c0005c 	xori	r7,r7,1
   4928c:	003fe706 	br	4922c <__alt_mem_epcs_flash+0xfffc822c>
   49290:	0109c83a 	sub	r4,zero,r4
   49294:	01c00044 	movi	r7,1
   49298:	003fe306 	br	49228 <__alt_mem_epcs_flash+0xfffc8228>
   4929c:	00c00044 	movi	r3,1
   492a0:	003fee06 	br	4925c <__alt_mem_epcs_flash+0xfffc825c>

000492a4 <__modsi3>:
   492a4:	20001716 	blt	r4,zero,49304 <__modsi3+0x60>
   492a8:	000f883a 	mov	r7,zero
   492ac:	2005883a 	mov	r2,r4
   492b0:	28001216 	blt	r5,zero,492fc <__modsi3+0x58>
   492b4:	2900162e 	bgeu	r5,r4,49310 <__modsi3+0x6c>
   492b8:	01800804 	movi	r6,32
   492bc:	00c00044 	movi	r3,1
   492c0:	00000106 	br	492c8 <__modsi3+0x24>
   492c4:	30000a26 	beq	r6,zero,492f0 <__modsi3+0x4c>
   492c8:	294b883a 	add	r5,r5,r5
   492cc:	31bfffc4 	addi	r6,r6,-1
   492d0:	18c7883a 	add	r3,r3,r3
   492d4:	293ffb36 	bltu	r5,r4,492c4 <__alt_mem_epcs_flash+0xfffc82c4>
   492d8:	18000526 	beq	r3,zero,492f0 <__modsi3+0x4c>
   492dc:	1806d07a 	srli	r3,r3,1
   492e0:	11400136 	bltu	r2,r5,492e8 <__modsi3+0x44>
   492e4:	1145c83a 	sub	r2,r2,r5
   492e8:	280ad07a 	srli	r5,r5,1
   492ec:	183ffb1e 	bne	r3,zero,492dc <__alt_mem_epcs_flash+0xfffc82dc>
   492f0:	38000126 	beq	r7,zero,492f8 <__modsi3+0x54>
   492f4:	0085c83a 	sub	r2,zero,r2
   492f8:	f800283a 	ret
   492fc:	014bc83a 	sub	r5,zero,r5
   49300:	003fec06 	br	492b4 <__alt_mem_epcs_flash+0xfffc82b4>
   49304:	0109c83a 	sub	r4,zero,r4
   49308:	01c00044 	movi	r7,1
   4930c:	003fe706 	br	492ac <__alt_mem_epcs_flash+0xfffc82ac>
   49310:	00c00044 	movi	r3,1
   49314:	003ff106 	br	492dc <__alt_mem_epcs_flash+0xfffc82dc>

00049318 <__udivsi3>:
   49318:	200d883a 	mov	r6,r4
   4931c:	2900152e 	bgeu	r5,r4,49374 <__udivsi3+0x5c>
   49320:	28001416 	blt	r5,zero,49374 <__udivsi3+0x5c>
   49324:	00800804 	movi	r2,32
   49328:	00c00044 	movi	r3,1
   4932c:	00000206 	br	49338 <__udivsi3+0x20>
   49330:	10000e26 	beq	r2,zero,4936c <__udivsi3+0x54>
   49334:	28000516 	blt	r5,zero,4934c <__udivsi3+0x34>
   49338:	294b883a 	add	r5,r5,r5
   4933c:	10bfffc4 	addi	r2,r2,-1
   49340:	18c7883a 	add	r3,r3,r3
   49344:	293ffa36 	bltu	r5,r4,49330 <__alt_mem_epcs_flash+0xfffc8330>
   49348:	18000826 	beq	r3,zero,4936c <__udivsi3+0x54>
   4934c:	0005883a 	mov	r2,zero
   49350:	31400236 	bltu	r6,r5,4935c <__udivsi3+0x44>
   49354:	314dc83a 	sub	r6,r6,r5
   49358:	10c4b03a 	or	r2,r2,r3
   4935c:	1806d07a 	srli	r3,r3,1
   49360:	280ad07a 	srli	r5,r5,1
   49364:	183ffa1e 	bne	r3,zero,49350 <__alt_mem_epcs_flash+0xfffc8350>
   49368:	f800283a 	ret
   4936c:	0005883a 	mov	r2,zero
   49370:	f800283a 	ret
   49374:	00c00044 	movi	r3,1
   49378:	003ff406 	br	4934c <__alt_mem_epcs_flash+0xfffc834c>

0004937c <__umodsi3>:
   4937c:	2005883a 	mov	r2,r4
   49380:	2900122e 	bgeu	r5,r4,493cc <__umodsi3+0x50>
   49384:	28001116 	blt	r5,zero,493cc <__umodsi3+0x50>
   49388:	01800804 	movi	r6,32
   4938c:	00c00044 	movi	r3,1
   49390:	00000206 	br	4939c <__umodsi3+0x20>
   49394:	30000c26 	beq	r6,zero,493c8 <__umodsi3+0x4c>
   49398:	28000516 	blt	r5,zero,493b0 <__umodsi3+0x34>
   4939c:	294b883a 	add	r5,r5,r5
   493a0:	31bfffc4 	addi	r6,r6,-1
   493a4:	18c7883a 	add	r3,r3,r3
   493a8:	293ffa36 	bltu	r5,r4,49394 <__alt_mem_epcs_flash+0xfffc8394>
   493ac:	18000626 	beq	r3,zero,493c8 <__umodsi3+0x4c>
   493b0:	1806d07a 	srli	r3,r3,1
   493b4:	11400136 	bltu	r2,r5,493bc <__umodsi3+0x40>
   493b8:	1145c83a 	sub	r2,r2,r5
   493bc:	280ad07a 	srli	r5,r5,1
   493c0:	183ffb1e 	bne	r3,zero,493b0 <__alt_mem_epcs_flash+0xfffc83b0>
   493c4:	f800283a 	ret
   493c8:	f800283a 	ret
   493cc:	00c00044 	movi	r3,1
   493d0:	003ff706 	br	493b0 <__alt_mem_epcs_flash+0xfffc83b0>

000493d4 <memcpy>:
   493d4:	defffd04 	addi	sp,sp,-12
   493d8:	dfc00215 	stw	ra,8(sp)
   493dc:	dc400115 	stw	r17,4(sp)
   493e0:	dc000015 	stw	r16,0(sp)
   493e4:	00c003c4 	movi	r3,15
   493e8:	2005883a 	mov	r2,r4
   493ec:	1980452e 	bgeu	r3,r6,49504 <memcpy+0x130>
   493f0:	2906b03a 	or	r3,r5,r4
   493f4:	18c000cc 	andi	r3,r3,3
   493f8:	1800441e 	bne	r3,zero,4950c <memcpy+0x138>
   493fc:	347ffc04 	addi	r17,r6,-16
   49400:	8822d13a 	srli	r17,r17,4
   49404:	28c00104 	addi	r3,r5,4
   49408:	23400104 	addi	r13,r4,4
   4940c:	8820913a 	slli	r16,r17,4
   49410:	2b000204 	addi	r12,r5,8
   49414:	22c00204 	addi	r11,r4,8
   49418:	84000504 	addi	r16,r16,20
   4941c:	2a800304 	addi	r10,r5,12
   49420:	22400304 	addi	r9,r4,12
   49424:	2c21883a 	add	r16,r5,r16
   49428:	2811883a 	mov	r8,r5
   4942c:	200f883a 	mov	r7,r4
   49430:	41000017 	ldw	r4,0(r8)
   49434:	1fc00017 	ldw	ra,0(r3)
   49438:	63c00017 	ldw	r15,0(r12)
   4943c:	39000015 	stw	r4,0(r7)
   49440:	53800017 	ldw	r14,0(r10)
   49444:	6fc00015 	stw	ra,0(r13)
   49448:	5bc00015 	stw	r15,0(r11)
   4944c:	4b800015 	stw	r14,0(r9)
   49450:	18c00404 	addi	r3,r3,16
   49454:	39c00404 	addi	r7,r7,16
   49458:	42000404 	addi	r8,r8,16
   4945c:	6b400404 	addi	r13,r13,16
   49460:	63000404 	addi	r12,r12,16
   49464:	5ac00404 	addi	r11,r11,16
   49468:	52800404 	addi	r10,r10,16
   4946c:	4a400404 	addi	r9,r9,16
   49470:	1c3fef1e 	bne	r3,r16,49430 <__alt_mem_epcs_flash+0xfffc8430>
   49474:	89c00044 	addi	r7,r17,1
   49478:	380e913a 	slli	r7,r7,4
   4947c:	310003cc 	andi	r4,r6,15
   49480:	02c000c4 	movi	r11,3
   49484:	11c7883a 	add	r3,r2,r7
   49488:	29cb883a 	add	r5,r5,r7
   4948c:	5900212e 	bgeu	r11,r4,49514 <memcpy+0x140>
   49490:	1813883a 	mov	r9,r3
   49494:	2811883a 	mov	r8,r5
   49498:	200f883a 	mov	r7,r4
   4949c:	42800017 	ldw	r10,0(r8)
   494a0:	4a400104 	addi	r9,r9,4
   494a4:	39ffff04 	addi	r7,r7,-4
   494a8:	4abfff15 	stw	r10,-4(r9)
   494ac:	42000104 	addi	r8,r8,4
   494b0:	59fffa36 	bltu	r11,r7,4949c <__alt_mem_epcs_flash+0xfffc849c>
   494b4:	213fff04 	addi	r4,r4,-4
   494b8:	2008d0ba 	srli	r4,r4,2
   494bc:	318000cc 	andi	r6,r6,3
   494c0:	21000044 	addi	r4,r4,1
   494c4:	2109883a 	add	r4,r4,r4
   494c8:	2109883a 	add	r4,r4,r4
   494cc:	1907883a 	add	r3,r3,r4
   494d0:	290b883a 	add	r5,r5,r4
   494d4:	30000626 	beq	r6,zero,494f0 <memcpy+0x11c>
   494d8:	198d883a 	add	r6,r3,r6
   494dc:	29c00003 	ldbu	r7,0(r5)
   494e0:	18c00044 	addi	r3,r3,1
   494e4:	29400044 	addi	r5,r5,1
   494e8:	19ffffc5 	stb	r7,-1(r3)
   494ec:	19bffb1e 	bne	r3,r6,494dc <__alt_mem_epcs_flash+0xfffc84dc>
   494f0:	dfc00217 	ldw	ra,8(sp)
   494f4:	dc400117 	ldw	r17,4(sp)
   494f8:	dc000017 	ldw	r16,0(sp)
   494fc:	dec00304 	addi	sp,sp,12
   49500:	f800283a 	ret
   49504:	2007883a 	mov	r3,r4
   49508:	003ff206 	br	494d4 <__alt_mem_epcs_flash+0xfffc84d4>
   4950c:	2007883a 	mov	r3,r4
   49510:	003ff106 	br	494d8 <__alt_mem_epcs_flash+0xfffc84d8>
   49514:	200d883a 	mov	r6,r4
   49518:	003fee06 	br	494d4 <__alt_mem_epcs_flash+0xfffc84d4>

0004951c <memset>:
   4951c:	20c000cc 	andi	r3,r4,3
   49520:	2005883a 	mov	r2,r4
   49524:	18004426 	beq	r3,zero,49638 <memset+0x11c>
   49528:	31ffffc4 	addi	r7,r6,-1
   4952c:	30004026 	beq	r6,zero,49630 <memset+0x114>
   49530:	2813883a 	mov	r9,r5
   49534:	200d883a 	mov	r6,r4
   49538:	2007883a 	mov	r3,r4
   4953c:	00000406 	br	49550 <memset+0x34>
   49540:	3a3fffc4 	addi	r8,r7,-1
   49544:	31800044 	addi	r6,r6,1
   49548:	38003926 	beq	r7,zero,49630 <memset+0x114>
   4954c:	400f883a 	mov	r7,r8
   49550:	18c00044 	addi	r3,r3,1
   49554:	32400005 	stb	r9,0(r6)
   49558:	1a0000cc 	andi	r8,r3,3
   4955c:	403ff81e 	bne	r8,zero,49540 <__alt_mem_epcs_flash+0xfffc8540>
   49560:	010000c4 	movi	r4,3
   49564:	21c02d2e 	bgeu	r4,r7,4961c <memset+0x100>
   49568:	29003fcc 	andi	r4,r5,255
   4956c:	200c923a 	slli	r6,r4,8
   49570:	3108b03a 	or	r4,r6,r4
   49574:	200c943a 	slli	r6,r4,16
   49578:	218cb03a 	or	r6,r4,r6
   4957c:	010003c4 	movi	r4,15
   49580:	21c0182e 	bgeu	r4,r7,495e4 <memset+0xc8>
   49584:	3b3ffc04 	addi	r12,r7,-16
   49588:	6018d13a 	srli	r12,r12,4
   4958c:	1a000104 	addi	r8,r3,4
   49590:	1ac00204 	addi	r11,r3,8
   49594:	6008913a 	slli	r4,r12,4
   49598:	1a800304 	addi	r10,r3,12
   4959c:	1813883a 	mov	r9,r3
   495a0:	21000504 	addi	r4,r4,20
   495a4:	1909883a 	add	r4,r3,r4
   495a8:	49800015 	stw	r6,0(r9)
   495ac:	41800015 	stw	r6,0(r8)
   495b0:	59800015 	stw	r6,0(r11)
   495b4:	51800015 	stw	r6,0(r10)
   495b8:	42000404 	addi	r8,r8,16
   495bc:	4a400404 	addi	r9,r9,16
   495c0:	5ac00404 	addi	r11,r11,16
   495c4:	52800404 	addi	r10,r10,16
   495c8:	413ff71e 	bne	r8,r4,495a8 <__alt_mem_epcs_flash+0xfffc85a8>
   495cc:	63000044 	addi	r12,r12,1
   495d0:	6018913a 	slli	r12,r12,4
   495d4:	39c003cc 	andi	r7,r7,15
   495d8:	010000c4 	movi	r4,3
   495dc:	1b07883a 	add	r3,r3,r12
   495e0:	21c00e2e 	bgeu	r4,r7,4961c <memset+0x100>
   495e4:	1813883a 	mov	r9,r3
   495e8:	3811883a 	mov	r8,r7
   495ec:	010000c4 	movi	r4,3
   495f0:	49800015 	stw	r6,0(r9)
   495f4:	423fff04 	addi	r8,r8,-4
   495f8:	4a400104 	addi	r9,r9,4
   495fc:	223ffc36 	bltu	r4,r8,495f0 <__alt_mem_epcs_flash+0xfffc85f0>
   49600:	393fff04 	addi	r4,r7,-4
   49604:	2008d0ba 	srli	r4,r4,2
   49608:	39c000cc 	andi	r7,r7,3
   4960c:	21000044 	addi	r4,r4,1
   49610:	2109883a 	add	r4,r4,r4
   49614:	2109883a 	add	r4,r4,r4
   49618:	1907883a 	add	r3,r3,r4
   4961c:	38000526 	beq	r7,zero,49634 <memset+0x118>
   49620:	19cf883a 	add	r7,r3,r7
   49624:	19400005 	stb	r5,0(r3)
   49628:	18c00044 	addi	r3,r3,1
   4962c:	38fffd1e 	bne	r7,r3,49624 <__alt_mem_epcs_flash+0xfffc8624>
   49630:	f800283a 	ret
   49634:	f800283a 	ret
   49638:	2007883a 	mov	r3,r4
   4963c:	300f883a 	mov	r7,r6
   49640:	003fc706 	br	49560 <__alt_mem_epcs_flash+0xfffc8560>

00049644 <strcmp>:
   49644:	2144b03a 	or	r2,r4,r5
   49648:	108000cc 	andi	r2,r2,3
   4964c:	1000171e 	bne	r2,zero,496ac <strcmp+0x68>
   49650:	20800017 	ldw	r2,0(r4)
   49654:	28c00017 	ldw	r3,0(r5)
   49658:	10c0141e 	bne	r2,r3,496ac <strcmp+0x68>
   4965c:	027fbff4 	movhi	r9,65279
   49660:	4a7fbfc4 	addi	r9,r9,-257
   49664:	0086303a 	nor	r3,zero,r2
   49668:	02202074 	movhi	r8,32897
   4966c:	1245883a 	add	r2,r2,r9
   49670:	42202004 	addi	r8,r8,-32640
   49674:	10c4703a 	and	r2,r2,r3
   49678:	1204703a 	and	r2,r2,r8
   4967c:	10000226 	beq	r2,zero,49688 <strcmp+0x44>
   49680:	00002306 	br	49710 <strcmp+0xcc>
   49684:	1000221e 	bne	r2,zero,49710 <strcmp+0xcc>
   49688:	21000104 	addi	r4,r4,4
   4968c:	20c00017 	ldw	r3,0(r4)
   49690:	29400104 	addi	r5,r5,4
   49694:	29800017 	ldw	r6,0(r5)
   49698:	1a4f883a 	add	r7,r3,r9
   4969c:	00c4303a 	nor	r2,zero,r3
   496a0:	3884703a 	and	r2,r7,r2
   496a4:	1204703a 	and	r2,r2,r8
   496a8:	19bff626 	beq	r3,r6,49684 <__alt_mem_epcs_flash+0xfffc8684>
   496ac:	20800003 	ldbu	r2,0(r4)
   496b0:	10c03fcc 	andi	r3,r2,255
   496b4:	18c0201c 	xori	r3,r3,128
   496b8:	18ffe004 	addi	r3,r3,-128
   496bc:	18000c26 	beq	r3,zero,496f0 <strcmp+0xac>
   496c0:	29800007 	ldb	r6,0(r5)
   496c4:	19800326 	beq	r3,r6,496d4 <strcmp+0x90>
   496c8:	00001306 	br	49718 <strcmp+0xd4>
   496cc:	29800007 	ldb	r6,0(r5)
   496d0:	11800b1e 	bne	r2,r6,49700 <strcmp+0xbc>
   496d4:	21000044 	addi	r4,r4,1
   496d8:	20c00003 	ldbu	r3,0(r4)
   496dc:	29400044 	addi	r5,r5,1
   496e0:	18803fcc 	andi	r2,r3,255
   496e4:	1080201c 	xori	r2,r2,128
   496e8:	10bfe004 	addi	r2,r2,-128
   496ec:	103ff71e 	bne	r2,zero,496cc <__alt_mem_epcs_flash+0xfffc86cc>
   496f0:	0007883a 	mov	r3,zero
   496f4:	28800003 	ldbu	r2,0(r5)
   496f8:	1885c83a 	sub	r2,r3,r2
   496fc:	f800283a 	ret
   49700:	28800003 	ldbu	r2,0(r5)
   49704:	18c03fcc 	andi	r3,r3,255
   49708:	1885c83a 	sub	r2,r3,r2
   4970c:	f800283a 	ret
   49710:	0005883a 	mov	r2,zero
   49714:	f800283a 	ret
   49718:	10c03fcc 	andi	r3,r2,255
   4971c:	003ff506 	br	496f4 <__alt_mem_epcs_flash+0xfffc86f4>

00049720 <strlen>:
   49720:	208000cc 	andi	r2,r4,3
   49724:	10002026 	beq	r2,zero,497a8 <strlen+0x88>
   49728:	20800007 	ldb	r2,0(r4)
   4972c:	10002026 	beq	r2,zero,497b0 <strlen+0x90>
   49730:	2005883a 	mov	r2,r4
   49734:	00000206 	br	49740 <strlen+0x20>
   49738:	10c00007 	ldb	r3,0(r2)
   4973c:	18001826 	beq	r3,zero,497a0 <strlen+0x80>
   49740:	10800044 	addi	r2,r2,1
   49744:	10c000cc 	andi	r3,r2,3
   49748:	183ffb1e 	bne	r3,zero,49738 <__alt_mem_epcs_flash+0xfffc8738>
   4974c:	10c00017 	ldw	r3,0(r2)
   49750:	01ffbff4 	movhi	r7,65279
   49754:	39ffbfc4 	addi	r7,r7,-257
   49758:	00ca303a 	nor	r5,zero,r3
   4975c:	01a02074 	movhi	r6,32897
   49760:	19c7883a 	add	r3,r3,r7
   49764:	31a02004 	addi	r6,r6,-32640
   49768:	1946703a 	and	r3,r3,r5
   4976c:	1986703a 	and	r3,r3,r6
   49770:	1800091e 	bne	r3,zero,49798 <strlen+0x78>
   49774:	10800104 	addi	r2,r2,4
   49778:	10c00017 	ldw	r3,0(r2)
   4977c:	19cb883a 	add	r5,r3,r7
   49780:	00c6303a 	nor	r3,zero,r3
   49784:	28c6703a 	and	r3,r5,r3
   49788:	1986703a 	and	r3,r3,r6
   4978c:	183ff926 	beq	r3,zero,49774 <__alt_mem_epcs_flash+0xfffc8774>
   49790:	00000106 	br	49798 <strlen+0x78>
   49794:	10800044 	addi	r2,r2,1
   49798:	10c00007 	ldb	r3,0(r2)
   4979c:	183ffd1e 	bne	r3,zero,49794 <__alt_mem_epcs_flash+0xfffc8794>
   497a0:	1105c83a 	sub	r2,r2,r4
   497a4:	f800283a 	ret
   497a8:	2005883a 	mov	r2,r4
   497ac:	003fe706 	br	4974c <__alt_mem_epcs_flash+0xfffc874c>
   497b0:	0005883a 	mov	r2,zero
   497b4:	f800283a 	ret

000497b8 <strncmp>:
   497b8:	30003126 	beq	r6,zero,49880 <strncmp+0xc8>
   497bc:	2144b03a 	or	r2,r4,r5
   497c0:	108000cc 	andi	r2,r2,3
   497c4:	10001e1e 	bne	r2,zero,49840 <strncmp+0x88>
   497c8:	024000c4 	movi	r9,3
   497cc:	49801c2e 	bgeu	r9,r6,49840 <strncmp+0x88>
   497d0:	20800017 	ldw	r2,0(r4)
   497d4:	28c00017 	ldw	r3,0(r5)
   497d8:	10c0191e 	bne	r2,r3,49840 <strncmp+0x88>
   497dc:	31bfff04 	addi	r6,r6,-4
   497e0:	30002726 	beq	r6,zero,49880 <strncmp+0xc8>
   497e4:	02ffbff4 	movhi	r11,65279
   497e8:	5affbfc4 	addi	r11,r11,-257
   497ec:	0086303a 	nor	r3,zero,r2
   497f0:	02a02074 	movhi	r10,32897
   497f4:	12c5883a 	add	r2,r2,r11
   497f8:	52a02004 	addi	r10,r10,-32640
   497fc:	10c4703a 	and	r2,r2,r3
   49800:	1284703a 	and	r2,r2,r10
   49804:	10000b26 	beq	r2,zero,49834 <strncmp+0x7c>
   49808:	00001d06 	br	49880 <strncmp+0xc8>
   4980c:	20c00017 	ldw	r3,0(r4)
   49810:	29c00017 	ldw	r7,0(r5)
   49814:	1ad1883a 	add	r8,r3,r11
   49818:	00c4303a 	nor	r2,zero,r3
   4981c:	4084703a 	and	r2,r8,r2
   49820:	1284703a 	and	r2,r2,r10
   49824:	19c0061e 	bne	r3,r7,49840 <strncmp+0x88>
   49828:	31bfff04 	addi	r6,r6,-4
   4982c:	30001426 	beq	r6,zero,49880 <strncmp+0xc8>
   49830:	1000131e 	bne	r2,zero,49880 <strncmp+0xc8>
   49834:	21000104 	addi	r4,r4,4
   49838:	29400104 	addi	r5,r5,4
   4983c:	49bff336 	bltu	r9,r6,4980c <__alt_mem_epcs_flash+0xfffc880c>
   49840:	28800007 	ldb	r2,0(r5)
   49844:	20c00007 	ldb	r3,0(r4)
   49848:	31bfffc4 	addi	r6,r6,-1
   4984c:	10c0081e 	bne	r2,r3,49870 <strncmp+0xb8>
   49850:	30000b26 	beq	r6,zero,49880 <strncmp+0xc8>
   49854:	10000a26 	beq	r2,zero,49880 <strncmp+0xc8>
   49858:	21000044 	addi	r4,r4,1
   4985c:	29400044 	addi	r5,r5,1
   49860:	20800007 	ldb	r2,0(r4)
   49864:	28c00007 	ldb	r3,0(r5)
   49868:	31bfffc4 	addi	r6,r6,-1
   4986c:	10fff826 	beq	r2,r3,49850 <__alt_mem_epcs_flash+0xfffc8850>
   49870:	20800003 	ldbu	r2,0(r4)
   49874:	28c00003 	ldbu	r3,0(r5)
   49878:	10c5c83a 	sub	r2,r2,r3
   4987c:	f800283a 	ret
   49880:	0005883a 	mov	r2,zero
   49884:	f800283a 	ret

00049888 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   49888:	defffc04 	addi	sp,sp,-16
   4988c:	dfc00315 	stw	ra,12(sp)
   49890:	df000215 	stw	fp,8(sp)
   49894:	df000204 	addi	fp,sp,8
   49898:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   4989c:	d1600604 	addi	r5,gp,-32744
   498a0:	e13fff17 	ldw	r4,-4(fp)
   498a4:	004c4840 	call	4c484 <alt_find_dev>
   498a8:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   498ac:	e0bffe17 	ldw	r2,-8(fp)
   498b0:	10000926 	beq	r2,zero,498d8 <alt_flash_open_dev+0x50>
   498b4:	e0bffe17 	ldw	r2,-8(fp)
   498b8:	10800317 	ldw	r2,12(r2)
   498bc:	10000626 	beq	r2,zero,498d8 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   498c0:	e0bffe17 	ldw	r2,-8(fp)
   498c4:	10800317 	ldw	r2,12(r2)
   498c8:	e17fff17 	ldw	r5,-4(fp)
   498cc:	e13ffe17 	ldw	r4,-8(fp)
   498d0:	103ee83a 	callr	r2
   498d4:	00000106 	br	498dc <alt_flash_open_dev+0x54>
  }

  return dev;
   498d8:	e0bffe17 	ldw	r2,-8(fp)
}
   498dc:	e037883a 	mov	sp,fp
   498e0:	dfc00117 	ldw	ra,4(sp)
   498e4:	df000017 	ldw	fp,0(sp)
   498e8:	dec00204 	addi	sp,sp,8
   498ec:	f800283a 	ret

000498f0 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   498f0:	defffd04 	addi	sp,sp,-12
   498f4:	dfc00215 	stw	ra,8(sp)
   498f8:	df000115 	stw	fp,4(sp)
   498fc:	df000104 	addi	fp,sp,4
   49900:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   49904:	e0bfff17 	ldw	r2,-4(fp)
   49908:	10000826 	beq	r2,zero,4992c <alt_flash_close_dev+0x3c>
   4990c:	e0bfff17 	ldw	r2,-4(fp)
   49910:	10800417 	ldw	r2,16(r2)
   49914:	10000526 	beq	r2,zero,4992c <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
   49918:	e0bfff17 	ldw	r2,-4(fp)
   4991c:	10800417 	ldw	r2,16(r2)
   49920:	e13fff17 	ldw	r4,-4(fp)
   49924:	103ee83a 	callr	r2
  }
  return;
   49928:	0001883a 	nop
   4992c:	0001883a 	nop
}
   49930:	e037883a 	mov	sp,fp
   49934:	dfc00117 	ldw	ra,4(sp)
   49938:	df000017 	ldw	fp,0(sp)
   4993c:	dec00204 	addi	sp,sp,8
   49940:	f800283a 	ret

00049944 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   49944:	defff904 	addi	sp,sp,-28
   49948:	dfc00615 	stw	ra,24(sp)
   4994c:	df000515 	stw	fp,20(sp)
   49950:	df000504 	addi	fp,sp,20
   49954:	e13ffc15 	stw	r4,-16(fp)
   49958:	e17ffd15 	stw	r5,-12(fp)
   4995c:	e1bffe15 	stw	r6,-8(fp)
   49960:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   49964:	e0800217 	ldw	r2,8(fp)
   49968:	d8800015 	stw	r2,0(sp)
   4996c:	e1ffff17 	ldw	r7,-4(fp)
   49970:	e1bffe17 	ldw	r6,-8(fp)
   49974:	e17ffd17 	ldw	r5,-12(fp)
   49978:	e13ffc17 	ldw	r4,-16(fp)
   4997c:	0049af40 	call	49af4 <alt_iic_isr_register>
}  
   49980:	e037883a 	mov	sp,fp
   49984:	dfc00117 	ldw	ra,4(sp)
   49988:	df000017 	ldw	fp,0(sp)
   4998c:	dec00204 	addi	sp,sp,8
   49990:	f800283a 	ret

00049994 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
   49994:	defff904 	addi	sp,sp,-28
   49998:	df000615 	stw	fp,24(sp)
   4999c:	df000604 	addi	fp,sp,24
   499a0:	e13ffe15 	stw	r4,-8(fp)
   499a4:	e17fff15 	stw	r5,-4(fp)
   499a8:	e0bfff17 	ldw	r2,-4(fp)
   499ac:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   499b0:	0005303a 	rdctl	r2,status
   499b4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   499b8:	e0fffb17 	ldw	r3,-20(fp)
   499bc:	00bfff84 	movi	r2,-2
   499c0:	1884703a 	and	r2,r3,r2
   499c4:	1001703a 	wrctl	status,r2
  
  return context;
   499c8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   499cc:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
   499d0:	00c00044 	movi	r3,1
   499d4:	e0bffa17 	ldw	r2,-24(fp)
   499d8:	1884983a 	sll	r2,r3,r2
   499dc:	1007883a 	mov	r3,r2
   499e0:	d0a01917 	ldw	r2,-32668(gp)
   499e4:	1884b03a 	or	r2,r3,r2
   499e8:	d0a01915 	stw	r2,-32668(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   499ec:	d0a01917 	ldw	r2,-32668(gp)
   499f0:	100170fa 	wrctl	ienable,r2
   499f4:	e0bffc17 	ldw	r2,-16(fp)
   499f8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   499fc:	e0bffd17 	ldw	r2,-12(fp)
   49a00:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   49a04:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
   49a08:	0001883a 	nop
}
   49a0c:	e037883a 	mov	sp,fp
   49a10:	df000017 	ldw	fp,0(sp)
   49a14:	dec00104 	addi	sp,sp,4
   49a18:	f800283a 	ret

00049a1c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
   49a1c:	defff904 	addi	sp,sp,-28
   49a20:	df000615 	stw	fp,24(sp)
   49a24:	df000604 	addi	fp,sp,24
   49a28:	e13ffe15 	stw	r4,-8(fp)
   49a2c:	e17fff15 	stw	r5,-4(fp)
   49a30:	e0bfff17 	ldw	r2,-4(fp)
   49a34:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   49a38:	0005303a 	rdctl	r2,status
   49a3c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   49a40:	e0fffb17 	ldw	r3,-20(fp)
   49a44:	00bfff84 	movi	r2,-2
   49a48:	1884703a 	and	r2,r3,r2
   49a4c:	1001703a 	wrctl	status,r2
  
  return context;
   49a50:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   49a54:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
   49a58:	00c00044 	movi	r3,1
   49a5c:	e0bffa17 	ldw	r2,-24(fp)
   49a60:	1884983a 	sll	r2,r3,r2
   49a64:	0084303a 	nor	r2,zero,r2
   49a68:	1007883a 	mov	r3,r2
   49a6c:	d0a01917 	ldw	r2,-32668(gp)
   49a70:	1884703a 	and	r2,r3,r2
   49a74:	d0a01915 	stw	r2,-32668(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   49a78:	d0a01917 	ldw	r2,-32668(gp)
   49a7c:	100170fa 	wrctl	ienable,r2
   49a80:	e0bffc17 	ldw	r2,-16(fp)
   49a84:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   49a88:	e0bffd17 	ldw	r2,-12(fp)
   49a8c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   49a90:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
   49a94:	0001883a 	nop
}
   49a98:	e037883a 	mov	sp,fp
   49a9c:	df000017 	ldw	fp,0(sp)
   49aa0:	dec00104 	addi	sp,sp,4
   49aa4:	f800283a 	ret

00049aa8 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
   49aa8:	defffc04 	addi	sp,sp,-16
   49aac:	df000315 	stw	fp,12(sp)
   49ab0:	df000304 	addi	fp,sp,12
   49ab4:	e13ffe15 	stw	r4,-8(fp)
   49ab8:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   49abc:	000530fa 	rdctl	r2,ienable
   49ac0:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
   49ac4:	00c00044 	movi	r3,1
   49ac8:	e0bfff17 	ldw	r2,-4(fp)
   49acc:	1884983a 	sll	r2,r3,r2
   49ad0:	1007883a 	mov	r3,r2
   49ad4:	e0bffd17 	ldw	r2,-12(fp)
   49ad8:	1884703a 	and	r2,r3,r2
   49adc:	1004c03a 	cmpne	r2,r2,zero
   49ae0:	10803fcc 	andi	r2,r2,255
}
   49ae4:	e037883a 	mov	sp,fp
   49ae8:	df000017 	ldw	fp,0(sp)
   49aec:	dec00104 	addi	sp,sp,4
   49af0:	f800283a 	ret

00049af4 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   49af4:	defff504 	addi	sp,sp,-44
   49af8:	dfc00a15 	stw	ra,40(sp)
   49afc:	df000915 	stw	fp,36(sp)
   49b00:	df000904 	addi	fp,sp,36
   49b04:	e13ffc15 	stw	r4,-16(fp)
   49b08:	e17ffd15 	stw	r5,-12(fp)
   49b0c:	e1bffe15 	stw	r6,-8(fp)
   49b10:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
   49b14:	00bffa84 	movi	r2,-22
   49b18:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
   49b1c:	e0bffd17 	ldw	r2,-12(fp)
   49b20:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   49b24:	e0bff817 	ldw	r2,-32(fp)
   49b28:	10800808 	cmpgei	r2,r2,32
   49b2c:	1000271e 	bne	r2,zero,49bcc <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   49b30:	0005303a 	rdctl	r2,status
   49b34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   49b38:	e0fffb17 	ldw	r3,-20(fp)
   49b3c:	00bfff84 	movi	r2,-2
   49b40:	1884703a 	and	r2,r3,r2
   49b44:	1001703a 	wrctl	status,r2
  
  return context;
   49b48:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
   49b4c:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
   49b50:	008001b4 	movhi	r2,6
   49b54:	10909104 	addi	r2,r2,16964
   49b58:	e0fff817 	ldw	r3,-32(fp)
   49b5c:	180690fa 	slli	r3,r3,3
   49b60:	10c5883a 	add	r2,r2,r3
   49b64:	e0fffe17 	ldw	r3,-8(fp)
   49b68:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
   49b6c:	008001b4 	movhi	r2,6
   49b70:	10909104 	addi	r2,r2,16964
   49b74:	e0fff817 	ldw	r3,-32(fp)
   49b78:	180690fa 	slli	r3,r3,3
   49b7c:	10c5883a 	add	r2,r2,r3
   49b80:	10800104 	addi	r2,r2,4
   49b84:	e0ffff17 	ldw	r3,-4(fp)
   49b88:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   49b8c:	e0bffe17 	ldw	r2,-8(fp)
   49b90:	10000526 	beq	r2,zero,49ba8 <alt_iic_isr_register+0xb4>
   49b94:	e0bff817 	ldw	r2,-32(fp)
   49b98:	100b883a 	mov	r5,r2
   49b9c:	e13ffc17 	ldw	r4,-16(fp)
   49ba0:	00499940 	call	49994 <alt_ic_irq_enable>
   49ba4:	00000406 	br	49bb8 <alt_iic_isr_register+0xc4>
   49ba8:	e0bff817 	ldw	r2,-32(fp)
   49bac:	100b883a 	mov	r5,r2
   49bb0:	e13ffc17 	ldw	r4,-16(fp)
   49bb4:	0049a1c0 	call	49a1c <alt_ic_irq_disable>
   49bb8:	e0bff715 	stw	r2,-36(fp)
   49bbc:	e0bffa17 	ldw	r2,-24(fp)
   49bc0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   49bc4:	e0bff917 	ldw	r2,-28(fp)
   49bc8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
   49bcc:	e0bff717 	ldw	r2,-36(fp)
}
   49bd0:	e037883a 	mov	sp,fp
   49bd4:	dfc00117 	ldw	ra,4(sp)
   49bd8:	df000017 	ldw	fp,0(sp)
   49bdc:	dec00204 	addi	sp,sp,8
   49be0:	f800283a 	ret

00049be4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   49be4:	defffc04 	addi	sp,sp,-16
   49be8:	df000315 	stw	fp,12(sp)
   49bec:	df000304 	addi	fp,sp,12
   49bf0:	e13ffd15 	stw	r4,-12(fp)
   49bf4:	e17ffe15 	stw	r5,-8(fp)
   49bf8:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   49bfc:	e0fffe17 	ldw	r3,-8(fp)
   49c00:	e0bffd17 	ldw	r2,-12(fp)
   49c04:	18800c26 	beq	r3,r2,49c38 <alt_load_section+0x54>
  {
    while( to != end )
   49c08:	00000806 	br	49c2c <alt_load_section+0x48>
    {
      *to++ = *from++;
   49c0c:	e0bffe17 	ldw	r2,-8(fp)
   49c10:	10c00104 	addi	r3,r2,4
   49c14:	e0fffe15 	stw	r3,-8(fp)
   49c18:	e0fffd17 	ldw	r3,-12(fp)
   49c1c:	19000104 	addi	r4,r3,4
   49c20:	e13ffd15 	stw	r4,-12(fp)
   49c24:	18c00017 	ldw	r3,0(r3)
   49c28:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   49c2c:	e0fffe17 	ldw	r3,-8(fp)
   49c30:	e0bfff17 	ldw	r2,-4(fp)
   49c34:	18bff51e 	bne	r3,r2,49c0c <__alt_mem_epcs_flash+0xfffc8c0c>
    {
      *to++ = *from++;
    }
  }
}
   49c38:	0001883a 	nop
   49c3c:	e037883a 	mov	sp,fp
   49c40:	df000017 	ldw	fp,0(sp)
   49c44:	dec00104 	addi	sp,sp,4
   49c48:	f800283a 	ret

00049c4c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   49c4c:	defffe04 	addi	sp,sp,-8
   49c50:	dfc00115 	stw	ra,4(sp)
   49c54:	df000015 	stw	fp,0(sp)
   49c58:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   49c5c:	018001b4 	movhi	r6,6
   49c60:	31b45304 	addi	r6,r6,-11956
   49c64:	014001b4 	movhi	r5,6
   49c68:	29656c04 	addi	r5,r5,-27216
   49c6c:	010001b4 	movhi	r4,6
   49c70:	21256c04 	addi	r4,r4,-27216
   49c74:	0049be40 	call	49be4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   49c78:	01800134 	movhi	r6,4
   49c7c:	31809104 	addi	r6,r6,580
   49c80:	01400134 	movhi	r5,4
   49c84:	29400804 	addi	r5,r5,32
   49c88:	01000134 	movhi	r4,4
   49c8c:	21000804 	addi	r4,r4,32
   49c90:	0049be40 	call	49be4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   49c94:	018001b4 	movhi	r6,6
   49c98:	31a56c04 	addi	r6,r6,-27216
   49c9c:	01400174 	movhi	r5,5
   49ca0:	2974dc04 	addi	r5,r5,-11408
   49ca4:	01000174 	movhi	r4,5
   49ca8:	2134dc04 	addi	r4,r4,-11408
   49cac:	0049be40 	call	49be4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   49cb0:	004c2980 	call	4c298 <alt_dcache_flush_all>
  alt_icache_flush_all();
   49cb4:	004c5140 	call	4c514 <alt_icache_flush_all>
}
   49cb8:	0001883a 	nop
   49cbc:	e037883a 	mov	sp,fp
   49cc0:	dfc00117 	ldw	ra,4(sp)
   49cc4:	df000017 	ldw	fp,0(sp)
   49cc8:	dec00204 	addi	sp,sp,8
   49ccc:	f800283a 	ret

00049cd0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   49cd0:	defffd04 	addi	sp,sp,-12
   49cd4:	dfc00215 	stw	ra,8(sp)
   49cd8:	df000115 	stw	fp,4(sp)
   49cdc:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   49ce0:	0009883a 	mov	r4,zero
   49ce4:	0049d800 	call	49d80 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   49ce8:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   49cec:	0049db80 	call	49db8 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   49cf0:	018001b4 	movhi	r6,6
   49cf4:	31a55c04 	addi	r6,r6,-27280
   49cf8:	014001b4 	movhi	r5,6
   49cfc:	29655c04 	addi	r5,r5,-27280
   49d00:	010001b4 	movhi	r4,6
   49d04:	21255c04 	addi	r4,r4,-27280
   49d08:	004c6a80 	call	4c6a8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   49d0c:	004c3c40 	call	4c3c4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   49d10:	01000174 	movhi	r4,5
   49d14:	21310904 	addi	r4,r4,-15324
   49d18:	004cfdc0 	call	4cfdc <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   49d1c:	d0a01a17 	ldw	r2,-32664(gp)
   49d20:	d0e01b17 	ldw	r3,-32660(gp)
   49d24:	d1201c17 	ldw	r4,-32656(gp)
   49d28:	200d883a 	mov	r6,r4
   49d2c:	180b883a 	mov	r5,r3
   49d30:	1009883a 	mov	r4,r2
   49d34:	00424b40 	call	424b4 <main>
   49d38:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   49d3c:	01000044 	movi	r4,1
   49d40:	004c1c80 	call	4c1c8 <close>
  exit (result);
   49d44:	e13fff17 	ldw	r4,-4(fp)
   49d48:	004cff00 	call	4cff0 <exit>

00049d4c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   49d4c:	defffd04 	addi	sp,sp,-12
   49d50:	dfc00215 	stw	ra,8(sp)
   49d54:	df000115 	stw	fp,4(sp)
   49d58:	df000104 	addi	fp,sp,4
   49d5c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   49d60:	d1600b04 	addi	r5,gp,-32724
   49d64:	e13fff17 	ldw	r4,-4(fp)
   49d68:	004c3200 	call	4c320 <alt_dev_llist_insert>
}
   49d6c:	e037883a 	mov	sp,fp
   49d70:	dfc00117 	ldw	ra,4(sp)
   49d74:	df000017 	ldw	fp,0(sp)
   49d78:	dec00204 	addi	sp,sp,8
   49d7c:	f800283a 	ret

00049d80 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   49d80:	defffd04 	addi	sp,sp,-12
   49d84:	dfc00215 	stw	ra,8(sp)
   49d88:	df000115 	stw	fp,4(sp)
   49d8c:	df000104 	addi	fp,sp,4
   49d90:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
   49d94:	004cb800 	call	4cb80 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   49d98:	00800044 	movi	r2,1
   49d9c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   49da0:	0001883a 	nop
   49da4:	e037883a 	mov	sp,fp
   49da8:	dfc00117 	ldw	ra,4(sp)
   49dac:	df000017 	ldw	fp,0(sp)
   49db0:	dec00204 	addi	sp,sp,8
   49db4:	f800283a 	ret

00049db8 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   49db8:	defffe04 	addi	sp,sp,-8
   49dbc:	dfc00115 	stw	ra,4(sp)
   49dc0:	df000015 	stw	fp,0(sp)
   49dc4:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( LED_TIMER, led_timer);
   49dc8:	01c0fa04 	movi	r7,1000
   49dcc:	01800084 	movi	r6,2
   49dd0:	000b883a 	mov	r5,zero
   49dd4:	01000234 	movhi	r4,8
   49dd8:	21082804 	addi	r4,r4,8352
   49ddc:	004b9a80 	call	4b9a8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( WATCHDOG, watchdog);
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_FLASH, epcs_flash);
   49de0:	010001b4 	movhi	r4,6
   49de4:	212e8204 	addi	r4,r4,-17912
   49de8:	0049e6c0 	call	49e6c <alt_epcs_flash_init>
    ALTERA_AVALON_FIFO_INIT ( LASER_FIFO, laser_fifo);
   49dec:	0001883a 	nop
    ALTERA_AVALON_FIFO_INIT ( PROTOCOL_FIFO, protocol_fifo);
   49df0:	0001883a 	nop
    ALTERA_AVALON_FIFO_INIT ( SPIRD_FIFO, spird_fifo);
   49df4:	0001883a 	nop
    ALTERA_AVALON_FIFO_INIT ( SPIWR_FIFO, spiwr_fifo);
   49df8:	0001883a 	nop
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   49dfc:	000d883a 	mov	r6,zero
   49e00:	000b883a 	mov	r5,zero
   49e04:	010001b4 	movhi	r4,6
   49e08:	212ebf04 	addi	r4,r4,-17668
   49e0c:	004b02c0 	call	4b02c <altera_avalon_jtag_uart_init>
   49e10:	010001b4 	movhi	r4,6
   49e14:	212eb504 	addi	r4,r4,-17708
   49e18:	0049d4c0 	call	49d4c <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   49e1c:	0001883a 	nop
}
   49e20:	0001883a 	nop
   49e24:	e037883a 	mov	sp,fp
   49e28:	dfc00117 	ldw	ra,4(sp)
   49e2c:	df000017 	ldw	fp,0(sp)
   49e30:	dec00204 	addi	sp,sp,8
   49e34:	f800283a 	ret

00049e38 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
   49e38:	defffd04 	addi	sp,sp,-12
   49e3c:	dfc00215 	stw	ra,8(sp)
   49e40:	df000115 	stw	fp,4(sp)
   49e44:	df000104 	addi	fp,sp,4
   49e48:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
   49e4c:	d1600604 	addi	r5,gp,-32744
   49e50:	e13fff17 	ldw	r4,-4(fp)
   49e54:	004c3200 	call	4c320 <alt_dev_llist_insert>
}
   49e58:	e037883a 	mov	sp,fp
   49e5c:	dfc00117 	ldw	ra,4(sp)
   49e60:	df000017 	ldw	fp,0(sp)
   49e64:	dec00204 	addi	sp,sp,8
   49e68:	f800283a 	ret

00049e6c <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
   49e6c:	defffc04 	addi	sp,sp,-16
   49e70:	dfc00315 	stw	ra,12(sp)
   49e74:	df000215 	stw	fp,8(sp)
   49e78:	df000204 	addi	fp,sp,8
   49e7c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   49e80:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
   49e84:	e13fff17 	ldw	r4,-4(fp)
   49e88:	0049ec00 	call	49ec0 <alt_epcs_flash_query>
   49e8c:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
   49e90:	e0bffe17 	ldw	r2,-8(fp)
   49e94:	1000041e 	bne	r2,zero,49ea8 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
   49e98:	e0bfff17 	ldw	r2,-4(fp)
   49e9c:	1009883a 	mov	r4,r2
   49ea0:	0049e380 	call	49e38 <alt_flash_device_register>
   49ea4:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
   49ea8:	e0bffe17 	ldw	r2,-8(fp)
}
   49eac:	e037883a 	mov	sp,fp
   49eb0:	dfc00117 	ldw	ra,4(sp)
   49eb4:	df000017 	ldw	fp,0(sp)
   49eb8:	dec00204 	addi	sp,sp,8
   49ebc:	f800283a 	ret

00049ec0 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
   49ec0:	defffc04 	addi	sp,sp,-16
   49ec4:	dfc00315 	stw	ra,12(sp)
   49ec8:	df000215 	stw	fp,8(sp)
   49ecc:	df000204 	addi	fp,sp,8
   49ed0:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   49ed4:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
   49ed8:	e0bfff17 	ldw	r2,-4(fp)
   49edc:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
   49ee0:	e0bfff17 	ldw	r2,-4(fp)
   49ee4:	10802e17 	ldw	r2,184(r2)
   49ee8:	1009883a 	mov	r4,r2
   49eec:	004bec00 	call	4bec0 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
   49ef0:	10c03fcc 	andi	r3,r2,255
   49ef4:	e0bfff17 	ldw	r2,-4(fp)
   49ef8:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
   49efc:	e0bfff17 	ldw	r2,-4(fp)
   49f00:	10803017 	ldw	r2,192(r2)
   49f04:	10800598 	cmpnei	r2,r2,22
   49f08:	10000a1e 	bne	r2,zero,49f34 <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
   49f0c:	e0bfff17 	ldw	r2,-4(fp)
   49f10:	00c02034 	movhi	r3,128
   49f14:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
   49f18:	e0bfff17 	ldw	r2,-4(fp)
   49f1c:	00c02004 	movi	r3,128
   49f20:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   49f24:	e0bfff17 	ldw	r2,-4(fp)
   49f28:	00c00074 	movhi	r3,1
   49f2c:	10c01015 	stw	r3,64(r2)
   49f30:	0000f206 	br	4a2fc <alt_epcs_flash_query+0x43c>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
   49f34:	e0bfff17 	ldw	r2,-4(fp)
   49f38:	10803017 	ldw	r2,192(r2)
   49f3c:	10800518 	cmpnei	r2,r2,20
   49f40:	10000a1e 	bne	r2,zero,49f6c <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
   49f44:	e0bfff17 	ldw	r2,-4(fp)
   49f48:	00c00834 	movhi	r3,32
   49f4c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
   49f50:	e0bfff17 	ldw	r2,-4(fp)
   49f54:	00c00804 	movi	r3,32
   49f58:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   49f5c:	e0bfff17 	ldw	r2,-4(fp)
   49f60:	00c00074 	movhi	r3,1
   49f64:	10c01015 	stw	r3,64(r2)
   49f68:	0000e406 	br	4a2fc <alt_epcs_flash_query+0x43c>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
   49f6c:	e0bfff17 	ldw	r2,-4(fp)
   49f70:	10803017 	ldw	r2,192(r2)
   49f74:	108004d8 	cmpnei	r2,r2,19
   49f78:	10000a1e 	bne	r2,zero,49fa4 <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
   49f7c:	e0bfff17 	ldw	r2,-4(fp)
   49f80:	00c00434 	movhi	r3,16
   49f84:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
   49f88:	e0bfff17 	ldw	r2,-4(fp)
   49f8c:	00c00404 	movi	r3,16
   49f90:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   49f94:	e0bfff17 	ldw	r2,-4(fp)
   49f98:	00c00074 	movhi	r3,1
   49f9c:	10c01015 	stw	r3,64(r2)
   49fa0:	0000d606 	br	4a2fc <alt_epcs_flash_query+0x43c>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
   49fa4:	e0bfff17 	ldw	r2,-4(fp)
   49fa8:	10803017 	ldw	r2,192(r2)
   49fac:	10800498 	cmpnei	r2,r2,18
   49fb0:	10000a1e 	bne	r2,zero,49fdc <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
   49fb4:	e0bfff17 	ldw	r2,-4(fp)
   49fb8:	00c00234 	movhi	r3,8
   49fbc:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
   49fc0:	e0bfff17 	ldw	r2,-4(fp)
   49fc4:	00c00204 	movi	r3,8
   49fc8:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   49fcc:	e0bfff17 	ldw	r2,-4(fp)
   49fd0:	00c00074 	movhi	r3,1
   49fd4:	10c01015 	stw	r3,64(r2)
   49fd8:	0000c806 	br	4a2fc <alt_epcs_flash_query+0x43c>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
   49fdc:	e0bfff17 	ldw	r2,-4(fp)
   49fe0:	10803017 	ldw	r2,192(r2)
   49fe4:	10800418 	cmpnei	r2,r2,16
   49fe8:	10000a1e 	bne	r2,zero,4a014 <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
   49fec:	e0bfff17 	ldw	r2,-4(fp)
   49ff0:	00c000b4 	movhi	r3,2
   49ff4:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
   49ff8:	e0bfff17 	ldw	r2,-4(fp)
   49ffc:	00c00104 	movi	r3,4
   4a000:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
   4a004:	e0bfff17 	ldw	r2,-4(fp)
   4a008:	00e00014 	movui	r3,32768
   4a00c:	10c01015 	stw	r3,64(r2)
   4a010:	0000ba06 	br	4a2fc <alt_epcs_flash_query+0x43c>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
   4a014:	e0bfff17 	ldw	r2,-4(fp)
   4a018:	10802e17 	ldw	r2,184(r2)
   4a01c:	1009883a 	mov	r4,r2
   4a020:	004bf280 	call	4bf28 <epcs_read_device_id>
   4a024:	1007883a 	mov	r3,r2
   4a028:	e0bfff17 	ldw	r2,-4(fp)
   4a02c:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
   4a030:	e0bfff17 	ldw	r2,-4(fp)
   4a034:	10c03017 	ldw	r3,192(r2)
   4a038:	00804034 	movhi	r2,256
   4a03c:	10bfffc4 	addi	r2,r2,-1
   4a040:	1886703a 	and	r3,r3,r2
   4a044:	00800874 	movhi	r2,33
   4a048:	10ae8544 	addi	r2,r2,-17899
   4a04c:	18800a1e 	bne	r3,r2,4a078 <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
   4a050:	e0bfff17 	ldw	r2,-4(fp)
   4a054:	00c00834 	movhi	r3,32
   4a058:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
   4a05c:	e0bfff17 	ldw	r2,-4(fp)
   4a060:	00c00804 	movi	r3,32
   4a064:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a068:	e0bfff17 	ldw	r2,-4(fp)
   4a06c:	00c00074 	movhi	r3,1
   4a070:	10c01015 	stw	r3,64(r2)
   4a074:	0000a106 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
   4a078:	e0bfff17 	ldw	r2,-4(fp)
   4a07c:	10c03017 	ldw	r3,192(r2)
   4a080:	00804034 	movhi	r2,256
   4a084:	10bfffc4 	addi	r2,r2,-1
   4a088:	1886703a 	and	r3,r3,r2
   4a08c:	00800874 	movhi	r2,33
   4a090:	10ae8584 	addi	r2,r2,-17898
   4a094:	18800a1e 	bne	r3,r2,4a0c0 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
   4a098:	e0bfff17 	ldw	r2,-4(fp)
   4a09c:	00c01034 	movhi	r3,64
   4a0a0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
   4a0a4:	e0bfff17 	ldw	r2,-4(fp)
   4a0a8:	00c01004 	movi	r3,64
   4a0ac:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a0b0:	e0bfff17 	ldw	r2,-4(fp)
   4a0b4:	00c00074 	movhi	r3,1
   4a0b8:	10c01015 	stw	r3,64(r2)
   4a0bc:	00008f06 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0xEF4016) /* EPCQ32 */
   4a0c0:	e0bfff17 	ldw	r2,-4(fp)
   4a0c4:	10c03017 	ldw	r3,192(r2)
   4a0c8:	00804034 	movhi	r2,256
   4a0cc:	10bfffc4 	addi	r2,r2,-1
   4a0d0:	1886703a 	and	r3,r3,r2
   4a0d4:	00803bf4 	movhi	r2,239
   4a0d8:	10900584 	addi	r2,r2,16406
   4a0dc:	18800a1e 	bne	r3,r2,4a108 <alt_epcs_flash_query+0x248>
        {
          flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
   4a0e0:	e0bfff17 	ldw	r2,-4(fp)
   4a0e4:	00c01034 	movhi	r3,64
   4a0e8:	10c00e15 	stw	r3,56(r2)
          flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
   4a0ec:	e0bfff17 	ldw	r2,-4(fp)
   4a0f0:	00c01004 	movi	r3,64
   4a0f4:	10c00f15 	stw	r3,60(r2)
          flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a0f8:	e0bfff17 	ldw	r2,-4(fp)
   4a0fc:	00c00074 	movhi	r3,1
   4a100:	10c01015 	stw	r3,64(r2)
   4a104:	00007d06 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0xC22016) /* EPCQ32 *///flashļ
   4a108:	e0bfff17 	ldw	r2,-4(fp)
   4a10c:	10c03017 	ldw	r3,192(r2)
   4a110:	00804034 	movhi	r2,256
   4a114:	10bfffc4 	addi	r2,r2,-1
   4a118:	1886703a 	and	r3,r3,r2
   4a11c:	008030b4 	movhi	r2,194
   4a120:	10880584 	addi	r2,r2,8214
   4a124:	18800a1e 	bne	r3,r2,4a150 <alt_epcs_flash_query+0x290>
        {
          flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
   4a128:	e0bfff17 	ldw	r2,-4(fp)
   4a12c:	00c01034 	movhi	r3,64
   4a130:	10c00e15 	stw	r3,56(r2)
          flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
   4a134:	e0bfff17 	ldw	r2,-4(fp)
   4a138:	00c01004 	movi	r3,64
   4a13c:	10c00f15 	stw	r3,60(r2)
          flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a140:	e0bfff17 	ldw	r2,-4(fp)
   4a144:	00c00074 	movhi	r3,1
   4a148:	10c01015 	stw	r3,64(r2)
   4a14c:	00006b06 	br	4a2fc <alt_epcs_flash_query+0x43c>
        }

    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
   4a150:	e0bfff17 	ldw	r2,-4(fp)
   4a154:	10c03017 	ldw	r3,192(r2)
   4a158:	00804034 	movhi	r2,256
   4a15c:	10bfffc4 	addi	r2,r2,-1
   4a160:	1886703a 	and	r3,r3,r2
   4a164:	00800874 	movhi	r2,33
   4a168:	10ae85c4 	addi	r2,r2,-17897
   4a16c:	18800a1e 	bne	r3,r2,4a198 <alt_epcs_flash_query+0x2d8>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
   4a170:	e0bfff17 	ldw	r2,-4(fp)
   4a174:	00c02034 	movhi	r3,128
   4a178:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
   4a17c:	e0bfff17 	ldw	r2,-4(fp)
   4a180:	00c02004 	movi	r3,128
   4a184:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a188:	e0bfff17 	ldw	r2,-4(fp)
   4a18c:	00c00074 	movhi	r3,1
   4a190:	10c01015 	stw	r3,64(r2)
   4a194:	00005906 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
   4a198:	e0bfff17 	ldw	r2,-4(fp)
   4a19c:	10c03017 	ldw	r3,192(r2)
   4a1a0:	00804034 	movhi	r2,256
   4a1a4:	10bfffc4 	addi	r2,r2,-1
   4a1a8:	1886703a 	and	r3,r3,r2
   4a1ac:	00800874 	movhi	r2,33
   4a1b0:	10ae8604 	addi	r2,r2,-17896
   4a1b4:	18800a1e 	bne	r3,r2,4a1e0 <alt_epcs_flash_query+0x320>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
   4a1b8:	e0bfff17 	ldw	r2,-4(fp)
   4a1bc:	00c04034 	movhi	r3,256
   4a1c0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
   4a1c4:	e0bfff17 	ldw	r2,-4(fp)
   4a1c8:	00c04004 	movi	r3,256
   4a1cc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a1d0:	e0bfff17 	ldw	r2,-4(fp)
   4a1d4:	00c00074 	movhi	r3,1
   4a1d8:	10c01015 	stw	r3,64(r2)
   4a1dc:	00004706 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
   4a1e0:	e0bfff17 	ldw	r2,-4(fp)
   4a1e4:	10803017 	ldw	r2,192(r2)
   4a1e8:	10803fcc 	andi	r2,r2,255
   4a1ec:	10800618 	cmpnei	r2,r2,24
   4a1f0:	10000a1e 	bne	r2,zero,4a21c <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
   4a1f4:	e0bfff17 	ldw	r2,-4(fp)
   4a1f8:	00c04034 	movhi	r3,256
   4a1fc:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
   4a200:	e0bfff17 	ldw	r2,-4(fp)
   4a204:	00c01004 	movi	r3,64
   4a208:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
   4a20c:	e0bfff17 	ldw	r2,-4(fp)
   4a210:	00c00134 	movhi	r3,4
   4a214:	10c01015 	stw	r3,64(r2)
   4a218:	00003806 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
   4a21c:	e0bfff17 	ldw	r2,-4(fp)
   4a220:	10803017 	ldw	r2,192(r2)
   4a224:	10803fcc 	andi	r2,r2,255
   4a228:	10800658 	cmpnei	r2,r2,25
   4a22c:	10000d1e 	bne	r2,zero,4a264 <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
   4a230:	e0bfff17 	ldw	r2,-4(fp)
   4a234:	00c08034 	movhi	r3,512
   4a238:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
   4a23c:	e0bfff17 	ldw	r2,-4(fp)
   4a240:	00c08004 	movi	r3,512
   4a244:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a248:	e0bfff17 	ldw	r2,-4(fp)
   4a24c:	00c00074 	movhi	r3,1
   4a250:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
   4a254:	e0bfff17 	ldw	r2,-4(fp)
   4a258:	00c00044 	movi	r3,1
   4a25c:	10c03215 	stw	r3,200(r2)
   4a260:	00002606 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
   4a264:	e0bfff17 	ldw	r2,-4(fp)
   4a268:	10803017 	ldw	r2,192(r2)
   4a26c:	10803fcc 	andi	r2,r2,255
   4a270:	10800818 	cmpnei	r2,r2,32
   4a274:	10000d1e 	bne	r2,zero,4a2ac <alt_epcs_flash_query+0x3ec>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
   4a278:	e0bfff17 	ldw	r2,-4(fp)
   4a27c:	00c10034 	movhi	r3,1024
   4a280:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
   4a284:	e0bfff17 	ldw	r2,-4(fp)
   4a288:	00c10004 	movi	r3,1024
   4a28c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a290:	e0bfff17 	ldw	r2,-4(fp)
   4a294:	00c00074 	movhi	r3,1
   4a298:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
   4a29c:	e0bfff17 	ldw	r2,-4(fp)
   4a2a0:	00c00044 	movi	r3,1
   4a2a4:	10c03215 	stw	r3,200(r2)
   4a2a8:	00001406 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
   4a2ac:	e0bfff17 	ldw	r2,-4(fp)
   4a2b0:	10803017 	ldw	r2,192(r2)
   4a2b4:	10803fcc 	andi	r2,r2,255
   4a2b8:	10800858 	cmpnei	r2,r2,33
   4a2bc:	10000d1e 	bne	r2,zero,4a2f4 <alt_epcs_flash_query+0x434>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
   4a2c0:	e0bfff17 	ldw	r2,-4(fp)
   4a2c4:	00c20034 	movhi	r3,2048
   4a2c8:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
   4a2cc:	e0bfff17 	ldw	r2,-4(fp)
   4a2d0:	00c20004 	movi	r3,2048
   4a2d4:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   4a2d8:	e0bfff17 	ldw	r2,-4(fp)
   4a2dc:	00c00074 	movhi	r3,1
   4a2e0:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
   4a2e4:	e0bfff17 	ldw	r2,-4(fp)
   4a2e8:	00c00044 	movi	r3,1
   4a2ec:	10c03215 	stw	r3,200(r2)
   4a2f0:	00000206 	br	4a2fc <alt_epcs_flash_query+0x43c>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
   4a2f4:	00bffb44 	movi	r2,-19
   4a2f8:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
   4a2fc:	e0bfff17 	ldw	r2,-4(fp)
   4a300:	10800e17 	ldw	r2,56(r2)
   4a304:	1007883a 	mov	r3,r2
   4a308:	e0bfff17 	ldw	r2,-4(fp)
   4a30c:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
   4a310:	e0bfff17 	ldw	r2,-4(fp)
   4a314:	00c00044 	movi	r3,1
   4a318:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
   4a31c:	e0bfff17 	ldw	r2,-4(fp)
   4a320:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
   4a324:	e0bfff17 	ldw	r2,-4(fp)
   4a328:	00c04004 	movi	r3,256
   4a32c:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
   4a330:	e0bffe17 	ldw	r2,-8(fp)
}
   4a334:	e037883a 	mov	sp,fp
   4a338:	dfc00117 	ldw	ra,4(sp)
   4a33c:	df000017 	ldw	fp,0(sp)
   4a340:	dec00204 	addi	sp,sp,8
   4a344:	f800283a 	ret

0004a348 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
   4a348:	deffee04 	addi	sp,sp,-72
   4a34c:	dfc01115 	stw	ra,68(sp)
   4a350:	df001015 	stw	fp,64(sp)
   4a354:	df001004 	addi	fp,sp,64
   4a358:	e13ffc15 	stw	r4,-16(fp)
   4a35c:	e17ffd15 	stw	r5,-12(fp)
   4a360:	e1bffe15 	stw	r6,-8(fp)
   4a364:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
   4a368:	00800804 	movi	r2,32
   4a36c:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
   4a370:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
   4a374:	00002706 	br	4a414 <alt_epcs_flash_memcmp+0xcc>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
   4a378:	e0fff117 	ldw	r3,-60(fp)
   4a37c:	e0bfff17 	ldw	r2,-4(fp)
   4a380:	1880012e 	bgeu	r3,r2,4a388 <alt_epcs_flash_memcmp+0x40>
   4a384:	1805883a 	mov	r2,r3
   4a388:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
   4a38c:	e0fffe17 	ldw	r3,-8(fp)
   4a390:	e0bff017 	ldw	r2,-64(fp)
   4a394:	1885883a 	add	r2,r3,r2
   4a398:	e0fff404 	addi	r3,fp,-48
   4a39c:	e1fff217 	ldw	r7,-56(fp)
   4a3a0:	180d883a 	mov	r6,r3
   4a3a4:	100b883a 	mov	r5,r2
   4a3a8:	e13ffc17 	ldw	r4,-16(fp)
   4a3ac:	004a92c0 	call	4a92c <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
   4a3b0:	1000020e 	bge	r2,zero,4a3bc <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
   4a3b4:	00bfffc4 	movi	r2,-1
   4a3b8:	00001906 	br	4a420 <alt_epcs_flash_memcmp+0xd8>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
   4a3bc:	e0bff017 	ldw	r2,-64(fp)
   4a3c0:	e0fffd17 	ldw	r3,-12(fp)
   4a3c4:	1885883a 	add	r2,r3,r2
   4a3c8:	e13ff217 	ldw	r4,-56(fp)
   4a3cc:	e0fff404 	addi	r3,fp,-48
   4a3d0:	200d883a 	mov	r6,r4
   4a3d4:	180b883a 	mov	r5,r3
   4a3d8:	1009883a 	mov	r4,r2
   4a3dc:	004d0280 	call	4d028 <memcmp>
   4a3e0:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
   4a3e4:	e0bff317 	ldw	r2,-52(fp)
   4a3e8:	10000226 	beq	r2,zero,4a3f4 <alt_epcs_flash_memcmp+0xac>
    {
      return this_chunk_cmp;
   4a3ec:	e0bff317 	ldw	r2,-52(fp)
   4a3f0:	00000b06 	br	4a420 <alt_epcs_flash_memcmp+0xd8>
    }

    n -= this_chunk_size;
   4a3f4:	e0bff217 	ldw	r2,-56(fp)
   4a3f8:	e0ffff17 	ldw	r3,-4(fp)
   4a3fc:	1885c83a 	sub	r2,r3,r2
   4a400:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
   4a404:	e0fff017 	ldw	r3,-64(fp)
   4a408:	e0bff217 	ldw	r2,-56(fp)
   4a40c:	1885883a 	add	r2,r3,r2
   4a410:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
   4a414:	e0bfff17 	ldw	r2,-4(fp)
   4a418:	103fd71e 	bne	r2,zero,4a378 <__alt_mem_epcs_flash+0xfffc9378>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
   4a41c:	0005883a 	mov	r2,zero
}
   4a420:	e037883a 	mov	sp,fp
   4a424:	dfc00117 	ldw	ra,4(sp)
   4a428:	df000017 	ldw	fp,0(sp)
   4a42c:	dec00204 	addi	sp,sp,8
   4a430:	f800283a 	ret

0004a434 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
   4a434:	defff404 	addi	sp,sp,-48
   4a438:	dfc00b15 	stw	ra,44(sp)
   4a43c:	df000a15 	stw	fp,40(sp)
   4a440:	df000a04 	addi	fp,sp,40
   4a444:	e13ffc15 	stw	r4,-16(fp)
   4a448:	e17ffd15 	stw	r5,-12(fp)
   4a44c:	e1bffe15 	stw	r6,-8(fp)
   4a450:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
   4a454:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
   4a458:	e03ff815 	stw	zero,-32(fp)
   4a45c:	00008306 	br	4a66c <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
   4a460:	e0fffc17 	ldw	r3,-16(fp)
   4a464:	e0bff817 	ldw	r2,-32(fp)
   4a468:	1004913a 	slli	r2,r2,4
   4a46c:	1885883a 	add	r2,r3,r2
   4a470:	10800d04 	addi	r2,r2,52
   4a474:	10800017 	ldw	r2,0(r2)
   4a478:	e0fffd17 	ldw	r3,-12(fp)
   4a47c:	18807816 	blt	r3,r2,4a660 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
   4a480:	e0fffc17 	ldw	r3,-16(fp)
   4a484:	e0bff817 	ldw	r2,-32(fp)
   4a488:	1004913a 	slli	r2,r2,4
   4a48c:	1885883a 	add	r2,r3,r2
   4a490:	10800d04 	addi	r2,r2,52
   4a494:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
   4a498:	e13ffc17 	ldw	r4,-16(fp)
   4a49c:	e0bff817 	ldw	r2,-32(fp)
   4a4a0:	1004913a 	slli	r2,r2,4
   4a4a4:	2085883a 	add	r2,r4,r2
   4a4a8:	10800e04 	addi	r2,r2,56
   4a4ac:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
   4a4b0:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
   4a4b4:	e0fffd17 	ldw	r3,-12(fp)
   4a4b8:	1880690e 	bge	r3,r2,4a660 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
   4a4bc:	e0fffc17 	ldw	r3,-16(fp)
   4a4c0:	e0bff817 	ldw	r2,-32(fp)
   4a4c4:	1004913a 	slli	r2,r2,4
   4a4c8:	1885883a 	add	r2,r3,r2
   4a4cc:	10800d04 	addi	r2,r2,52
   4a4d0:	10800017 	ldw	r2,0(r2)
   4a4d4:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
   4a4d8:	e03ff915 	stw	zero,-28(fp)
   4a4dc:	00005806 	br	4a640 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
   4a4e0:	e0fffd17 	ldw	r3,-12(fp)
   4a4e4:	e0bffa17 	ldw	r2,-24(fp)
   4a4e8:	18804916 	blt	r3,r2,4a610 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
   4a4ec:	e0fffc17 	ldw	r3,-16(fp)
   4a4f0:	e0bff817 	ldw	r2,-32(fp)
   4a4f4:	10800104 	addi	r2,r2,4
   4a4f8:	1004913a 	slli	r2,r2,4
   4a4fc:	1885883a 	add	r2,r3,r2
   4a500:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
   4a504:	e0bffa17 	ldw	r2,-24(fp)
   4a508:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
   4a50c:	e0fffd17 	ldw	r3,-12(fp)
   4a510:	18803f0e 	bge	r3,r2,4a610 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
   4a514:	e0fffc17 	ldw	r3,-16(fp)
   4a518:	e0bff817 	ldw	r2,-32(fp)
   4a51c:	10800104 	addi	r2,r2,4
   4a520:	1004913a 	slli	r2,r2,4
   4a524:	1885883a 	add	r2,r3,r2
   4a528:	10c00017 	ldw	r3,0(r2)
   4a52c:	e0bffa17 	ldw	r2,-24(fp)
   4a530:	1887883a 	add	r3,r3,r2
   4a534:	e0bffd17 	ldw	r2,-12(fp)
   4a538:	1885c83a 	sub	r2,r3,r2
   4a53c:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
   4a540:	e0fffb17 	ldw	r3,-20(fp)
   4a544:	e0bfff17 	ldw	r2,-4(fp)
   4a548:	1880010e 	bge	r3,r2,4a550 <alt_epcs_flash_write+0x11c>
   4a54c:	1805883a 	mov	r2,r3
   4a550:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
   4a554:	e0bffb17 	ldw	r2,-20(fp)
   4a558:	100f883a 	mov	r7,r2
   4a55c:	e1bffd17 	ldw	r6,-12(fp)
   4a560:	e17ffe17 	ldw	r5,-8(fp)
   4a564:	e13ffc17 	ldw	r4,-16(fp)
   4a568:	004a3480 	call	4a348 <alt_epcs_flash_memcmp>
   4a56c:	10001226 	beq	r2,zero,4a5b8 <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
   4a570:	e0bffc17 	ldw	r2,-16(fp)
   4a574:	10800817 	ldw	r2,32(r2)
   4a578:	e17ffa17 	ldw	r5,-24(fp)
   4a57c:	e13ffc17 	ldw	r4,-16(fp)
   4a580:	103ee83a 	callr	r2
   4a584:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
   4a588:	e0bff717 	ldw	r2,-36(fp)
   4a58c:	10000a1e 	bne	r2,zero,4a5b8 <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
   4a590:	e0bffc17 	ldw	r2,-16(fp)
   4a594:	10800917 	ldw	r2,36(r2)
   4a598:	e0fffb17 	ldw	r3,-20(fp)
   4a59c:	d8c00015 	stw	r3,0(sp)
   4a5a0:	e1fffe17 	ldw	r7,-8(fp)
   4a5a4:	e1bffd17 	ldw	r6,-12(fp)
   4a5a8:	e17ffa17 	ldw	r5,-24(fp)
   4a5ac:	e13ffc17 	ldw	r4,-16(fp)
   4a5b0:	103ee83a 	callr	r2
   4a5b4:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
   4a5b8:	e0ffff17 	ldw	r3,-4(fp)
   4a5bc:	e0bffb17 	ldw	r2,-20(fp)
   4a5c0:	18802e26 	beq	r3,r2,4a67c <alt_epcs_flash_write+0x248>
   4a5c4:	e0bff717 	ldw	r2,-36(fp)
   4a5c8:	10002c1e 	bne	r2,zero,4a67c <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
   4a5cc:	e0ffff17 	ldw	r3,-4(fp)
   4a5d0:	e0bffb17 	ldw	r2,-20(fp)
   4a5d4:	1885c83a 	sub	r2,r3,r2
   4a5d8:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
   4a5dc:	e0fffc17 	ldw	r3,-16(fp)
   4a5e0:	e0bff817 	ldw	r2,-32(fp)
   4a5e4:	10800104 	addi	r2,r2,4
   4a5e8:	1004913a 	slli	r2,r2,4
   4a5ec:	1885883a 	add	r2,r3,r2
   4a5f0:	10c00017 	ldw	r3,0(r2)
   4a5f4:	e0bffa17 	ldw	r2,-24(fp)
   4a5f8:	1885883a 	add	r2,r3,r2
   4a5fc:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
   4a600:	e0bffb17 	ldw	r2,-20(fp)
   4a604:	e0fffe17 	ldw	r3,-8(fp)
   4a608:	1885883a 	add	r2,r3,r2
   4a60c:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
   4a610:	e0fffc17 	ldw	r3,-16(fp)
   4a614:	e0bff817 	ldw	r2,-32(fp)
   4a618:	10800104 	addi	r2,r2,4
   4a61c:	1004913a 	slli	r2,r2,4
   4a620:	1885883a 	add	r2,r3,r2
   4a624:	10800017 	ldw	r2,0(r2)
   4a628:	e0fffa17 	ldw	r3,-24(fp)
   4a62c:	1885883a 	add	r2,r3,r2
   4a630:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
   4a634:	e0bff917 	ldw	r2,-28(fp)
   4a638:	10800044 	addi	r2,r2,1
   4a63c:	e0bff915 	stw	r2,-28(fp)
   4a640:	e0fffc17 	ldw	r3,-16(fp)
   4a644:	e0bff817 	ldw	r2,-32(fp)
   4a648:	1004913a 	slli	r2,r2,4
   4a64c:	1885883a 	add	r2,r3,r2
   4a650:	10800f04 	addi	r2,r2,60
   4a654:	10800017 	ldw	r2,0(r2)
   4a658:	e0fff917 	ldw	r3,-28(fp)
   4a65c:	18bfa016 	blt	r3,r2,4a4e0 <__alt_mem_epcs_flash+0xfffc94e0>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
   4a660:	e0bff817 	ldw	r2,-32(fp)
   4a664:	10800044 	addi	r2,r2,1
   4a668:	e0bff815 	stw	r2,-32(fp)
   4a66c:	e0bffc17 	ldw	r2,-16(fp)
   4a670:	10800c17 	ldw	r2,48(r2)
   4a674:	e0fff817 	ldw	r3,-32(fp)
   4a678:	18bf7916 	blt	r3,r2,4a460 <__alt_mem_epcs_flash+0xfffc9460>
      }
    }
  }

finished:
  return ret_code;
   4a67c:	e0bff717 	ldw	r2,-36(fp)
}
   4a680:	e037883a 	mov	sp,fp
   4a684:	dfc00117 	ldw	ra,4(sp)
   4a688:	df000017 	ldw	fp,0(sp)
   4a68c:	dec00204 	addi	sp,sp,8
   4a690:	f800283a 	ret

0004a694 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
   4a694:	defffa04 	addi	sp,sp,-24
   4a698:	df000515 	stw	fp,20(sp)
   4a69c:	df000504 	addi	fp,sp,20
   4a6a0:	e13ffd15 	stw	r4,-12(fp)
   4a6a4:	e17ffe15 	stw	r5,-8(fp)
   4a6a8:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
   4a6ac:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
   4a6b0:	e0bffd17 	ldw	r2,-12(fp)
   4a6b4:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
   4a6b8:	e0bffc17 	ldw	r2,-16(fp)
   4a6bc:	10c00c17 	ldw	r3,48(r2)
   4a6c0:	e0bfff17 	ldw	r2,-4(fp)
   4a6c4:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
   4a6c8:	e0bffc17 	ldw	r2,-16(fp)
   4a6cc:	10800c17 	ldw	r2,48(r2)
   4a6d0:	1000031e 	bne	r2,zero,4a6e0 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
   4a6d4:	00bffec4 	movi	r2,-5
   4a6d8:	e0bffb15 	stw	r2,-20(fp)
   4a6dc:	00000b06 	br	4a70c <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
   4a6e0:	e0bffc17 	ldw	r2,-16(fp)
   4a6e4:	10800c17 	ldw	r2,48(r2)
   4a6e8:	10800250 	cmplti	r2,r2,9
   4a6ec:	1000031e 	bne	r2,zero,4a6fc <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
   4a6f0:	00bffd04 	movi	r2,-12
   4a6f4:	e0bffb15 	stw	r2,-20(fp)
   4a6f8:	00000406 	br	4a70c <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
   4a6fc:	e0bffc17 	ldw	r2,-16(fp)
   4a700:	10c00d04 	addi	r3,r2,52
   4a704:	e0bffe17 	ldw	r2,-8(fp)
   4a708:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
   4a70c:	e0bffb17 	ldw	r2,-20(fp)
}
   4a710:	e037883a 	mov	sp,fp
   4a714:	df000017 	ldw	fp,0(sp)
   4a718:	dec00104 	addi	sp,sp,4
   4a71c:	f800283a 	ret

0004a720 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
   4a720:	defff904 	addi	sp,sp,-28
   4a724:	df000615 	stw	fp,24(sp)
   4a728:	df000604 	addi	fp,sp,24
   4a72c:	e13ffe15 	stw	r4,-8(fp)
   4a730:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
   4a734:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   4a738:	e0bffe17 	ldw	r2,-8(fp)
   4a73c:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
   4a740:	e0bffb17 	ldw	r2,-20(fp)
   4a744:	10800c17 	ldw	r2,48(r2)
   4a748:	10bfffc4 	addi	r2,r2,-1
   4a74c:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
   4a750:	e0fffb17 	ldw	r3,-20(fp)
   4a754:	e0bffc17 	ldw	r2,-16(fp)
   4a758:	1004913a 	slli	r2,r2,4
   4a75c:	1885883a 	add	r2,r3,r2
   4a760:	10800d04 	addi	r2,r2,52
   4a764:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
   4a768:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
   4a76c:	e13ffb17 	ldw	r4,-20(fp)
   4a770:	e0bffc17 	ldw	r2,-16(fp)
   4a774:	1004913a 	slli	r2,r2,4
   4a778:	2085883a 	add	r2,r4,r2
   4a77c:	10800e04 	addi	r2,r2,56
   4a780:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
   4a784:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
   4a788:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
   4a78c:	e0bfff17 	ldw	r2,-4(fp)
   4a790:	e0fffd17 	ldw	r3,-12(fp)
   4a794:	1880022e 	bgeu	r3,r2,4a7a0 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
   4a798:	00bffec4 	movi	r2,-5
   4a79c:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
   4a7a0:	e0bffa17 	ldw	r2,-24(fp)
}
   4a7a4:	e037883a 	mov	sp,fp
   4a7a8:	df000017 	ldw	fp,0(sp)
   4a7ac:	dec00104 	addi	sp,sp,4
   4a7b0:	f800283a 	ret

0004a7b4 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
   4a7b4:	defffa04 	addi	sp,sp,-24
   4a7b8:	dfc00515 	stw	ra,20(sp)
   4a7bc:	df000415 	stw	fp,16(sp)
   4a7c0:	df000404 	addi	fp,sp,16
   4a7c4:	e13ffe15 	stw	r4,-8(fp)
   4a7c8:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
   4a7cc:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   4a7d0:	e0bffe17 	ldw	r2,-8(fp)
   4a7d4:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
   4a7d8:	e17fff17 	ldw	r5,-4(fp)
   4a7dc:	e13ffe17 	ldw	r4,-8(fp)
   4a7e0:	004a7200 	call	4a720 <alt_epcs_test_address>
   4a7e4:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
   4a7e8:	e0bffc17 	ldw	r2,-16(fp)
   4a7ec:	10000916 	blt	r2,zero,4a814 <alt_epcs_flash_erase_block+0x60>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
   4a7f0:	e0bffd17 	ldw	r2,-12(fp)
   4a7f4:	10c02e17 	ldw	r3,184(r2)
   4a7f8:	e13fff17 	ldw	r4,-4(fp)
   4a7fc:	e0bffd17 	ldw	r2,-12(fp)
   4a800:	10803217 	ldw	r2,200(r2)
   4a804:	100d883a 	mov	r6,r2
   4a808:	200b883a 	mov	r5,r4
   4a80c:	1809883a 	mov	r4,r3
   4a810:	004baf40 	call	4baf4 <epcs_sector_erase>
  }
  return ret_code;
   4a814:	e0bffc17 	ldw	r2,-16(fp)
}
   4a818:	e037883a 	mov	sp,fp
   4a81c:	dfc00117 	ldw	ra,4(sp)
   4a820:	df000017 	ldw	fp,0(sp)
   4a824:	dec00204 	addi	sp,sp,8
   4a828:	f800283a 	ret

0004a82c <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
   4a82c:	defff404 	addi	sp,sp,-48
   4a830:	dfc00b15 	stw	ra,44(sp)
   4a834:	df000a15 	stw	fp,40(sp)
   4a838:	df000a04 	addi	fp,sp,40
   4a83c:	e13ffc15 	stw	r4,-16(fp)
   4a840:	e17ffd15 	stw	r5,-12(fp)
   4a844:	e1bffe15 	stw	r6,-8(fp)
   4a848:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   4a84c:	e0bffc17 	ldw	r2,-16(fp)
   4a850:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
   4a854:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
   4a858:	e17ffe17 	ldw	r5,-8(fp)
   4a85c:	e13ffc17 	ldw	r4,-16(fp)
   4a860:	004a7200 	call	4a720 <alt_epcs_test_address>
   4a864:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
   4a868:	e0bff917 	ldw	r2,-28(fp)
   4a86c:	10002916 	blt	r2,zero,4a914 <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
   4a870:	00002606 	br	4a90c <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
   4a874:	e0bff817 	ldw	r2,-32(fp)
   4a878:	10c03117 	ldw	r3,196(r2)
   4a87c:	e0bffe17 	ldw	r2,-8(fp)
   4a880:	1887883a 	add	r3,r3,r2
   4a884:	e0bff817 	ldw	r2,-32(fp)
   4a888:	10803117 	ldw	r2,196(r2)
   4a88c:	0085c83a 	sub	r2,zero,r2
   4a890:	1884703a 	and	r2,r3,r2
   4a894:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
   4a898:	e0fffa17 	ldw	r3,-24(fp)
   4a89c:	e0bffe17 	ldw	r2,-8(fp)
   4a8a0:	1885c83a 	sub	r2,r3,r2
   4a8a4:	e0c00217 	ldw	r3,8(fp)
   4a8a8:	1880010e 	bge	r3,r2,4a8b0 <alt_epcs_flash_write_block+0x84>
   4a8ac:	1805883a 	mov	r2,r3
   4a8b0:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
   4a8b4:	e0bff817 	ldw	r2,-32(fp)
   4a8b8:	11002e17 	ldw	r4,184(r2)
   4a8bc:	e0bff717 	ldw	r2,-36(fp)
   4a8c0:	e0ffff17 	ldw	r3,-4(fp)
   4a8c4:	1887883a 	add	r3,r3,r2
   4a8c8:	e0bff817 	ldw	r2,-32(fp)
   4a8cc:	10803217 	ldw	r2,200(r2)
   4a8d0:	d8800015 	stw	r2,0(sp)
   4a8d4:	e1fffb17 	ldw	r7,-20(fp)
   4a8d8:	180d883a 	mov	r6,r3
   4a8dc:	e17ffe17 	ldw	r5,-8(fp)
   4a8e0:	004bda40 	call	4bda4 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
   4a8e4:	e0c00217 	ldw	r3,8(fp)
   4a8e8:	e0bffb17 	ldw	r2,-20(fp)
   4a8ec:	1885c83a 	sub	r2,r3,r2
   4a8f0:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
   4a8f4:	e0fff717 	ldw	r3,-36(fp)
   4a8f8:	e0bffb17 	ldw	r2,-20(fp)
   4a8fc:	1885883a 	add	r2,r3,r2
   4a900:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
   4a904:	e0bffa17 	ldw	r2,-24(fp)
   4a908:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
   4a90c:	e0800217 	ldw	r2,8(fp)
   4a910:	103fd81e 	bne	r2,zero,4a874 <__alt_mem_epcs_flash+0xfffc9874>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
   4a914:	e0bff917 	ldw	r2,-28(fp)
}
   4a918:	e037883a 	mov	sp,fp
   4a91c:	dfc00117 	ldw	ra,4(sp)
   4a920:	df000017 	ldw	fp,0(sp)
   4a924:	dec00204 	addi	sp,sp,8
   4a928:	f800283a 	ret

0004a92c <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
   4a92c:	defff704 	addi	sp,sp,-36
   4a930:	dfc00815 	stw	ra,32(sp)
   4a934:	df000715 	stw	fp,28(sp)
   4a938:	df000704 	addi	fp,sp,28
   4a93c:	e13ffc15 	stw	r4,-16(fp)
   4a940:	e17ffd15 	stw	r5,-12(fp)
   4a944:	e1bffe15 	stw	r6,-8(fp)
   4a948:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
   4a94c:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   4a950:	e0bffc17 	ldw	r2,-16(fp)
   4a954:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
   4a958:	e17ffd17 	ldw	r5,-12(fp)
   4a95c:	e13ffc17 	ldw	r4,-16(fp)
   4a960:	004a7200 	call	4a720 <alt_epcs_test_address>
   4a964:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
   4a968:	e0bffa17 	ldw	r2,-24(fp)
   4a96c:	10000f16 	blt	r2,zero,4a9ac <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
   4a970:	e0bffb17 	ldw	r2,-20(fp)
   4a974:	10c02e17 	ldw	r3,184(r2)
   4a978:	e0bffb17 	ldw	r2,-20(fp)
   4a97c:	10803217 	ldw	r2,200(r2)
   4a980:	d8800015 	stw	r2,0(sp)
   4a984:	e1ffff17 	ldw	r7,-4(fp)
   4a988:	e1bffe17 	ldw	r6,-8(fp)
   4a98c:	e17ffd17 	ldw	r5,-12(fp)
   4a990:	1809883a 	mov	r4,r3
   4a994:	004bbf00 	call	4bbf0 <epcs_read_buffer>
   4a998:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
   4a99c:	e0fffa17 	ldw	r3,-24(fp)
   4a9a0:	e0bfff17 	ldw	r2,-4(fp)
   4a9a4:	1880011e 	bne	r3,r2,4a9ac <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
   4a9a8:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
   4a9ac:	e0bffa17 	ldw	r2,-24(fp)
}
   4a9b0:	e037883a 	mov	sp,fp
   4a9b4:	dfc00117 	ldw	ra,4(sp)
   4a9b8:	df000017 	ldw	fp,0(sp)
   4a9bc:	dec00204 	addi	sp,sp,8
   4a9c0:	f800283a 	ret

0004a9c4 <altera_avalon_fifo_init>:



int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
   4a9c4:	defffa04 	addi	sp,sp,-24
   4a9c8:	dfc00515 	stw	ra,20(sp)
   4a9cc:	df000415 	stw	fp,16(sp)
   4a9d0:	df000404 	addi	fp,sp,16
   4a9d4:	e13ffc15 	stw	r4,-16(fp)
   4a9d8:	e17ffd15 	stw	r5,-12(fp)
   4a9dc:	e1bffe15 	stw	r6,-8(fp)
   4a9e0:	e1ffff15 	stw	r7,-4(fp)
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
   4a9e4:	01400fc4 	movi	r5,63
   4a9e8:	e13ffc17 	ldw	r4,-16(fp)
   4a9ec:	004ab900 	call	4ab90 <altera_avalon_fifo_clear_event>
   4a9f0:	10000226 	beq	r2,zero,4a9fc <altera_avalon_fifo_init+0x38>
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
   4a9f4:	00bfffc4 	movi	r2,-1
   4a9f8:	00001306 	br	4aa48 <altera_avalon_fifo_init+0x84>
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
   4a9fc:	e17ffd17 	ldw	r5,-12(fp)
   4aa00:	e13ffc17 	ldw	r4,-16(fp)
   4aa04:	004abf00 	call	4abf0 <altera_avalon_fifo_write_ienable>
   4aa08:	10000226 	beq	r2,zero,4aa14 <altera_avalon_fifo_init+0x50>
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
   4aa0c:	00bfff84 	movi	r2,-2
   4aa10:	00000d06 	br	4aa48 <altera_avalon_fifo_init+0x84>
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
   4aa14:	e17fff17 	ldw	r5,-4(fp)
   4aa18:	e13ffc17 	ldw	r4,-16(fp)
   4aa1c:	004ac4c0 	call	4ac4c <altera_avalon_fifo_write_almostfull>
   4aa20:	10000226 	beq	r2,zero,4aa2c <altera_avalon_fifo_init+0x68>
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
   4aa24:	00bfff44 	movi	r2,-3
   4aa28:	00000706 	br	4aa48 <altera_avalon_fifo_init+0x84>
    }
  
    if( altera_avalon_fifo_write_almostempty(address, emptymark) != ALTERA_AVALON_FIFO_OK)
   4aa2c:	e17ffe17 	ldw	r5,-8(fp)
   4aa30:	e13ffc17 	ldw	r4,-16(fp)
   4aa34:	004aca80 	call	4aca8 <altera_avalon_fifo_write_almostempty>
   4aa38:	10000226 	beq	r2,zero,4aa44 <altera_avalon_fifo_init+0x80>
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
   4aa3c:	00bfff44 	movi	r2,-3
   4aa40:	00000106 	br	4aa48 <altera_avalon_fifo_init+0x84>
    }

    return ALTERA_AVALON_FIFO_OK;
   4aa44:	0005883a 	mov	r2,zero
}
   4aa48:	e037883a 	mov	sp,fp
   4aa4c:	dfc00117 	ldw	ra,4(sp)
   4aa50:	df000017 	ldw	fp,0(sp)
   4aa54:	dec00204 	addi	sp,sp,8
   4aa58:	f800283a 	ret

0004aa5c <altera_avalon_fifo_read_status>:

int altera_avalon_fifo_read_status(alt_u32 address, alt_u32 mask)
{
   4aa5c:	defffd04 	addi	sp,sp,-12
   4aa60:	df000215 	stw	fp,8(sp)
   4aa64:	df000204 	addi	fp,sp,8
   4aa68:	e13ffe15 	stw	r4,-8(fp)
   4aa6c:	e17fff15 	stw	r5,-4(fp)
    return (IORD_ALTERA_AVALON_FIFO_STATUS(address) & mask);
   4aa70:	e0bffe17 	ldw	r2,-8(fp)
   4aa74:	10800104 	addi	r2,r2,4
   4aa78:	10800037 	ldwio	r2,0(r2)
   4aa7c:	1007883a 	mov	r3,r2
   4aa80:	e0bfff17 	ldw	r2,-4(fp)
   4aa84:	1884703a 	and	r2,r3,r2
}
   4aa88:	e037883a 	mov	sp,fp
   4aa8c:	df000017 	ldw	fp,0(sp)
   4aa90:	dec00104 	addi	sp,sp,4
   4aa94:	f800283a 	ret

0004aa98 <altera_avalon_fifo_read_ienable>:

int altera_avalon_fifo_read_ienable(alt_u32 address, alt_u32 mask)
{
   4aa98:	defffd04 	addi	sp,sp,-12
   4aa9c:	df000215 	stw	fp,8(sp)
   4aaa0:	df000204 	addi	fp,sp,8
   4aaa4:	e13ffe15 	stw	r4,-8(fp)
   4aaa8:	e17fff15 	stw	r5,-4(fp)
	
    return (IORD_ALTERA_AVALON_FIFO_IENABLE(address) & mask);
   4aaac:	e0bffe17 	ldw	r2,-8(fp)
   4aab0:	10800304 	addi	r2,r2,12
   4aab4:	10800037 	ldwio	r2,0(r2)
   4aab8:	1007883a 	mov	r3,r2
   4aabc:	e0bfff17 	ldw	r2,-4(fp)
   4aac0:	1884703a 	and	r2,r3,r2
}
   4aac4:	e037883a 	mov	sp,fp
   4aac8:	df000017 	ldw	fp,0(sp)
   4aacc:	dec00104 	addi	sp,sp,4
   4aad0:	f800283a 	ret

0004aad4 <altera_avalon_fifo_read_almostfull>:

int altera_avalon_fifo_read_almostfull(alt_u32 address)
{
   4aad4:	defffe04 	addi	sp,sp,-8
   4aad8:	df000115 	stw	fp,4(sp)
   4aadc:	df000104 	addi	fp,sp,4
   4aae0:	e13fff15 	stw	r4,-4(fp)
    return IORD_ALTERA_AVALON_FIFO_ALMOSTFULL(address);
   4aae4:	e0bfff17 	ldw	r2,-4(fp)
   4aae8:	10800404 	addi	r2,r2,16
   4aaec:	10800037 	ldwio	r2,0(r2)
}
   4aaf0:	e037883a 	mov	sp,fp
   4aaf4:	df000017 	ldw	fp,0(sp)
   4aaf8:	dec00104 	addi	sp,sp,4
   4aafc:	f800283a 	ret

0004ab00 <altera_avalon_fifo_read_almostempty>:

int altera_avalon_fifo_read_almostempty(alt_u32 address)
{
   4ab00:	defffe04 	addi	sp,sp,-8
   4ab04:	df000115 	stw	fp,4(sp)
   4ab08:	df000104 	addi	fp,sp,4
   4ab0c:	e13fff15 	stw	r4,-4(fp)
    return IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address);
   4ab10:	e0bfff17 	ldw	r2,-4(fp)
   4ab14:	10800504 	addi	r2,r2,20
   4ab18:	10800037 	ldwio	r2,0(r2)
}
   4ab1c:	e037883a 	mov	sp,fp
   4ab20:	df000017 	ldw	fp,0(sp)
   4ab24:	dec00104 	addi	sp,sp,4
   4ab28:	f800283a 	ret

0004ab2c <altera_avalon_fifo_read_event>:

int altera_avalon_fifo_read_event(alt_u32 address, alt_u32 mask)
{
   4ab2c:	defffd04 	addi	sp,sp,-12
   4ab30:	df000215 	stw	fp,8(sp)
   4ab34:	df000204 	addi	fp,sp,8
   4ab38:	e13ffe15 	stw	r4,-8(fp)
   4ab3c:	e17fff15 	stw	r5,-4(fp)
    return (IORD_ALTERA_AVALON_FIFO_EVENT(address) & mask);
   4ab40:	e0bffe17 	ldw	r2,-8(fp)
   4ab44:	10800204 	addi	r2,r2,8
   4ab48:	10800037 	ldwio	r2,0(r2)
   4ab4c:	1007883a 	mov	r3,r2
   4ab50:	e0bfff17 	ldw	r2,-4(fp)
   4ab54:	1884703a 	and	r2,r3,r2
}
   4ab58:	e037883a 	mov	sp,fp
   4ab5c:	df000017 	ldw	fp,0(sp)
   4ab60:	dec00104 	addi	sp,sp,4
   4ab64:	f800283a 	ret

0004ab68 <altera_avalon_fifo_read_level>:

int altera_avalon_fifo_read_level(alt_u32 address)
{
   4ab68:	defffe04 	addi	sp,sp,-8
   4ab6c:	df000115 	stw	fp,4(sp)
   4ab70:	df000104 	addi	fp,sp,4
   4ab74:	e13fff15 	stw	r4,-4(fp)
    return IORD_ALTERA_AVALON_FIFO_LEVEL(address);
   4ab78:	e0bfff17 	ldw	r2,-4(fp)
   4ab7c:	10800037 	ldwio	r2,0(r2)
}
   4ab80:	e037883a 	mov	sp,fp
   4ab84:	df000017 	ldw	fp,0(sp)
   4ab88:	dec00104 	addi	sp,sp,4
   4ab8c:	f800283a 	ret

0004ab90 <altera_avalon_fifo_clear_event>:

int altera_avalon_fifo_clear_event(alt_u32 address, alt_u32 mask)
{
   4ab90:	defffd04 	addi	sp,sp,-12
   4ab94:	df000215 	stw	fp,8(sp)
   4ab98:	df000204 	addi	fp,sp,8
   4ab9c:	e13ffe15 	stw	r4,-8(fp)
   4aba0:	e17fff15 	stw	r5,-4(fp)
    IOWR_ALTERA_AVALON_FIFO_EVENT(address, mask);
   4aba4:	e0bffe17 	ldw	r2,-8(fp)
   4aba8:	10800204 	addi	r2,r2,8
   4abac:	1007883a 	mov	r3,r2
   4abb0:	e0bfff17 	ldw	r2,-4(fp)
   4abb4:	18800035 	stwio	r2,0(r3)
    if((IORD_ALTERA_AVALON_FIFO_EVENT(address) & mask) == 0)
   4abb8:	e0bffe17 	ldw	r2,-8(fp)
   4abbc:	10800204 	addi	r2,r2,8
   4abc0:	10800037 	ldwio	r2,0(r2)
   4abc4:	1007883a 	mov	r3,r2
   4abc8:	e0bfff17 	ldw	r2,-4(fp)
   4abcc:	1884703a 	and	r2,r3,r2
   4abd0:	1000021e 	bne	r2,zero,4abdc <altera_avalon_fifo_clear_event+0x4c>
        return ALTERA_AVALON_FIFO_OK;
   4abd4:	0005883a 	mov	r2,zero
   4abd8:	00000106 	br	4abe0 <altera_avalon_fifo_clear_event+0x50>
    else
    return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
   4abdc:	00bfffc4 	movi	r2,-1
}
   4abe0:	e037883a 	mov	sp,fp
   4abe4:	df000017 	ldw	fp,0(sp)
   4abe8:	dec00104 	addi	sp,sp,4
   4abec:	f800283a 	ret

0004abf0 <altera_avalon_fifo_write_ienable>:

int altera_avalon_fifo_write_ienable(alt_u32 address, alt_u32 mask)
{
   4abf0:	defffd04 	addi	sp,sp,-12
   4abf4:	df000215 	stw	fp,8(sp)
   4abf8:	df000204 	addi	fp,sp,8
   4abfc:	e13ffe15 	stw	r4,-8(fp)
   4ac00:	e17fff15 	stw	r5,-4(fp)
    IOWR_ALTERA_AVALON_FIFO_IENABLE(address, mask);
   4ac04:	e0bffe17 	ldw	r2,-8(fp)
   4ac08:	10800304 	addi	r2,r2,12
   4ac0c:	1007883a 	mov	r3,r2
   4ac10:	e0bfff17 	ldw	r2,-4(fp)
   4ac14:	18800035 	stwio	r2,0(r3)
    if(IORD_ALTERA_AVALON_FIFO_IENABLE(address) == mask)
   4ac18:	e0bffe17 	ldw	r2,-8(fp)
   4ac1c:	10800304 	addi	r2,r2,12
   4ac20:	10800037 	ldwio	r2,0(r2)
   4ac24:	1007883a 	mov	r3,r2
   4ac28:	e0bfff17 	ldw	r2,-4(fp)
   4ac2c:	1880021e 	bne	r3,r2,4ac38 <altera_avalon_fifo_write_ienable+0x48>
        return ALTERA_AVALON_FIFO_OK;
   4ac30:	0005883a 	mov	r2,zero
   4ac34:	00000106 	br	4ac3c <altera_avalon_fifo_write_ienable+0x4c>
    else
        return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
   4ac38:	00bfff84 	movi	r2,-2
}
   4ac3c:	e037883a 	mov	sp,fp
   4ac40:	df000017 	ldw	fp,0(sp)
   4ac44:	dec00104 	addi	sp,sp,4
   4ac48:	f800283a 	ret

0004ac4c <altera_avalon_fifo_write_almostfull>:

int altera_avalon_fifo_write_almostfull(alt_u32 address, alt_u32 data)
{
   4ac4c:	defffd04 	addi	sp,sp,-12
   4ac50:	df000215 	stw	fp,8(sp)
   4ac54:	df000204 	addi	fp,sp,8
   4ac58:	e13ffe15 	stw	r4,-8(fp)
   4ac5c:	e17fff15 	stw	r5,-4(fp)
    IOWR_ALTERA_AVALON_FIFO_ALMOSTFULL(address, data);
   4ac60:	e0bffe17 	ldw	r2,-8(fp)
   4ac64:	10800404 	addi	r2,r2,16
   4ac68:	1007883a 	mov	r3,r2
   4ac6c:	e0bfff17 	ldw	r2,-4(fp)
   4ac70:	18800035 	stwio	r2,0(r3)
    if(IORD_ALTERA_AVALON_FIFO_ALMOSTFULL(address) == data)
   4ac74:	e0bffe17 	ldw	r2,-8(fp)
   4ac78:	10800404 	addi	r2,r2,16
   4ac7c:	10800037 	ldwio	r2,0(r2)
   4ac80:	1007883a 	mov	r3,r2
   4ac84:	e0bfff17 	ldw	r2,-4(fp)
   4ac88:	1880021e 	bne	r3,r2,4ac94 <altera_avalon_fifo_write_almostfull+0x48>
        return ALTERA_AVALON_FIFO_OK;
   4ac8c:	0005883a 	mov	r2,zero
   4ac90:	00000106 	br	4ac98 <altera_avalon_fifo_write_almostfull+0x4c>
    else
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
   4ac94:	00bfff44 	movi	r2,-3
}
   4ac98:	e037883a 	mov	sp,fp
   4ac9c:	df000017 	ldw	fp,0(sp)
   4aca0:	dec00104 	addi	sp,sp,4
   4aca4:	f800283a 	ret

0004aca8 <altera_avalon_fifo_write_almostempty>:

int altera_avalon_fifo_write_almostempty(alt_u32 address, alt_u32 data)
{
   4aca8:	defffd04 	addi	sp,sp,-12
   4acac:	df000215 	stw	fp,8(sp)
   4acb0:	df000204 	addi	fp,sp,8
   4acb4:	e13ffe15 	stw	r4,-8(fp)
   4acb8:	e17fff15 	stw	r5,-4(fp)
    IOWR_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address, data);
   4acbc:	e0bffe17 	ldw	r2,-8(fp)
   4acc0:	10800504 	addi	r2,r2,20
   4acc4:	1007883a 	mov	r3,r2
   4acc8:	e0bfff17 	ldw	r2,-4(fp)
   4accc:	18800035 	stwio	r2,0(r3)
    if(IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address) == data)
   4acd0:	e0bffe17 	ldw	r2,-8(fp)
   4acd4:	10800504 	addi	r2,r2,20
   4acd8:	10800037 	ldwio	r2,0(r2)
   4acdc:	1007883a 	mov	r3,r2
   4ace0:	e0bfff17 	ldw	r2,-4(fp)
   4ace4:	1880021e 	bne	r3,r2,4acf0 <altera_avalon_fifo_write_almostempty+0x48>
        return ALTERA_AVALON_FIFO_OK;
   4ace8:	0005883a 	mov	r2,zero
   4acec:	00000106 	br	4acf4 <altera_avalon_fifo_write_almostempty+0x4c>
    else
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
   4acf0:	00bfff44 	movi	r2,-3
}
   4acf4:	e037883a 	mov	sp,fp
   4acf8:	df000017 	ldw	fp,0(sp)
   4acfc:	dec00104 	addi	sp,sp,4
   4ad00:	f800283a 	ret

0004ad04 <altera_avalon_fifo_write_fifo>:

int altera_avalon_fifo_write_fifo(alt_u32 write_address,
                                  alt_u32 ctrl_address,
                                  alt_u32 data)
{
   4ad04:	defffb04 	addi	sp,sp,-20
   4ad08:	dfc00415 	stw	ra,16(sp)
   4ad0c:	df000315 	stw	fp,12(sp)
   4ad10:	df000304 	addi	fp,sp,12
   4ad14:	e13ffd15 	stw	r4,-12(fp)
   4ad18:	e17ffe15 	stw	r5,-8(fp)
   4ad1c:	e1bfff15 	stw	r6,-4(fp)
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
   4ad20:	01400044 	movi	r5,1
   4ad24:	e13ffe17 	ldw	r4,-8(fp)
   4ad28:	004aa5c0 	call	4aa5c <altera_avalon_fifo_read_status>
   4ad2c:	1000051e 	bne	r2,zero,4ad44 <altera_avalon_fifo_write_fifo+0x40>
    {
        IOWR_ALTERA_AVALON_FIFO_DATA(write_address, data);
   4ad30:	e0bffd17 	ldw	r2,-12(fp)
   4ad34:	e0ffff17 	ldw	r3,-4(fp)
   4ad38:	10c00035 	stwio	r3,0(r2)
        return ALTERA_AVALON_FIFO_OK;
   4ad3c:	0005883a 	mov	r2,zero
   4ad40:	00000106 	br	4ad48 <altera_avalon_fifo_write_fifo+0x44>
    }
    else
    {
        return ALTERA_AVALON_FIFO_FULL;
   4ad44:	00bfff04 	movi	r2,-4
    }
}
   4ad48:	e037883a 	mov	sp,fp
   4ad4c:	dfc00117 	ldw	ra,4(sp)
   4ad50:	df000017 	ldw	fp,0(sp)
   4ad54:	dec00204 	addi	sp,sp,8
   4ad58:	f800283a 	ret

0004ad5c <altera_avalon_read_fifo>:

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
   4ad5c:	defffa04 	addi	sp,sp,-24
   4ad60:	dfc00515 	stw	ra,20(sp)
   4ad64:	df000415 	stw	fp,16(sp)
   4ad68:	df000404 	addi	fp,sp,16
   4ad6c:	e13ffd15 	stw	r4,-12(fp)
   4ad70:	e17ffe15 	stw	r5,-8(fp)
   4ad74:	e1bfff15 	stw	r6,-4(fp)
    int return_val = 0;
   4ad78:	e03ffc15 	stw	zero,-16(fp)
    *data = 0;
   4ad7c:	e0bfff17 	ldw	r2,-4(fp)
   4ad80:	10000015 	stw	zero,0(r2)
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
   4ad84:	01400084 	movi	r5,2
   4ad88:	e13ffe17 	ldw	r4,-8(fp)
   4ad8c:	004aa5c0 	call	4aa5c <altera_avalon_fifo_read_status>
   4ad90:	1000071e 	bne	r2,zero,4adb0 <altera_avalon_read_fifo+0x54>
    {
        return_val = altera_avalon_fifo_read_level(ctrl_address);
   4ad94:	e13ffe17 	ldw	r4,-8(fp)
   4ad98:	004ab680 	call	4ab68 <altera_avalon_fifo_read_level>
   4ad9c:	e0bffc15 	stw	r2,-16(fp)
        *data = IORD_ALTERA_AVALON_FIFO_DATA(read_address);
   4ada0:	e0bffd17 	ldw	r2,-12(fp)
   4ada4:	10c00037 	ldwio	r3,0(r2)
   4ada8:	e0bfff17 	ldw	r2,-4(fp)
   4adac:	10c00015 	stw	r3,0(r2)
    
    }
    return return_val;
   4adb0:	e0bffc17 	ldw	r2,-16(fp)
}
   4adb4:	e037883a 	mov	sp,fp
   4adb8:	dfc00117 	ldw	ra,4(sp)
   4adbc:	df000017 	ldw	fp,0(sp)
   4adc0:	dec00204 	addi	sp,sp,8
   4adc4:	f800283a 	ret

0004adc8 <altera_avalon_fifo_read_fifo>:

int altera_avalon_fifo_read_fifo(alt_u32 read_address, alt_u32 ctrl_address)
{
   4adc8:	defffc04 	addi	sp,sp,-16
   4adcc:	dfc00315 	stw	ra,12(sp)
   4add0:	df000215 	stw	fp,8(sp)
   4add4:	df000204 	addi	fp,sp,8
   4add8:	e13ffe15 	stw	r4,-8(fp)
   4addc:	e17fff15 	stw	r5,-4(fp)
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
   4ade0:	01400084 	movi	r5,2
   4ade4:	e13fff17 	ldw	r4,-4(fp)
   4ade8:	004aa5c0 	call	4aa5c <altera_avalon_fifo_read_status>
   4adec:	1000031e 	bne	r2,zero,4adfc <altera_avalon_fifo_read_fifo+0x34>
    {
        return IORD_ALTERA_AVALON_FIFO_DATA(read_address);
   4adf0:	e0bffe17 	ldw	r2,-8(fp)
   4adf4:	10800037 	ldwio	r2,0(r2)
   4adf8:	00000106 	br	4ae00 <altera_avalon_fifo_read_fifo+0x38>
    }
    return 0;
   4adfc:	0005883a 	mov	r2,zero
}
   4ae00:	e037883a 	mov	sp,fp
   4ae04:	dfc00117 	ldw	ra,4(sp)
   4ae08:	df000017 	ldw	fp,0(sp)
   4ae0c:	dec00204 	addi	sp,sp,8
   4ae10:	f800283a 	ret

0004ae14 <altera_avalon_fifo_write_other_info>:

int altera_avalon_fifo_write_other_info(alt_u32 write_address,
					alt_u32 ctrl_address,
					alt_u32 data)
{
   4ae14:	defffb04 	addi	sp,sp,-20
   4ae18:	dfc00415 	stw	ra,16(sp)
   4ae1c:	df000315 	stw	fp,12(sp)
   4ae20:	df000304 	addi	fp,sp,12
   4ae24:	e13ffd15 	stw	r4,-12(fp)
   4ae28:	e17ffe15 	stw	r5,-8(fp)
   4ae2c:	e1bfff15 	stw	r6,-4(fp)
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
   4ae30:	01400044 	movi	r5,1
   4ae34:	e13ffe17 	ldw	r4,-8(fp)
   4ae38:	004aa5c0 	call	4aa5c <altera_avalon_fifo_read_status>
   4ae3c:	1000071e 	bne	r2,zero,4ae5c <altera_avalon_fifo_write_other_info+0x48>
    {
	IOWR_ALTERA_AVALON_FIFO_OTHER_INFO(write_address, data);
   4ae40:	e0bffd17 	ldw	r2,-12(fp)
   4ae44:	10800104 	addi	r2,r2,4
   4ae48:	1007883a 	mov	r3,r2
   4ae4c:	e0bfff17 	ldw	r2,-4(fp)
   4ae50:	18800035 	stwio	r2,0(r3)
	return ALTERA_AVALON_FIFO_OK;
   4ae54:	0005883a 	mov	r2,zero
   4ae58:	00000106 	br	4ae60 <altera_avalon_fifo_write_other_info+0x4c>
    }
    else
    {
	return ALTERA_AVALON_FIFO_FULL;
   4ae5c:	00bfff04 	movi	r2,-4
    }
}
   4ae60:	e037883a 	mov	sp,fp
   4ae64:	dfc00117 	ldw	ra,4(sp)
   4ae68:	df000017 	ldw	fp,0(sp)
   4ae6c:	dec00204 	addi	sp,sp,8
   4ae70:	f800283a 	ret

0004ae74 <altera_avalon_fifo_read_other_info>:

int altera_avalon_fifo_read_other_info(alt_u32 read_address)
{
   4ae74:	defffe04 	addi	sp,sp,-8
   4ae78:	df000115 	stw	fp,4(sp)
   4ae7c:	df000104 	addi	fp,sp,4
   4ae80:	e13fff15 	stw	r4,-4(fp)
    return IORD_ALTERA_AVALON_FIFO_OTHER_INFO(read_address);
   4ae84:	e0bfff17 	ldw	r2,-4(fp)
   4ae88:	10800104 	addi	r2,r2,4
   4ae8c:	10800037 	ldwio	r2,0(r2)
}
   4ae90:	e037883a 	mov	sp,fp
   4ae94:	df000017 	ldw	fp,0(sp)
   4ae98:	dec00104 	addi	sp,sp,4
   4ae9c:	f800283a 	ret

0004aea0 <altera_avalon_fifo_read_backpressure>:

int altera_avalon_fifo_read_backpressure (alt_u32 read_address){
   4aea0:	defffe04 	addi	sp,sp,-8
   4aea4:	df000115 	stw	fp,4(sp)
   4aea8:	df000104 	addi	fp,sp,4
   4aeac:	e13fff15 	stw	r4,-4(fp)
    // Read data from FIFO directly. If FIFO is empty and backpressure is supported, this call is backpressure.
    return IORD_ALTERA_AVALON_FIFO_DATA(read_address);  
   4aeb0:	e0bfff17 	ldw	r2,-4(fp)
   4aeb4:	10800037 	ldwio	r2,0(r2)
}
   4aeb8:	e037883a 	mov	sp,fp
   4aebc:	df000017 	ldw	fp,0(sp)
   4aec0:	dec00104 	addi	sp,sp,4
   4aec4:	f800283a 	ret

0004aec8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   4aec8:	defffa04 	addi	sp,sp,-24
   4aecc:	dfc00515 	stw	ra,20(sp)
   4aed0:	df000415 	stw	fp,16(sp)
   4aed4:	df000404 	addi	fp,sp,16
   4aed8:	e13ffd15 	stw	r4,-12(fp)
   4aedc:	e17ffe15 	stw	r5,-8(fp)
   4aee0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   4aee4:	e0bffd17 	ldw	r2,-12(fp)
   4aee8:	10800017 	ldw	r2,0(r2)
   4aeec:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   4aef0:	e0bffc17 	ldw	r2,-16(fp)
   4aef4:	10c00a04 	addi	r3,r2,40
   4aef8:	e0bffd17 	ldw	r2,-12(fp)
   4aefc:	10800217 	ldw	r2,8(r2)
   4af00:	100f883a 	mov	r7,r2
   4af04:	e1bfff17 	ldw	r6,-4(fp)
   4af08:	e17ffe17 	ldw	r5,-8(fp)
   4af0c:	1809883a 	mov	r4,r3
   4af10:	004b4f00 	call	4b4f0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   4af14:	e037883a 	mov	sp,fp
   4af18:	dfc00117 	ldw	ra,4(sp)
   4af1c:	df000017 	ldw	fp,0(sp)
   4af20:	dec00204 	addi	sp,sp,8
   4af24:	f800283a 	ret

0004af28 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   4af28:	defffa04 	addi	sp,sp,-24
   4af2c:	dfc00515 	stw	ra,20(sp)
   4af30:	df000415 	stw	fp,16(sp)
   4af34:	df000404 	addi	fp,sp,16
   4af38:	e13ffd15 	stw	r4,-12(fp)
   4af3c:	e17ffe15 	stw	r5,-8(fp)
   4af40:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   4af44:	e0bffd17 	ldw	r2,-12(fp)
   4af48:	10800017 	ldw	r2,0(r2)
   4af4c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   4af50:	e0bffc17 	ldw	r2,-16(fp)
   4af54:	10c00a04 	addi	r3,r2,40
   4af58:	e0bffd17 	ldw	r2,-12(fp)
   4af5c:	10800217 	ldw	r2,8(r2)
   4af60:	100f883a 	mov	r7,r2
   4af64:	e1bfff17 	ldw	r6,-4(fp)
   4af68:	e17ffe17 	ldw	r5,-8(fp)
   4af6c:	1809883a 	mov	r4,r3
   4af70:	004b70c0 	call	4b70c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   4af74:	e037883a 	mov	sp,fp
   4af78:	dfc00117 	ldw	ra,4(sp)
   4af7c:	df000017 	ldw	fp,0(sp)
   4af80:	dec00204 	addi	sp,sp,8
   4af84:	f800283a 	ret

0004af88 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   4af88:	defffc04 	addi	sp,sp,-16
   4af8c:	dfc00315 	stw	ra,12(sp)
   4af90:	df000215 	stw	fp,8(sp)
   4af94:	df000204 	addi	fp,sp,8
   4af98:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   4af9c:	e0bfff17 	ldw	r2,-4(fp)
   4afa0:	10800017 	ldw	r2,0(r2)
   4afa4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   4afa8:	e0bffe17 	ldw	r2,-8(fp)
   4afac:	10c00a04 	addi	r3,r2,40
   4afb0:	e0bfff17 	ldw	r2,-4(fp)
   4afb4:	10800217 	ldw	r2,8(r2)
   4afb8:	100b883a 	mov	r5,r2
   4afbc:	1809883a 	mov	r4,r3
   4afc0:	004b3980 	call	4b398 <altera_avalon_jtag_uart_close>
}
   4afc4:	e037883a 	mov	sp,fp
   4afc8:	dfc00117 	ldw	ra,4(sp)
   4afcc:	df000017 	ldw	fp,0(sp)
   4afd0:	dec00204 	addi	sp,sp,8
   4afd4:	f800283a 	ret

0004afd8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   4afd8:	defffa04 	addi	sp,sp,-24
   4afdc:	dfc00515 	stw	ra,20(sp)
   4afe0:	df000415 	stw	fp,16(sp)
   4afe4:	df000404 	addi	fp,sp,16
   4afe8:	e13ffd15 	stw	r4,-12(fp)
   4afec:	e17ffe15 	stw	r5,-8(fp)
   4aff0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   4aff4:	e0bffd17 	ldw	r2,-12(fp)
   4aff8:	10800017 	ldw	r2,0(r2)
   4affc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   4b000:	e0bffc17 	ldw	r2,-16(fp)
   4b004:	10800a04 	addi	r2,r2,40
   4b008:	e1bfff17 	ldw	r6,-4(fp)
   4b00c:	e17ffe17 	ldw	r5,-8(fp)
   4b010:	1009883a 	mov	r4,r2
   4b014:	004b4000 	call	4b400 <altera_avalon_jtag_uart_ioctl>
}
   4b018:	e037883a 	mov	sp,fp
   4b01c:	dfc00117 	ldw	ra,4(sp)
   4b020:	df000017 	ldw	fp,0(sp)
   4b024:	dec00204 	addi	sp,sp,8
   4b028:	f800283a 	ret

0004b02c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   4b02c:	defffa04 	addi	sp,sp,-24
   4b030:	dfc00515 	stw	ra,20(sp)
   4b034:	df000415 	stw	fp,16(sp)
   4b038:	df000404 	addi	fp,sp,16
   4b03c:	e13ffd15 	stw	r4,-12(fp)
   4b040:	e17ffe15 	stw	r5,-8(fp)
   4b044:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   4b048:	e0bffd17 	ldw	r2,-12(fp)
   4b04c:	00c00044 	movi	r3,1
   4b050:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   4b054:	e0bffd17 	ldw	r2,-12(fp)
   4b058:	10800017 	ldw	r2,0(r2)
   4b05c:	10800104 	addi	r2,r2,4
   4b060:	1007883a 	mov	r3,r2
   4b064:	e0bffd17 	ldw	r2,-12(fp)
   4b068:	10800817 	ldw	r2,32(r2)
   4b06c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   4b070:	e0bffe17 	ldw	r2,-8(fp)
   4b074:	e0ffff17 	ldw	r3,-4(fp)
   4b078:	d8000015 	stw	zero,0(sp)
   4b07c:	e1fffd17 	ldw	r7,-12(fp)
   4b080:	01800174 	movhi	r6,5
   4b084:	31ac3b04 	addi	r6,r6,-20244
   4b088:	180b883a 	mov	r5,r3
   4b08c:	1009883a 	mov	r4,r2
   4b090:	00499440 	call	49944 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   4b094:	e0bffd17 	ldw	r2,-12(fp)
   4b098:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   4b09c:	e0bffd17 	ldw	r2,-12(fp)
   4b0a0:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   4b0a4:	d0e01e17 	ldw	r3,-32648(gp)
   4b0a8:	e1fffd17 	ldw	r7,-12(fp)
   4b0ac:	01800174 	movhi	r6,5
   4b0b0:	31acbe04 	addi	r6,r6,-19720
   4b0b4:	180b883a 	mov	r5,r3
   4b0b8:	1009883a 	mov	r4,r2
   4b0bc:	004c0600 	call	4c060 <alt_alarm_start>
   4b0c0:	1000040e 	bge	r2,zero,4b0d4 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   4b0c4:	e0fffd17 	ldw	r3,-12(fp)
   4b0c8:	00a00034 	movhi	r2,32768
   4b0cc:	10bfffc4 	addi	r2,r2,-1
   4b0d0:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   4b0d4:	0001883a 	nop
   4b0d8:	e037883a 	mov	sp,fp
   4b0dc:	dfc00117 	ldw	ra,4(sp)
   4b0e0:	df000017 	ldw	fp,0(sp)
   4b0e4:	dec00204 	addi	sp,sp,8
   4b0e8:	f800283a 	ret

0004b0ec <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   4b0ec:	defff804 	addi	sp,sp,-32
   4b0f0:	df000715 	stw	fp,28(sp)
   4b0f4:	df000704 	addi	fp,sp,28
   4b0f8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   4b0fc:	e0bfff17 	ldw	r2,-4(fp)
   4b100:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   4b104:	e0bffb17 	ldw	r2,-20(fp)
   4b108:	10800017 	ldw	r2,0(r2)
   4b10c:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   4b110:	e0bffc17 	ldw	r2,-16(fp)
   4b114:	10800104 	addi	r2,r2,4
   4b118:	10800037 	ldwio	r2,0(r2)
   4b11c:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   4b120:	e0bffd17 	ldw	r2,-12(fp)
   4b124:	1080c00c 	andi	r2,r2,768
   4b128:	10006d26 	beq	r2,zero,4b2e0 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   4b12c:	e0bffd17 	ldw	r2,-12(fp)
   4b130:	1080400c 	andi	r2,r2,256
   4b134:	10003526 	beq	r2,zero,4b20c <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   4b138:	00800074 	movhi	r2,1
   4b13c:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   4b140:	e0bffb17 	ldw	r2,-20(fp)
   4b144:	10800a17 	ldw	r2,40(r2)
   4b148:	10800044 	addi	r2,r2,1
   4b14c:	1081ffcc 	andi	r2,r2,2047
   4b150:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   4b154:	e0bffb17 	ldw	r2,-20(fp)
   4b158:	10c00b17 	ldw	r3,44(r2)
   4b15c:	e0bffe17 	ldw	r2,-8(fp)
   4b160:	18801526 	beq	r3,r2,4b1b8 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   4b164:	e0bffc17 	ldw	r2,-16(fp)
   4b168:	10800037 	ldwio	r2,0(r2)
   4b16c:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   4b170:	e0bff917 	ldw	r2,-28(fp)
   4b174:	10a0000c 	andi	r2,r2,32768
   4b178:	10001126 	beq	r2,zero,4b1c0 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   4b17c:	e0bffb17 	ldw	r2,-20(fp)
   4b180:	10800a17 	ldw	r2,40(r2)
   4b184:	e0fff917 	ldw	r3,-28(fp)
   4b188:	1809883a 	mov	r4,r3
   4b18c:	e0fffb17 	ldw	r3,-20(fp)
   4b190:	1885883a 	add	r2,r3,r2
   4b194:	10800e04 	addi	r2,r2,56
   4b198:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   4b19c:	e0bffb17 	ldw	r2,-20(fp)
   4b1a0:	10800a17 	ldw	r2,40(r2)
   4b1a4:	10800044 	addi	r2,r2,1
   4b1a8:	10c1ffcc 	andi	r3,r2,2047
   4b1ac:	e0bffb17 	ldw	r2,-20(fp)
   4b1b0:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   4b1b4:	003fe206 	br	4b140 <__alt_mem_epcs_flash+0xfffca140>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   4b1b8:	0001883a 	nop
   4b1bc:	00000106 	br	4b1c4 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   4b1c0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   4b1c4:	e0bff917 	ldw	r2,-28(fp)
   4b1c8:	10bfffec 	andhi	r2,r2,65535
   4b1cc:	10000f26 	beq	r2,zero,4b20c <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   4b1d0:	e0bffb17 	ldw	r2,-20(fp)
   4b1d4:	10c00817 	ldw	r3,32(r2)
   4b1d8:	00bfff84 	movi	r2,-2
   4b1dc:	1886703a 	and	r3,r3,r2
   4b1e0:	e0bffb17 	ldw	r2,-20(fp)
   4b1e4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   4b1e8:	e0bffc17 	ldw	r2,-16(fp)
   4b1ec:	10800104 	addi	r2,r2,4
   4b1f0:	1007883a 	mov	r3,r2
   4b1f4:	e0bffb17 	ldw	r2,-20(fp)
   4b1f8:	10800817 	ldw	r2,32(r2)
   4b1fc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   4b200:	e0bffc17 	ldw	r2,-16(fp)
   4b204:	10800104 	addi	r2,r2,4
   4b208:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   4b20c:	e0bffd17 	ldw	r2,-12(fp)
   4b210:	1080800c 	andi	r2,r2,512
   4b214:	103fbe26 	beq	r2,zero,4b110 <__alt_mem_epcs_flash+0xfffca110>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   4b218:	e0bffd17 	ldw	r2,-12(fp)
   4b21c:	1004d43a 	srli	r2,r2,16
   4b220:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   4b224:	00001406 	br	4b278 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   4b228:	e0bffc17 	ldw	r2,-16(fp)
   4b22c:	e0fffb17 	ldw	r3,-20(fp)
   4b230:	18c00d17 	ldw	r3,52(r3)
   4b234:	e13ffb17 	ldw	r4,-20(fp)
   4b238:	20c7883a 	add	r3,r4,r3
   4b23c:	18c20e04 	addi	r3,r3,2104
   4b240:	18c00003 	ldbu	r3,0(r3)
   4b244:	18c03fcc 	andi	r3,r3,255
   4b248:	18c0201c 	xori	r3,r3,128
   4b24c:	18ffe004 	addi	r3,r3,-128
   4b250:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   4b254:	e0bffb17 	ldw	r2,-20(fp)
   4b258:	10800d17 	ldw	r2,52(r2)
   4b25c:	10800044 	addi	r2,r2,1
   4b260:	10c1ffcc 	andi	r3,r2,2047
   4b264:	e0bffb17 	ldw	r2,-20(fp)
   4b268:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   4b26c:	e0bffa17 	ldw	r2,-24(fp)
   4b270:	10bfffc4 	addi	r2,r2,-1
   4b274:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   4b278:	e0bffa17 	ldw	r2,-24(fp)
   4b27c:	10000526 	beq	r2,zero,4b294 <altera_avalon_jtag_uart_irq+0x1a8>
   4b280:	e0bffb17 	ldw	r2,-20(fp)
   4b284:	10c00d17 	ldw	r3,52(r2)
   4b288:	e0bffb17 	ldw	r2,-20(fp)
   4b28c:	10800c17 	ldw	r2,48(r2)
   4b290:	18bfe51e 	bne	r3,r2,4b228 <__alt_mem_epcs_flash+0xfffca228>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   4b294:	e0bffa17 	ldw	r2,-24(fp)
   4b298:	103f9d26 	beq	r2,zero,4b110 <__alt_mem_epcs_flash+0xfffca110>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   4b29c:	e0bffb17 	ldw	r2,-20(fp)
   4b2a0:	10c00817 	ldw	r3,32(r2)
   4b2a4:	00bfff44 	movi	r2,-3
   4b2a8:	1886703a 	and	r3,r3,r2
   4b2ac:	e0bffb17 	ldw	r2,-20(fp)
   4b2b0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   4b2b4:	e0bffb17 	ldw	r2,-20(fp)
   4b2b8:	10800017 	ldw	r2,0(r2)
   4b2bc:	10800104 	addi	r2,r2,4
   4b2c0:	1007883a 	mov	r3,r2
   4b2c4:	e0bffb17 	ldw	r2,-20(fp)
   4b2c8:	10800817 	ldw	r2,32(r2)
   4b2cc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   4b2d0:	e0bffc17 	ldw	r2,-16(fp)
   4b2d4:	10800104 	addi	r2,r2,4
   4b2d8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   4b2dc:	003f8c06 	br	4b110 <__alt_mem_epcs_flash+0xfffca110>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   4b2e0:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   4b2e4:	0001883a 	nop
   4b2e8:	e037883a 	mov	sp,fp
   4b2ec:	df000017 	ldw	fp,0(sp)
   4b2f0:	dec00104 	addi	sp,sp,4
   4b2f4:	f800283a 	ret

0004b2f8 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   4b2f8:	defff804 	addi	sp,sp,-32
   4b2fc:	df000715 	stw	fp,28(sp)
   4b300:	df000704 	addi	fp,sp,28
   4b304:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   4b308:	e0bffb17 	ldw	r2,-20(fp)
   4b30c:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   4b310:	e0bff917 	ldw	r2,-28(fp)
   4b314:	10800017 	ldw	r2,0(r2)
   4b318:	10800104 	addi	r2,r2,4
   4b31c:	10800037 	ldwio	r2,0(r2)
   4b320:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   4b324:	e0bffa17 	ldw	r2,-24(fp)
   4b328:	1081000c 	andi	r2,r2,1024
   4b32c:	10000b26 	beq	r2,zero,4b35c <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   4b330:	e0bff917 	ldw	r2,-28(fp)
   4b334:	10800017 	ldw	r2,0(r2)
   4b338:	10800104 	addi	r2,r2,4
   4b33c:	1007883a 	mov	r3,r2
   4b340:	e0bff917 	ldw	r2,-28(fp)
   4b344:	10800817 	ldw	r2,32(r2)
   4b348:	10810014 	ori	r2,r2,1024
   4b34c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
   4b350:	e0bff917 	ldw	r2,-28(fp)
   4b354:	10000915 	stw	zero,36(r2)
   4b358:	00000a06 	br	4b384 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   4b35c:	e0bff917 	ldw	r2,-28(fp)
   4b360:	10c00917 	ldw	r3,36(r2)
   4b364:	00a00034 	movhi	r2,32768
   4b368:	10bfff04 	addi	r2,r2,-4
   4b36c:	10c00536 	bltu	r2,r3,4b384 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
   4b370:	e0bff917 	ldw	r2,-28(fp)
   4b374:	10800917 	ldw	r2,36(r2)
   4b378:	10c00044 	addi	r3,r2,1
   4b37c:	e0bff917 	ldw	r2,-28(fp)
   4b380:	10c00915 	stw	r3,36(r2)
   4b384:	d0a01e17 	ldw	r2,-32648(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   4b388:	e037883a 	mov	sp,fp
   4b38c:	df000017 	ldw	fp,0(sp)
   4b390:	dec00104 	addi	sp,sp,4
   4b394:	f800283a 	ret

0004b398 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   4b398:	defffd04 	addi	sp,sp,-12
   4b39c:	df000215 	stw	fp,8(sp)
   4b3a0:	df000204 	addi	fp,sp,8
   4b3a4:	e13ffe15 	stw	r4,-8(fp)
   4b3a8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   4b3ac:	00000506 	br	4b3c4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   4b3b0:	e0bfff17 	ldw	r2,-4(fp)
   4b3b4:	1090000c 	andi	r2,r2,16384
   4b3b8:	10000226 	beq	r2,zero,4b3c4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   4b3bc:	00bffd44 	movi	r2,-11
   4b3c0:	00000b06 	br	4b3f0 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   4b3c4:	e0bffe17 	ldw	r2,-8(fp)
   4b3c8:	10c00d17 	ldw	r3,52(r2)
   4b3cc:	e0bffe17 	ldw	r2,-8(fp)
   4b3d0:	10800c17 	ldw	r2,48(r2)
   4b3d4:	18800526 	beq	r3,r2,4b3ec <altera_avalon_jtag_uart_close+0x54>
   4b3d8:	e0bffe17 	ldw	r2,-8(fp)
   4b3dc:	10c00917 	ldw	r3,36(r2)
   4b3e0:	e0bffe17 	ldw	r2,-8(fp)
   4b3e4:	10800117 	ldw	r2,4(r2)
   4b3e8:	18bff136 	bltu	r3,r2,4b3b0 <__alt_mem_epcs_flash+0xfffca3b0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   4b3ec:	0005883a 	mov	r2,zero
}
   4b3f0:	e037883a 	mov	sp,fp
   4b3f4:	df000017 	ldw	fp,0(sp)
   4b3f8:	dec00104 	addi	sp,sp,4
   4b3fc:	f800283a 	ret

0004b400 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   4b400:	defffa04 	addi	sp,sp,-24
   4b404:	df000515 	stw	fp,20(sp)
   4b408:	df000504 	addi	fp,sp,20
   4b40c:	e13ffd15 	stw	r4,-12(fp)
   4b410:	e17ffe15 	stw	r5,-8(fp)
   4b414:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   4b418:	00bff9c4 	movi	r2,-25
   4b41c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   4b420:	e0bffe17 	ldw	r2,-8(fp)
   4b424:	10da8060 	cmpeqi	r3,r2,27137
   4b428:	1800031e 	bne	r3,zero,4b438 <altera_avalon_jtag_uart_ioctl+0x38>
   4b42c:	109a80a0 	cmpeqi	r2,r2,27138
   4b430:	1000181e 	bne	r2,zero,4b494 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
   4b434:	00002906 	br	4b4dc <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   4b438:	e0bffd17 	ldw	r2,-12(fp)
   4b43c:	10c00117 	ldw	r3,4(r2)
   4b440:	00a00034 	movhi	r2,32768
   4b444:	10bfffc4 	addi	r2,r2,-1
   4b448:	18802126 	beq	r3,r2,4b4d0 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
   4b44c:	e0bfff17 	ldw	r2,-4(fp)
   4b450:	10800017 	ldw	r2,0(r2)
   4b454:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   4b458:	e0bffc17 	ldw	r2,-16(fp)
   4b45c:	10800090 	cmplti	r2,r2,2
   4b460:	1000061e 	bne	r2,zero,4b47c <altera_avalon_jtag_uart_ioctl+0x7c>
   4b464:	e0fffc17 	ldw	r3,-16(fp)
   4b468:	00a00034 	movhi	r2,32768
   4b46c:	10bfffc4 	addi	r2,r2,-1
   4b470:	18800226 	beq	r3,r2,4b47c <altera_avalon_jtag_uart_ioctl+0x7c>
   4b474:	e0bffc17 	ldw	r2,-16(fp)
   4b478:	00000206 	br	4b484 <altera_avalon_jtag_uart_ioctl+0x84>
   4b47c:	00a00034 	movhi	r2,32768
   4b480:	10bfff84 	addi	r2,r2,-2
   4b484:	e0fffd17 	ldw	r3,-12(fp)
   4b488:	18800115 	stw	r2,4(r3)
      rc = 0;
   4b48c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   4b490:	00000f06 	br	4b4d0 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   4b494:	e0bffd17 	ldw	r2,-12(fp)
   4b498:	10c00117 	ldw	r3,4(r2)
   4b49c:	00a00034 	movhi	r2,32768
   4b4a0:	10bfffc4 	addi	r2,r2,-1
   4b4a4:	18800c26 	beq	r3,r2,4b4d8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   4b4a8:	e0bffd17 	ldw	r2,-12(fp)
   4b4ac:	10c00917 	ldw	r3,36(r2)
   4b4b0:	e0bffd17 	ldw	r2,-12(fp)
   4b4b4:	10800117 	ldw	r2,4(r2)
   4b4b8:	1885803a 	cmpltu	r2,r3,r2
   4b4bc:	10c03fcc 	andi	r3,r2,255
   4b4c0:	e0bfff17 	ldw	r2,-4(fp)
   4b4c4:	10c00015 	stw	r3,0(r2)
      rc = 0;
   4b4c8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   4b4cc:	00000206 	br	4b4d8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   4b4d0:	0001883a 	nop
   4b4d4:	00000106 	br	4b4dc <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   4b4d8:	0001883a 	nop

  default:
    break;
  }

  return rc;
   4b4dc:	e0bffb17 	ldw	r2,-20(fp)
}
   4b4e0:	e037883a 	mov	sp,fp
   4b4e4:	df000017 	ldw	fp,0(sp)
   4b4e8:	dec00104 	addi	sp,sp,4
   4b4ec:	f800283a 	ret

0004b4f0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   4b4f0:	defff304 	addi	sp,sp,-52
   4b4f4:	dfc00c15 	stw	ra,48(sp)
   4b4f8:	df000b15 	stw	fp,44(sp)
   4b4fc:	df000b04 	addi	fp,sp,44
   4b500:	e13ffc15 	stw	r4,-16(fp)
   4b504:	e17ffd15 	stw	r5,-12(fp)
   4b508:	e1bffe15 	stw	r6,-8(fp)
   4b50c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   4b510:	e0bffd17 	ldw	r2,-12(fp)
   4b514:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   4b518:	00004706 	br	4b638 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   4b51c:	e0bffc17 	ldw	r2,-16(fp)
   4b520:	10800a17 	ldw	r2,40(r2)
   4b524:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
   4b528:	e0bffc17 	ldw	r2,-16(fp)
   4b52c:	10800b17 	ldw	r2,44(r2)
   4b530:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
   4b534:	e0fff717 	ldw	r3,-36(fp)
   4b538:	e0bff817 	ldw	r2,-32(fp)
   4b53c:	18800536 	bltu	r3,r2,4b554 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   4b540:	e0fff717 	ldw	r3,-36(fp)
   4b544:	e0bff817 	ldw	r2,-32(fp)
   4b548:	1885c83a 	sub	r2,r3,r2
   4b54c:	e0bff615 	stw	r2,-40(fp)
   4b550:	00000406 	br	4b564 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   4b554:	00c20004 	movi	r3,2048
   4b558:	e0bff817 	ldw	r2,-32(fp)
   4b55c:	1885c83a 	sub	r2,r3,r2
   4b560:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
   4b564:	e0bff617 	ldw	r2,-40(fp)
   4b568:	10001e26 	beq	r2,zero,4b5e4 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   4b56c:	e0fffe17 	ldw	r3,-8(fp)
   4b570:	e0bff617 	ldw	r2,-40(fp)
   4b574:	1880022e 	bgeu	r3,r2,4b580 <altera_avalon_jtag_uart_read+0x90>
        n = space;
   4b578:	e0bffe17 	ldw	r2,-8(fp)
   4b57c:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   4b580:	e0bffc17 	ldw	r2,-16(fp)
   4b584:	10c00e04 	addi	r3,r2,56
   4b588:	e0bff817 	ldw	r2,-32(fp)
   4b58c:	1885883a 	add	r2,r3,r2
   4b590:	e1bff617 	ldw	r6,-40(fp)
   4b594:	100b883a 	mov	r5,r2
   4b598:	e13ff517 	ldw	r4,-44(fp)
   4b59c:	00493d40 	call	493d4 <memcpy>
      ptr   += n;
   4b5a0:	e0fff517 	ldw	r3,-44(fp)
   4b5a4:	e0bff617 	ldw	r2,-40(fp)
   4b5a8:	1885883a 	add	r2,r3,r2
   4b5ac:	e0bff515 	stw	r2,-44(fp)
      space -= n;
   4b5b0:	e0fffe17 	ldw	r3,-8(fp)
   4b5b4:	e0bff617 	ldw	r2,-40(fp)
   4b5b8:	1885c83a 	sub	r2,r3,r2
   4b5bc:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   4b5c0:	e0fff817 	ldw	r3,-32(fp)
   4b5c4:	e0bff617 	ldw	r2,-40(fp)
   4b5c8:	1885883a 	add	r2,r3,r2
   4b5cc:	10c1ffcc 	andi	r3,r2,2047
   4b5d0:	e0bffc17 	ldw	r2,-16(fp)
   4b5d4:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   4b5d8:	e0bffe17 	ldw	r2,-8(fp)
   4b5dc:	00bfcf16 	blt	zero,r2,4b51c <__alt_mem_epcs_flash+0xfffca51c>
   4b5e0:	00000106 	br	4b5e8 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   4b5e4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   4b5e8:	e0fff517 	ldw	r3,-44(fp)
   4b5ec:	e0bffd17 	ldw	r2,-12(fp)
   4b5f0:	1880141e 	bne	r3,r2,4b644 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   4b5f4:	e0bfff17 	ldw	r2,-4(fp)
   4b5f8:	1090000c 	andi	r2,r2,16384
   4b5fc:	1000131e 	bne	r2,zero,4b64c <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   4b600:	0001883a 	nop
   4b604:	e0bffc17 	ldw	r2,-16(fp)
   4b608:	10c00a17 	ldw	r3,40(r2)
   4b60c:	e0bff717 	ldw	r2,-36(fp)
   4b610:	1880051e 	bne	r3,r2,4b628 <altera_avalon_jtag_uart_read+0x138>
   4b614:	e0bffc17 	ldw	r2,-16(fp)
   4b618:	10c00917 	ldw	r3,36(r2)
   4b61c:	e0bffc17 	ldw	r2,-16(fp)
   4b620:	10800117 	ldw	r2,4(r2)
   4b624:	18bff736 	bltu	r3,r2,4b604 <__alt_mem_epcs_flash+0xfffca604>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   4b628:	e0bffc17 	ldw	r2,-16(fp)
   4b62c:	10c00a17 	ldw	r3,40(r2)
   4b630:	e0bff717 	ldw	r2,-36(fp)
   4b634:	18800726 	beq	r3,r2,4b654 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   4b638:	e0bffe17 	ldw	r2,-8(fp)
   4b63c:	00bfb716 	blt	zero,r2,4b51c <__alt_mem_epcs_flash+0xfffca51c>
   4b640:	00000506 	br	4b658 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   4b644:	0001883a 	nop
   4b648:	00000306 	br	4b658 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   4b64c:	0001883a 	nop
   4b650:	00000106 	br	4b658 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   4b654:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   4b658:	e0fff517 	ldw	r3,-44(fp)
   4b65c:	e0bffd17 	ldw	r2,-12(fp)
   4b660:	18801826 	beq	r3,r2,4b6c4 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   4b664:	0005303a 	rdctl	r2,status
   4b668:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   4b66c:	e0fffb17 	ldw	r3,-20(fp)
   4b670:	00bfff84 	movi	r2,-2
   4b674:	1884703a 	and	r2,r3,r2
   4b678:	1001703a 	wrctl	status,r2
  
  return context;
   4b67c:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   4b680:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   4b684:	e0bffc17 	ldw	r2,-16(fp)
   4b688:	10800817 	ldw	r2,32(r2)
   4b68c:	10c00054 	ori	r3,r2,1
   4b690:	e0bffc17 	ldw	r2,-16(fp)
   4b694:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   4b698:	e0bffc17 	ldw	r2,-16(fp)
   4b69c:	10800017 	ldw	r2,0(r2)
   4b6a0:	10800104 	addi	r2,r2,4
   4b6a4:	1007883a 	mov	r3,r2
   4b6a8:	e0bffc17 	ldw	r2,-16(fp)
   4b6ac:	10800817 	ldw	r2,32(r2)
   4b6b0:	18800035 	stwio	r2,0(r3)
   4b6b4:	e0bffa17 	ldw	r2,-24(fp)
   4b6b8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   4b6bc:	e0bff917 	ldw	r2,-28(fp)
   4b6c0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   4b6c4:	e0fff517 	ldw	r3,-44(fp)
   4b6c8:	e0bffd17 	ldw	r2,-12(fp)
   4b6cc:	18800426 	beq	r3,r2,4b6e0 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
   4b6d0:	e0fff517 	ldw	r3,-44(fp)
   4b6d4:	e0bffd17 	ldw	r2,-12(fp)
   4b6d8:	1885c83a 	sub	r2,r3,r2
   4b6dc:	00000606 	br	4b6f8 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
   4b6e0:	e0bfff17 	ldw	r2,-4(fp)
   4b6e4:	1090000c 	andi	r2,r2,16384
   4b6e8:	10000226 	beq	r2,zero,4b6f4 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
   4b6ec:	00bffd44 	movi	r2,-11
   4b6f0:	00000106 	br	4b6f8 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
   4b6f4:	00bffec4 	movi	r2,-5
}
   4b6f8:	e037883a 	mov	sp,fp
   4b6fc:	dfc00117 	ldw	ra,4(sp)
   4b700:	df000017 	ldw	fp,0(sp)
   4b704:	dec00204 	addi	sp,sp,8
   4b708:	f800283a 	ret

0004b70c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   4b70c:	defff304 	addi	sp,sp,-52
   4b710:	dfc00c15 	stw	ra,48(sp)
   4b714:	df000b15 	stw	fp,44(sp)
   4b718:	df000b04 	addi	fp,sp,44
   4b71c:	e13ffc15 	stw	r4,-16(fp)
   4b720:	e17ffd15 	stw	r5,-12(fp)
   4b724:	e1bffe15 	stw	r6,-8(fp)
   4b728:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   4b72c:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   4b730:	e0bffd17 	ldw	r2,-12(fp)
   4b734:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   4b738:	00003706 	br	4b818 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   4b73c:	e0bffc17 	ldw	r2,-16(fp)
   4b740:	10800c17 	ldw	r2,48(r2)
   4b744:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
   4b748:	e0bffc17 	ldw	r2,-16(fp)
   4b74c:	10800d17 	ldw	r2,52(r2)
   4b750:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
   4b754:	e0fff917 	ldw	r3,-28(fp)
   4b758:	e0bff517 	ldw	r2,-44(fp)
   4b75c:	1880062e 	bgeu	r3,r2,4b778 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   4b760:	e0fff517 	ldw	r3,-44(fp)
   4b764:	e0bff917 	ldw	r2,-28(fp)
   4b768:	1885c83a 	sub	r2,r3,r2
   4b76c:	10bfffc4 	addi	r2,r2,-1
   4b770:	e0bff615 	stw	r2,-40(fp)
   4b774:	00000b06 	br	4b7a4 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   4b778:	e0bff517 	ldw	r2,-44(fp)
   4b77c:	10000526 	beq	r2,zero,4b794 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   4b780:	00c20004 	movi	r3,2048
   4b784:	e0bff917 	ldw	r2,-28(fp)
   4b788:	1885c83a 	sub	r2,r3,r2
   4b78c:	e0bff615 	stw	r2,-40(fp)
   4b790:	00000406 	br	4b7a4 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   4b794:	00c1ffc4 	movi	r3,2047
   4b798:	e0bff917 	ldw	r2,-28(fp)
   4b79c:	1885c83a 	sub	r2,r3,r2
   4b7a0:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
   4b7a4:	e0bff617 	ldw	r2,-40(fp)
   4b7a8:	10001e26 	beq	r2,zero,4b824 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   4b7ac:	e0fffe17 	ldw	r3,-8(fp)
   4b7b0:	e0bff617 	ldw	r2,-40(fp)
   4b7b4:	1880022e 	bgeu	r3,r2,4b7c0 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   4b7b8:	e0bffe17 	ldw	r2,-8(fp)
   4b7bc:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   4b7c0:	e0bffc17 	ldw	r2,-16(fp)
   4b7c4:	10c20e04 	addi	r3,r2,2104
   4b7c8:	e0bff917 	ldw	r2,-28(fp)
   4b7cc:	1885883a 	add	r2,r3,r2
   4b7d0:	e1bff617 	ldw	r6,-40(fp)
   4b7d4:	e17ffd17 	ldw	r5,-12(fp)
   4b7d8:	1009883a 	mov	r4,r2
   4b7dc:	00493d40 	call	493d4 <memcpy>
      ptr   += n;
   4b7e0:	e0fffd17 	ldw	r3,-12(fp)
   4b7e4:	e0bff617 	ldw	r2,-40(fp)
   4b7e8:	1885883a 	add	r2,r3,r2
   4b7ec:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   4b7f0:	e0fffe17 	ldw	r3,-8(fp)
   4b7f4:	e0bff617 	ldw	r2,-40(fp)
   4b7f8:	1885c83a 	sub	r2,r3,r2
   4b7fc:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   4b800:	e0fff917 	ldw	r3,-28(fp)
   4b804:	e0bff617 	ldw	r2,-40(fp)
   4b808:	1885883a 	add	r2,r3,r2
   4b80c:	10c1ffcc 	andi	r3,r2,2047
   4b810:	e0bffc17 	ldw	r2,-16(fp)
   4b814:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   4b818:	e0bffe17 	ldw	r2,-8(fp)
   4b81c:	00bfc716 	blt	zero,r2,4b73c <__alt_mem_epcs_flash+0xfffca73c>
   4b820:	00000106 	br	4b828 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   4b824:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   4b828:	0005303a 	rdctl	r2,status
   4b82c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   4b830:	e0fffb17 	ldw	r3,-20(fp)
   4b834:	00bfff84 	movi	r2,-2
   4b838:	1884703a 	and	r2,r3,r2
   4b83c:	1001703a 	wrctl	status,r2
  
  return context;
   4b840:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   4b844:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   4b848:	e0bffc17 	ldw	r2,-16(fp)
   4b84c:	10800817 	ldw	r2,32(r2)
   4b850:	10c00094 	ori	r3,r2,2
   4b854:	e0bffc17 	ldw	r2,-16(fp)
   4b858:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   4b85c:	e0bffc17 	ldw	r2,-16(fp)
   4b860:	10800017 	ldw	r2,0(r2)
   4b864:	10800104 	addi	r2,r2,4
   4b868:	1007883a 	mov	r3,r2
   4b86c:	e0bffc17 	ldw	r2,-16(fp)
   4b870:	10800817 	ldw	r2,32(r2)
   4b874:	18800035 	stwio	r2,0(r3)
   4b878:	e0bffa17 	ldw	r2,-24(fp)
   4b87c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   4b880:	e0bff817 	ldw	r2,-32(fp)
   4b884:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   4b888:	e0bffe17 	ldw	r2,-8(fp)
   4b88c:	0080100e 	bge	zero,r2,4b8d0 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
   4b890:	e0bfff17 	ldw	r2,-4(fp)
   4b894:	1090000c 	andi	r2,r2,16384
   4b898:	1000101e 	bne	r2,zero,4b8dc <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   4b89c:	0001883a 	nop
   4b8a0:	e0bffc17 	ldw	r2,-16(fp)
   4b8a4:	10c00d17 	ldw	r3,52(r2)
   4b8a8:	e0bff517 	ldw	r2,-44(fp)
   4b8ac:	1880051e 	bne	r3,r2,4b8c4 <altera_avalon_jtag_uart_write+0x1b8>
   4b8b0:	e0bffc17 	ldw	r2,-16(fp)
   4b8b4:	10c00917 	ldw	r3,36(r2)
   4b8b8:	e0bffc17 	ldw	r2,-16(fp)
   4b8bc:	10800117 	ldw	r2,4(r2)
   4b8c0:	18bff736 	bltu	r3,r2,4b8a0 <__alt_mem_epcs_flash+0xfffca8a0>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
   4b8c4:	e0bffc17 	ldw	r2,-16(fp)
   4b8c8:	10800917 	ldw	r2,36(r2)
   4b8cc:	1000051e 	bne	r2,zero,4b8e4 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
   4b8d0:	e0bffe17 	ldw	r2,-8(fp)
   4b8d4:	00bfd016 	blt	zero,r2,4b818 <__alt_mem_epcs_flash+0xfffca818>
   4b8d8:	00000306 	br	4b8e8 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   4b8dc:	0001883a 	nop
   4b8e0:	00000106 	br	4b8e8 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
   4b8e4:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   4b8e8:	e0fffd17 	ldw	r3,-12(fp)
   4b8ec:	e0bff717 	ldw	r2,-36(fp)
   4b8f0:	18800426 	beq	r3,r2,4b904 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
   4b8f4:	e0fffd17 	ldw	r3,-12(fp)
   4b8f8:	e0bff717 	ldw	r2,-36(fp)
   4b8fc:	1885c83a 	sub	r2,r3,r2
   4b900:	00000606 	br	4b91c <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
   4b904:	e0bfff17 	ldw	r2,-4(fp)
   4b908:	1090000c 	andi	r2,r2,16384
   4b90c:	10000226 	beq	r2,zero,4b918 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
   4b910:	00bffd44 	movi	r2,-11
   4b914:	00000106 	br	4b91c <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   4b918:	00bffec4 	movi	r2,-5
}
   4b91c:	e037883a 	mov	sp,fp
   4b920:	dfc00117 	ldw	ra,4(sp)
   4b924:	df000017 	ldw	fp,0(sp)
   4b928:	dec00204 	addi	sp,sp,8
   4b92c:	f800283a 	ret

0004b930 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   4b930:	defffa04 	addi	sp,sp,-24
   4b934:	dfc00515 	stw	ra,20(sp)
   4b938:	df000415 	stw	fp,16(sp)
   4b93c:	df000404 	addi	fp,sp,16
   4b940:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   4b944:	0007883a 	mov	r3,zero
   4b948:	e0bfff17 	ldw	r2,-4(fp)
   4b94c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   4b950:	e0bfff17 	ldw	r2,-4(fp)
   4b954:	10800104 	addi	r2,r2,4
   4b958:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   4b95c:	0005303a 	rdctl	r2,status
   4b960:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   4b964:	e0fffd17 	ldw	r3,-12(fp)
   4b968:	00bfff84 	movi	r2,-2
   4b96c:	1884703a 	and	r2,r3,r2
   4b970:	1001703a 	wrctl	status,r2
  
  return context;
   4b974:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   4b978:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
   4b97c:	004ca780 	call	4ca78 <alt_tick>
   4b980:	e0bffc17 	ldw	r2,-16(fp)
   4b984:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   4b988:	e0bffe17 	ldw	r2,-8(fp)
   4b98c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   4b990:	0001883a 	nop
   4b994:	e037883a 	mov	sp,fp
   4b998:	dfc00117 	ldw	ra,4(sp)
   4b99c:	df000017 	ldw	fp,0(sp)
   4b9a0:	dec00204 	addi	sp,sp,8
   4b9a4:	f800283a 	ret

0004b9a8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   4b9a8:	defff804 	addi	sp,sp,-32
   4b9ac:	dfc00715 	stw	ra,28(sp)
   4b9b0:	df000615 	stw	fp,24(sp)
   4b9b4:	df000604 	addi	fp,sp,24
   4b9b8:	e13ffc15 	stw	r4,-16(fp)
   4b9bc:	e17ffd15 	stw	r5,-12(fp)
   4b9c0:	e1bffe15 	stw	r6,-8(fp)
   4b9c4:	e1ffff15 	stw	r7,-4(fp)
   4b9c8:	e0bfff17 	ldw	r2,-4(fp)
   4b9cc:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   4b9d0:	d0a01e17 	ldw	r2,-32648(gp)
   4b9d4:	1000021e 	bne	r2,zero,4b9e0 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
   4b9d8:	e0bffb17 	ldw	r2,-20(fp)
   4b9dc:	d0a01e15 	stw	r2,-32648(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   4b9e0:	e0bffc17 	ldw	r2,-16(fp)
   4b9e4:	10800104 	addi	r2,r2,4
   4b9e8:	00c001c4 	movi	r3,7
   4b9ec:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   4b9f0:	d8000015 	stw	zero,0(sp)
   4b9f4:	e1fffc17 	ldw	r7,-16(fp)
   4b9f8:	01800174 	movhi	r6,5
   4b9fc:	31ae4c04 	addi	r6,r6,-18128
   4ba00:	e17ffe17 	ldw	r5,-8(fp)
   4ba04:	e13ffd17 	ldw	r4,-12(fp)
   4ba08:	00499440 	call	49944 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   4ba0c:	0001883a 	nop
   4ba10:	e037883a 	mov	sp,fp
   4ba14:	dfc00117 	ldw	ra,4(sp)
   4ba18:	df000017 	ldw	fp,0(sp)
   4ba1c:	dec00204 	addi	sp,sp,8
   4ba20:	f800283a 	ret

0004ba24 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
   4ba24:	defff904 	addi	sp,sp,-28
   4ba28:	dfc00615 	stw	ra,24(sp)
   4ba2c:	df000515 	stw	fp,20(sp)
   4ba30:	df000504 	addi	fp,sp,20
   4ba34:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
   4ba38:	00800144 	movi	r2,5
   4ba3c:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
   4ba40:	d8000215 	stw	zero,8(sp)
   4ba44:	e0bffe44 	addi	r2,fp,-7
   4ba48:	d8800115 	stw	r2,4(sp)
   4ba4c:	00800044 	movi	r2,1
   4ba50:	d8800015 	stw	r2,0(sp)
   4ba54:	e1fffe04 	addi	r7,fp,-8
   4ba58:	01800044 	movi	r6,1
   4ba5c:	000b883a 	mov	r5,zero
   4ba60:	e13fff17 	ldw	r4,-4(fp)
   4ba64:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
   4ba68:	e0bffe43 	ldbu	r2,-7(fp)
}
   4ba6c:	e037883a 	mov	sp,fp
   4ba70:	dfc00117 	ldw	ra,4(sp)
   4ba74:	df000017 	ldw	fp,0(sp)
   4ba78:	dec00204 	addi	sp,sp,8
   4ba7c:	f800283a 	ret

0004ba80 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
   4ba80:	defffd04 	addi	sp,sp,-12
   4ba84:	dfc00215 	stw	ra,8(sp)
   4ba88:	df000115 	stw	fp,4(sp)
   4ba8c:	df000104 	addi	fp,sp,4
   4ba90:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
   4ba94:	e13fff17 	ldw	r4,-4(fp)
   4ba98:	004ba240 	call	4ba24 <epcs_read_status_register>
   4ba9c:	10803fcc 	andi	r2,r2,255
   4baa0:	1080004c 	andi	r2,r2,1
}
   4baa4:	e037883a 	mov	sp,fp
   4baa8:	dfc00117 	ldw	ra,4(sp)
   4baac:	df000017 	ldw	fp,0(sp)
   4bab0:	dec00204 	addi	sp,sp,8
   4bab4:	f800283a 	ret

0004bab8 <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
   4bab8:	defffd04 	addi	sp,sp,-12
   4babc:	dfc00215 	stw	ra,8(sp)
   4bac0:	df000115 	stw	fp,4(sp)
   4bac4:	df000104 	addi	fp,sp,4
   4bac8:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
   4bacc:	0001883a 	nop
   4bad0:	e13fff17 	ldw	r4,-4(fp)
   4bad4:	004ba800 	call	4ba80 <epcs_test_wip>
   4bad8:	103ffd1e 	bne	r2,zero,4bad0 <__alt_mem_epcs_flash+0xfffcaad0>
  {
  }
}
   4badc:	0001883a 	nop
   4bae0:	e037883a 	mov	sp,fp
   4bae4:	dfc00117 	ldw	ra,4(sp)
   4bae8:	df000017 	ldw	fp,0(sp)
   4baec:	dec00204 	addi	sp,sp,8
   4baf0:	f800283a 	ret

0004baf4 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
   4baf4:	defff604 	addi	sp,sp,-40
   4baf8:	dfc00915 	stw	ra,36(sp)
   4bafc:	df000815 	stw	fp,32(sp)
   4bb00:	df000804 	addi	fp,sp,32
   4bb04:	e13ffd15 	stw	r4,-12(fp)
   4bb08:	e17ffe15 	stw	r5,-8(fp)
   4bb0c:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
   4bb10:	e0bfff17 	ldw	r2,-4(fp)
   4bb14:	10001226 	beq	r2,zero,4bb60 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
   4bb18:	00bff604 	movi	r2,-40
   4bb1c:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
   4bb20:	e0bffe17 	ldw	r2,-8(fp)
   4bb24:	1004d63a 	srli	r2,r2,24
   4bb28:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
   4bb2c:	e0bffe17 	ldw	r2,-8(fp)
   4bb30:	1004d43a 	srli	r2,r2,16
   4bb34:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
   4bb38:	e0bffe17 	ldw	r2,-8(fp)
   4bb3c:	1004d23a 	srli	r2,r2,8
   4bb40:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
   4bb44:	e0bffe17 	ldw	r2,-8(fp)
   4bb48:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
   4bb4c:	00800144 	movi	r2,5
   4bb50:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
   4bb54:	e13ffd17 	ldw	r4,-12(fp)
   4bb58:	004bfa80 	call	4bfa8 <epcs_enter_4_bytes_mode>
   4bb5c:	00000c06 	br	4bb90 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
   4bb60:	00bff604 	movi	r2,-40
   4bb64:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
   4bb68:	e0bffe17 	ldw	r2,-8(fp)
   4bb6c:	1004d43a 	srli	r2,r2,16
   4bb70:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
   4bb74:	e0bffe17 	ldw	r2,-8(fp)
   4bb78:	1004d23a 	srli	r2,r2,8
   4bb7c:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
   4bb80:	e0bffe17 	ldw	r2,-8(fp)
   4bb84:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
   4bb88:	00800104 	movi	r2,4
   4bb8c:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
   4bb90:	e13ffd17 	ldw	r4,-12(fp)
   4bb94:	004bce40 	call	4bce4 <epcs_write_enable>

  alt_avalon_spi_command(
   4bb98:	e0bffb03 	ldbu	r2,-20(fp)
   4bb9c:	e0fffb44 	addi	r3,fp,-19
   4bba0:	d8000215 	stw	zero,8(sp)
   4bba4:	d8000115 	stw	zero,4(sp)
   4bba8:	d8000015 	stw	zero,0(sp)
   4bbac:	180f883a 	mov	r7,r3
   4bbb0:	100d883a 	mov	r6,r2
   4bbb4:	000b883a 	mov	r5,zero
   4bbb8:	e13ffd17 	ldw	r4,-12(fp)
   4bbbc:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
   4bbc0:	e13ffd17 	ldw	r4,-12(fp)
   4bbc4:	004bab80 	call	4bab8 <epcs_await_wip_released>

  if(four_bytes_mode)
   4bbc8:	e0bfff17 	ldw	r2,-4(fp)
   4bbcc:	10000226 	beq	r2,zero,4bbd8 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
   4bbd0:	e13ffd17 	ldw	r4,-12(fp)
   4bbd4:	004c0040 	call	4c004 <epcs_exit_4_bytes_mode>
  }
}
   4bbd8:	0001883a 	nop
   4bbdc:	e037883a 	mov	sp,fp
   4bbe0:	dfc00117 	ldw	ra,4(sp)
   4bbe4:	df000017 	ldw	fp,0(sp)
   4bbe8:	dec00204 	addi	sp,sp,8
   4bbec:	f800283a 	ret

0004bbf0 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
   4bbf0:	defff404 	addi	sp,sp,-48
   4bbf4:	dfc00b15 	stw	ra,44(sp)
   4bbf8:	df000a15 	stw	fp,40(sp)
   4bbfc:	df000a04 	addi	fp,sp,40
   4bc00:	e13ffc15 	stw	r4,-16(fp)
   4bc04:	e17ffd15 	stw	r5,-12(fp)
   4bc08:	e1bffe15 	stw	r6,-8(fp)
   4bc0c:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
   4bc10:	008000c4 	movi	r2,3
   4bc14:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
   4bc18:	e0800217 	ldw	r2,8(fp)
   4bc1c:	10001026 	beq	r2,zero,4bc60 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
   4bc20:	e0bffd17 	ldw	r2,-12(fp)
   4bc24:	1004d63a 	srli	r2,r2,24
   4bc28:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
   4bc2c:	e0bffd17 	ldw	r2,-12(fp)
   4bc30:	1005d43a 	srai	r2,r2,16
   4bc34:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
   4bc38:	e0bffd17 	ldw	r2,-12(fp)
   4bc3c:	1005d23a 	srai	r2,r2,8
   4bc40:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
   4bc44:	e0bffd17 	ldw	r2,-12(fp)
   4bc48:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
   4bc4c:	00800144 	movi	r2,5
   4bc50:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
   4bc54:	e13ffc17 	ldw	r4,-16(fp)
   4bc58:	004bfa80 	call	4bfa8 <epcs_enter_4_bytes_mode>
   4bc5c:	00000a06 	br	4bc88 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
   4bc60:	e0bffd17 	ldw	r2,-12(fp)
   4bc64:	1005d43a 	srai	r2,r2,16
   4bc68:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
   4bc6c:	e0bffd17 	ldw	r2,-12(fp)
   4bc70:	1005d23a 	srai	r2,r2,8
   4bc74:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
   4bc78:	e0bffd17 	ldw	r2,-12(fp)
   4bc7c:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
   4bc80:	00800104 	movi	r2,4
   4bc84:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
   4bc88:	e13ffc17 	ldw	r4,-16(fp)
   4bc8c:	004bab80 	call	4bab8 <epcs_await_wip_released>

  alt_avalon_spi_command(
   4bc90:	e0bfff17 	ldw	r2,-4(fp)
   4bc94:	e13ffa04 	addi	r4,fp,-24
   4bc98:	d8000215 	stw	zero,8(sp)
   4bc9c:	e0fffe17 	ldw	r3,-8(fp)
   4bca0:	d8c00115 	stw	r3,4(sp)
   4bca4:	d8800015 	stw	r2,0(sp)
   4bca8:	200f883a 	mov	r7,r4
   4bcac:	e1bff917 	ldw	r6,-28(fp)
   4bcb0:	000b883a 	mov	r5,zero
   4bcb4:	e13ffc17 	ldw	r4,-16(fp)
   4bcb8:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
   4bcbc:	e0800217 	ldw	r2,8(fp)
   4bcc0:	10000226 	beq	r2,zero,4bccc <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
   4bcc4:	e13ffc17 	ldw	r4,-16(fp)
   4bcc8:	004c0040 	call	4c004 <epcs_exit_4_bytes_mode>
  }

  return length;
   4bccc:	e0bfff17 	ldw	r2,-4(fp)
}
   4bcd0:	e037883a 	mov	sp,fp
   4bcd4:	dfc00117 	ldw	ra,4(sp)
   4bcd8:	df000017 	ldw	fp,0(sp)
   4bcdc:	dec00204 	addi	sp,sp,8
   4bce0:	f800283a 	ret

0004bce4 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
   4bce4:	defff904 	addi	sp,sp,-28
   4bce8:	dfc00615 	stw	ra,24(sp)
   4bcec:	df000515 	stw	fp,20(sp)
   4bcf0:	df000504 	addi	fp,sp,20
   4bcf4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
   4bcf8:	00800184 	movi	r2,6
   4bcfc:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
   4bd00:	d8000215 	stw	zero,8(sp)
   4bd04:	d8000115 	stw	zero,4(sp)
   4bd08:	d8000015 	stw	zero,0(sp)
   4bd0c:	e1fffe04 	addi	r7,fp,-8
   4bd10:	01800044 	movi	r6,1
   4bd14:	000b883a 	mov	r5,zero
   4bd18:	e13fff17 	ldw	r4,-4(fp)
   4bd1c:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
   4bd20:	0001883a 	nop
   4bd24:	e037883a 	mov	sp,fp
   4bd28:	dfc00117 	ldw	ra,4(sp)
   4bd2c:	df000017 	ldw	fp,0(sp)
   4bd30:	dec00204 	addi	sp,sp,8
   4bd34:	f800283a 	ret

0004bd38 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
   4bd38:	defff804 	addi	sp,sp,-32
   4bd3c:	dfc00715 	stw	ra,28(sp)
   4bd40:	df000615 	stw	fp,24(sp)
   4bd44:	df000604 	addi	fp,sp,24
   4bd48:	e13ffe15 	stw	r4,-8(fp)
   4bd4c:	2805883a 	mov	r2,r5
   4bd50:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
   4bd54:	00800044 	movi	r2,1
   4bd58:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
   4bd5c:	e0bfff03 	ldbu	r2,-4(fp)
   4bd60:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
   4bd64:	d8000215 	stw	zero,8(sp)
   4bd68:	d8000115 	stw	zero,4(sp)
   4bd6c:	d8000015 	stw	zero,0(sp)
   4bd70:	e1fffd04 	addi	r7,fp,-12
   4bd74:	01800084 	movi	r6,2
   4bd78:	000b883a 	mov	r5,zero
   4bd7c:	e13ffe17 	ldw	r4,-8(fp)
   4bd80:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
   4bd84:	e13ffe17 	ldw	r4,-8(fp)
   4bd88:	004bab80 	call	4bab8 <epcs_await_wip_released>
}
   4bd8c:	0001883a 	nop
   4bd90:	e037883a 	mov	sp,fp
   4bd94:	dfc00117 	ldw	ra,4(sp)
   4bd98:	df000017 	ldw	fp,0(sp)
   4bd9c:	dec00204 	addi	sp,sp,8
   4bda0:	f800283a 	ret

0004bda4 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
   4bda4:	defff404 	addi	sp,sp,-48
   4bda8:	dfc00b15 	stw	ra,44(sp)
   4bdac:	df000a15 	stw	fp,40(sp)
   4bdb0:	df000a04 	addi	fp,sp,40
   4bdb4:	e13ffc15 	stw	r4,-16(fp)
   4bdb8:	e17ffd15 	stw	r5,-12(fp)
   4bdbc:	e1bffe15 	stw	r6,-8(fp)
   4bdc0:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
   4bdc4:	00800084 	movi	r2,2
   4bdc8:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
   4bdcc:	e0800217 	ldw	r2,8(fp)
   4bdd0:	10001026 	beq	r2,zero,4be14 <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
   4bdd4:	e0bffd17 	ldw	r2,-12(fp)
   4bdd8:	1004d63a 	srli	r2,r2,24
   4bddc:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
   4bde0:	e0bffd17 	ldw	r2,-12(fp)
   4bde4:	1005d43a 	srai	r2,r2,16
   4bde8:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
   4bdec:	e0bffd17 	ldw	r2,-12(fp)
   4bdf0:	1005d23a 	srai	r2,r2,8
   4bdf4:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
   4bdf8:	e0bffd17 	ldw	r2,-12(fp)
   4bdfc:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
   4be00:	00800144 	movi	r2,5
   4be04:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
   4be08:	e13ffc17 	ldw	r4,-16(fp)
   4be0c:	004bfa80 	call	4bfa8 <epcs_enter_4_bytes_mode>
   4be10:	00000a06 	br	4be3c <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
   4be14:	e0bffd17 	ldw	r2,-12(fp)
   4be18:	1005d43a 	srai	r2,r2,16
   4be1c:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
   4be20:	e0bffd17 	ldw	r2,-12(fp)
   4be24:	1005d23a 	srai	r2,r2,8
   4be28:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
   4be2c:	e0bffd17 	ldw	r2,-12(fp)
   4be30:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
   4be34:	00800104 	movi	r2,4
   4be38:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
   4be3c:	e13ffc17 	ldw	r4,-16(fp)
   4be40:	004bce40 	call	4bce4 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
   4be44:	e0fffa04 	addi	r3,fp,-24
   4be48:	00800044 	movi	r2,1
   4be4c:	d8800215 	stw	r2,8(sp)
   4be50:	d8000115 	stw	zero,4(sp)
   4be54:	d8000015 	stw	zero,0(sp)
   4be58:	180f883a 	mov	r7,r3
   4be5c:	e1bff917 	ldw	r6,-28(fp)
   4be60:	000b883a 	mov	r5,zero
   4be64:	e13ffc17 	ldw	r4,-16(fp)
   4be68:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
   4be6c:	e0bfff17 	ldw	r2,-4(fp)
   4be70:	d8000215 	stw	zero,8(sp)
   4be74:	d8000115 	stw	zero,4(sp)
   4be78:	d8000015 	stw	zero,0(sp)
   4be7c:	e1fffe17 	ldw	r7,-8(fp)
   4be80:	100d883a 	mov	r6,r2
   4be84:	000b883a 	mov	r5,zero
   4be88:	e13ffc17 	ldw	r4,-16(fp)
   4be8c:	004cba40 	call	4cba4 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
   4be90:	e13ffc17 	ldw	r4,-16(fp)
   4be94:	004bab80 	call	4bab8 <epcs_await_wip_released>

  if(four_bytes_mode)
   4be98:	e0800217 	ldw	r2,8(fp)
   4be9c:	10000226 	beq	r2,zero,4bea8 <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
   4bea0:	e13ffc17 	ldw	r4,-16(fp)
   4bea4:	004c0040 	call	4c004 <epcs_exit_4_bytes_mode>
  }

  return length;
   4bea8:	e0bfff17 	ldw	r2,-4(fp)
}
   4beac:	e037883a 	mov	sp,fp
   4beb0:	dfc00117 	ldw	ra,4(sp)
   4beb4:	df000017 	ldw	fp,0(sp)
   4beb8:	dec00204 	addi	sp,sp,8
   4bebc:	f800283a 	ret

0004bec0 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
   4bec0:	defff804 	addi	sp,sp,-32
   4bec4:	dfc00715 	stw	ra,28(sp)
   4bec8:	df000615 	stw	fp,24(sp)
   4becc:	df000604 	addi	fp,sp,24
   4bed0:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
   4bed4:	00bfeac4 	movi	r2,-85
   4bed8:	e0bffd05 	stb	r2,-12(fp)
   4bedc:	e03ffd45 	stb	zero,-11(fp)
   4bee0:	e03ffd85 	stb	zero,-10(fp)
   4bee4:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
   4bee8:	d8000215 	stw	zero,8(sp)
   4beec:	e0bffe04 	addi	r2,fp,-8
   4bef0:	d8800115 	stw	r2,4(sp)
   4bef4:	00800044 	movi	r2,1
   4bef8:	d8800015 	stw	r2,0(sp)
   4befc:	e1fffd04 	addi	r7,fp,-12
   4bf00:	01800104 	movi	r6,4
   4bf04:	000b883a 	mov	r5,zero
   4bf08:	e13fff17 	ldw	r4,-4(fp)
   4bf0c:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
   4bf10:	e0bffe03 	ldbu	r2,-8(fp)
}
   4bf14:	e037883a 	mov	sp,fp
   4bf18:	dfc00117 	ldw	ra,4(sp)
   4bf1c:	df000017 	ldw	fp,0(sp)
   4bf20:	dec00204 	addi	sp,sp,8
   4bf24:	f800283a 	ret

0004bf28 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
   4bf28:	defff904 	addi	sp,sp,-28
   4bf2c:	dfc00615 	stw	ra,24(sp)
   4bf30:	df000515 	stw	fp,20(sp)
   4bf34:	df000504 	addi	fp,sp,20
   4bf38:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
   4bf3c:	00bfe7c4 	movi	r2,-97
   4bf40:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
   4bf44:	d8000215 	stw	zero,8(sp)
   4bf48:	e0bffe44 	addi	r2,fp,-7
   4bf4c:	d8800115 	stw	r2,4(sp)
   4bf50:	008000c4 	movi	r2,3
   4bf54:	d8800015 	stw	r2,0(sp)
   4bf58:	e1fffe04 	addi	r7,fp,-8
   4bf5c:	01800044 	movi	r6,1
   4bf60:	000b883a 	mov	r5,zero
   4bf64:	e13fff17 	ldw	r4,-4(fp)
   4bf68:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
   4bf6c:	e0bffe43 	ldbu	r2,-7(fp)
   4bf70:	10803fcc 	andi	r2,r2,255
   4bf74:	1006943a 	slli	r3,r2,16
   4bf78:	e0bffe83 	ldbu	r2,-6(fp)
   4bf7c:	10803fcc 	andi	r2,r2,255
   4bf80:	1004923a 	slli	r2,r2,8
   4bf84:	1886b03a 	or	r3,r3,r2
   4bf88:	e0bffec3 	ldbu	r2,-5(fp)
   4bf8c:	10803fcc 	andi	r2,r2,255
   4bf90:	1884b03a 	or	r2,r3,r2
}
   4bf94:	e037883a 	mov	sp,fp
   4bf98:	dfc00117 	ldw	ra,4(sp)
   4bf9c:	df000017 	ldw	fp,0(sp)
   4bfa0:	dec00204 	addi	sp,sp,8
   4bfa4:	f800283a 	ret

0004bfa8 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
   4bfa8:	defff904 	addi	sp,sp,-28
   4bfac:	dfc00615 	stw	ra,24(sp)
   4bfb0:	df000515 	stw	fp,20(sp)
   4bfb4:	df000504 	addi	fp,sp,20
   4bfb8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
   4bfbc:	00bfedc4 	movi	r2,-73
   4bfc0:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
   4bfc4:	e13fff17 	ldw	r4,-4(fp)
   4bfc8:	004bce40 	call	4bce4 <epcs_write_enable>

  alt_avalon_spi_command(
   4bfcc:	d8000215 	stw	zero,8(sp)
   4bfd0:	d8000115 	stw	zero,4(sp)
   4bfd4:	d8000015 	stw	zero,0(sp)
   4bfd8:	e1fffe04 	addi	r7,fp,-8
   4bfdc:	01800044 	movi	r6,1
   4bfe0:	000b883a 	mov	r5,zero
   4bfe4:	e13fff17 	ldw	r4,-4(fp)
   4bfe8:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
   4bfec:	0001883a 	nop
}
   4bff0:	e037883a 	mov	sp,fp
   4bff4:	dfc00117 	ldw	ra,4(sp)
   4bff8:	df000017 	ldw	fp,0(sp)
   4bffc:	dec00204 	addi	sp,sp,8
   4c000:	f800283a 	ret

0004c004 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
   4c004:	defff904 	addi	sp,sp,-28
   4c008:	dfc00615 	stw	ra,24(sp)
   4c00c:	df000515 	stw	fp,20(sp)
   4c010:	df000504 	addi	fp,sp,20
   4c014:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
   4c018:	00bffa44 	movi	r2,-23
   4c01c:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
   4c020:	e13fff17 	ldw	r4,-4(fp)
   4c024:	004bce40 	call	4bce4 <epcs_write_enable>

  alt_avalon_spi_command(
   4c028:	d8000215 	stw	zero,8(sp)
   4c02c:	d8000115 	stw	zero,4(sp)
   4c030:	d8000015 	stw	zero,0(sp)
   4c034:	e1fffe04 	addi	r7,fp,-8
   4c038:	01800044 	movi	r6,1
   4c03c:	000b883a 	mov	r5,zero
   4c040:	e13fff17 	ldw	r4,-4(fp)
   4c044:	004cba40 	call	4cba4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
   4c048:	0001883a 	nop
}
   4c04c:	e037883a 	mov	sp,fp
   4c050:	dfc00117 	ldw	ra,4(sp)
   4c054:	df000017 	ldw	fp,0(sp)
   4c058:	dec00204 	addi	sp,sp,8
   4c05c:	f800283a 	ret

0004c060 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   4c060:	defff504 	addi	sp,sp,-44
   4c064:	df000a15 	stw	fp,40(sp)
   4c068:	df000a04 	addi	fp,sp,40
   4c06c:	e13ffc15 	stw	r4,-16(fp)
   4c070:	e17ffd15 	stw	r5,-12(fp)
   4c074:	e1bffe15 	stw	r6,-8(fp)
   4c078:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   4c07c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   4c080:	d0a01e17 	ldw	r2,-32648(gp)
  
  if (alt_ticks_per_second ())
   4c084:	10003c26 	beq	r2,zero,4c178 <alt_alarm_start+0x118>
  {
    if (alarm)
   4c088:	e0bffc17 	ldw	r2,-16(fp)
   4c08c:	10003826 	beq	r2,zero,4c170 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
   4c090:	e0bffc17 	ldw	r2,-16(fp)
   4c094:	e0fffe17 	ldw	r3,-8(fp)
   4c098:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   4c09c:	e0bffc17 	ldw	r2,-16(fp)
   4c0a0:	e0ffff17 	ldw	r3,-4(fp)
   4c0a4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   4c0a8:	0005303a 	rdctl	r2,status
   4c0ac:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   4c0b0:	e0fff917 	ldw	r3,-28(fp)
   4c0b4:	00bfff84 	movi	r2,-2
   4c0b8:	1884703a 	and	r2,r3,r2
   4c0bc:	1001703a 	wrctl	status,r2
  
  return context;
   4c0c0:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
   4c0c4:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   4c0c8:	d0a01f17 	ldw	r2,-32644(gp)
      
      current_nticks = alt_nticks();
   4c0cc:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   4c0d0:	e0fffd17 	ldw	r3,-12(fp)
   4c0d4:	e0bff617 	ldw	r2,-40(fp)
   4c0d8:	1885883a 	add	r2,r3,r2
   4c0dc:	10c00044 	addi	r3,r2,1
   4c0e0:	e0bffc17 	ldw	r2,-16(fp)
   4c0e4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   4c0e8:	e0bffc17 	ldw	r2,-16(fp)
   4c0ec:	10c00217 	ldw	r3,8(r2)
   4c0f0:	e0bff617 	ldw	r2,-40(fp)
   4c0f4:	1880042e 	bgeu	r3,r2,4c108 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
   4c0f8:	e0bffc17 	ldw	r2,-16(fp)
   4c0fc:	00c00044 	movi	r3,1
   4c100:	10c00405 	stb	r3,16(r2)
   4c104:	00000206 	br	4c110 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
   4c108:	e0bffc17 	ldw	r2,-16(fp)
   4c10c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   4c110:	e0bffc17 	ldw	r2,-16(fp)
   4c114:	d0e00f04 	addi	r3,gp,-32708
   4c118:	e0fffa15 	stw	r3,-24(fp)
   4c11c:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   4c120:	e0bffb17 	ldw	r2,-20(fp)
   4c124:	e0fffa17 	ldw	r3,-24(fp)
   4c128:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   4c12c:	e0bffa17 	ldw	r2,-24(fp)
   4c130:	10c00017 	ldw	r3,0(r2)
   4c134:	e0bffb17 	ldw	r2,-20(fp)
   4c138:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   4c13c:	e0bffa17 	ldw	r2,-24(fp)
   4c140:	10800017 	ldw	r2,0(r2)
   4c144:	e0fffb17 	ldw	r3,-20(fp)
   4c148:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   4c14c:	e0bffa17 	ldw	r2,-24(fp)
   4c150:	e0fffb17 	ldw	r3,-20(fp)
   4c154:	10c00015 	stw	r3,0(r2)
   4c158:	e0bff817 	ldw	r2,-32(fp)
   4c15c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   4c160:	e0bff717 	ldw	r2,-36(fp)
   4c164:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   4c168:	0005883a 	mov	r2,zero
   4c16c:	00000306 	br	4c17c <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
   4c170:	00bffa84 	movi	r2,-22
   4c174:	00000106 	br	4c17c <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
   4c178:	00bfde84 	movi	r2,-134
  }
}
   4c17c:	e037883a 	mov	sp,fp
   4c180:	df000017 	ldw	fp,0(sp)
   4c184:	dec00104 	addi	sp,sp,4
   4c188:	f800283a 	ret

0004c18c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   4c18c:	defffe04 	addi	sp,sp,-8
   4c190:	dfc00115 	stw	ra,4(sp)
   4c194:	df000015 	stw	fp,0(sp)
   4c198:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   4c19c:	d0a00e17 	ldw	r2,-32712(gp)
   4c1a0:	10000326 	beq	r2,zero,4c1b0 <alt_get_errno+0x24>
   4c1a4:	d0a00e17 	ldw	r2,-32712(gp)
   4c1a8:	103ee83a 	callr	r2
   4c1ac:	00000106 	br	4c1b4 <alt_get_errno+0x28>
   4c1b0:	d0a02004 	addi	r2,gp,-32640
}
   4c1b4:	e037883a 	mov	sp,fp
   4c1b8:	dfc00117 	ldw	ra,4(sp)
   4c1bc:	df000017 	ldw	fp,0(sp)
   4c1c0:	dec00204 	addi	sp,sp,8
   4c1c4:	f800283a 	ret

0004c1c8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   4c1c8:	defffb04 	addi	sp,sp,-20
   4c1cc:	dfc00415 	stw	ra,16(sp)
   4c1d0:	df000315 	stw	fp,12(sp)
   4c1d4:	df000304 	addi	fp,sp,12
   4c1d8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   4c1dc:	e0bfff17 	ldw	r2,-4(fp)
   4c1e0:	10000616 	blt	r2,zero,4c1fc <close+0x34>
   4c1e4:	e0bfff17 	ldw	r2,-4(fp)
   4c1e8:	10c00324 	muli	r3,r2,12
   4c1ec:	008001b4 	movhi	r2,6
   4c1f0:	10b2d704 	addi	r2,r2,-13476
   4c1f4:	1885883a 	add	r2,r3,r2
   4c1f8:	00000106 	br	4c200 <close+0x38>
   4c1fc:	0005883a 	mov	r2,zero
   4c200:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   4c204:	e0bffd17 	ldw	r2,-12(fp)
   4c208:	10001926 	beq	r2,zero,4c270 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   4c20c:	e0bffd17 	ldw	r2,-12(fp)
   4c210:	10800017 	ldw	r2,0(r2)
   4c214:	10800417 	ldw	r2,16(r2)
   4c218:	10000626 	beq	r2,zero,4c234 <close+0x6c>
   4c21c:	e0bffd17 	ldw	r2,-12(fp)
   4c220:	10800017 	ldw	r2,0(r2)
   4c224:	10800417 	ldw	r2,16(r2)
   4c228:	e13ffd17 	ldw	r4,-12(fp)
   4c22c:	103ee83a 	callr	r2
   4c230:	00000106 	br	4c238 <close+0x70>
   4c234:	0005883a 	mov	r2,zero
   4c238:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   4c23c:	e13fff17 	ldw	r4,-4(fp)
   4c240:	004c9780 	call	4c978 <alt_release_fd>
    if (rval < 0)
   4c244:	e0bffe17 	ldw	r2,-8(fp)
   4c248:	1000070e 	bge	r2,zero,4c268 <close+0xa0>
    {
      ALT_ERRNO = -rval;
   4c24c:	004c18c0 	call	4c18c <alt_get_errno>
   4c250:	1007883a 	mov	r3,r2
   4c254:	e0bffe17 	ldw	r2,-8(fp)
   4c258:	0085c83a 	sub	r2,zero,r2
   4c25c:	18800015 	stw	r2,0(r3)
      return -1;
   4c260:	00bfffc4 	movi	r2,-1
   4c264:	00000706 	br	4c284 <close+0xbc>
    }
    return 0;
   4c268:	0005883a 	mov	r2,zero
   4c26c:	00000506 	br	4c284 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   4c270:	004c18c0 	call	4c18c <alt_get_errno>
   4c274:	1007883a 	mov	r3,r2
   4c278:	00801444 	movi	r2,81
   4c27c:	18800015 	stw	r2,0(r3)
    return -1;
   4c280:	00bfffc4 	movi	r2,-1
  }
}
   4c284:	e037883a 	mov	sp,fp
   4c288:	dfc00117 	ldw	ra,4(sp)
   4c28c:	df000017 	ldw	fp,0(sp)
   4c290:	dec00204 	addi	sp,sp,8
   4c294:	f800283a 	ret

0004c298 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   4c298:	deffff04 	addi	sp,sp,-4
   4c29c:	df000015 	stw	fp,0(sp)
   4c2a0:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   4c2a4:	0001883a 	nop
   4c2a8:	e037883a 	mov	sp,fp
   4c2ac:	df000017 	ldw	fp,0(sp)
   4c2b0:	dec00104 	addi	sp,sp,4
   4c2b4:	f800283a 	ret

0004c2b8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   4c2b8:	defffc04 	addi	sp,sp,-16
   4c2bc:	df000315 	stw	fp,12(sp)
   4c2c0:	df000304 	addi	fp,sp,12
   4c2c4:	e13ffd15 	stw	r4,-12(fp)
   4c2c8:	e17ffe15 	stw	r5,-8(fp)
   4c2cc:	e1bfff15 	stw	r6,-4(fp)
  return len;
   4c2d0:	e0bfff17 	ldw	r2,-4(fp)
}
   4c2d4:	e037883a 	mov	sp,fp
   4c2d8:	df000017 	ldw	fp,0(sp)
   4c2dc:	dec00104 	addi	sp,sp,4
   4c2e0:	f800283a 	ret

0004c2e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   4c2e4:	defffe04 	addi	sp,sp,-8
   4c2e8:	dfc00115 	stw	ra,4(sp)
   4c2ec:	df000015 	stw	fp,0(sp)
   4c2f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   4c2f4:	d0a00e17 	ldw	r2,-32712(gp)
   4c2f8:	10000326 	beq	r2,zero,4c308 <alt_get_errno+0x24>
   4c2fc:	d0a00e17 	ldw	r2,-32712(gp)
   4c300:	103ee83a 	callr	r2
   4c304:	00000106 	br	4c30c <alt_get_errno+0x28>
   4c308:	d0a02004 	addi	r2,gp,-32640
}
   4c30c:	e037883a 	mov	sp,fp
   4c310:	dfc00117 	ldw	ra,4(sp)
   4c314:	df000017 	ldw	fp,0(sp)
   4c318:	dec00204 	addi	sp,sp,8
   4c31c:	f800283a 	ret

0004c320 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   4c320:	defffa04 	addi	sp,sp,-24
   4c324:	dfc00515 	stw	ra,20(sp)
   4c328:	df000415 	stw	fp,16(sp)
   4c32c:	df000404 	addi	fp,sp,16
   4c330:	e13ffe15 	stw	r4,-8(fp)
   4c334:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   4c338:	e0bffe17 	ldw	r2,-8(fp)
   4c33c:	10000326 	beq	r2,zero,4c34c <alt_dev_llist_insert+0x2c>
   4c340:	e0bffe17 	ldw	r2,-8(fp)
   4c344:	10800217 	ldw	r2,8(r2)
   4c348:	1000061e 	bne	r2,zero,4c364 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
   4c34c:	004c2e40 	call	4c2e4 <alt_get_errno>
   4c350:	1007883a 	mov	r3,r2
   4c354:	00800584 	movi	r2,22
   4c358:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   4c35c:	00bffa84 	movi	r2,-22
   4c360:	00001306 	br	4c3b0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   4c364:	e0bffe17 	ldw	r2,-8(fp)
   4c368:	e0ffff17 	ldw	r3,-4(fp)
   4c36c:	e0fffc15 	stw	r3,-16(fp)
   4c370:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   4c374:	e0bffd17 	ldw	r2,-12(fp)
   4c378:	e0fffc17 	ldw	r3,-16(fp)
   4c37c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   4c380:	e0bffc17 	ldw	r2,-16(fp)
   4c384:	10c00017 	ldw	r3,0(r2)
   4c388:	e0bffd17 	ldw	r2,-12(fp)
   4c38c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   4c390:	e0bffc17 	ldw	r2,-16(fp)
   4c394:	10800017 	ldw	r2,0(r2)
   4c398:	e0fffd17 	ldw	r3,-12(fp)
   4c39c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   4c3a0:	e0bffc17 	ldw	r2,-16(fp)
   4c3a4:	e0fffd17 	ldw	r3,-12(fp)
   4c3a8:	10c00015 	stw	r3,0(r2)

  return 0;  
   4c3ac:	0005883a 	mov	r2,zero
}
   4c3b0:	e037883a 	mov	sp,fp
   4c3b4:	dfc00117 	ldw	ra,4(sp)
   4c3b8:	df000017 	ldw	fp,0(sp)
   4c3bc:	dec00204 	addi	sp,sp,8
   4c3c0:	f800283a 	ret

0004c3c4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
   4c3c4:	defffd04 	addi	sp,sp,-12
   4c3c8:	dfc00215 	stw	ra,8(sp)
   4c3cc:	df000115 	stw	fp,4(sp)
   4c3d0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   4c3d4:	00800174 	movhi	r2,5
   4c3d8:	10b4db04 	addi	r2,r2,-11412
   4c3dc:	e0bfff15 	stw	r2,-4(fp)
   4c3e0:	00000606 	br	4c3fc <_do_ctors+0x38>
        (*ctor) (); 
   4c3e4:	e0bfff17 	ldw	r2,-4(fp)
   4c3e8:	10800017 	ldw	r2,0(r2)
   4c3ec:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   4c3f0:	e0bfff17 	ldw	r2,-4(fp)
   4c3f4:	10bfff04 	addi	r2,r2,-4
   4c3f8:	e0bfff15 	stw	r2,-4(fp)
   4c3fc:	e0ffff17 	ldw	r3,-4(fp)
   4c400:	00800174 	movhi	r2,5
   4c404:	10b4dc04 	addi	r2,r2,-11408
   4c408:	18bff62e 	bgeu	r3,r2,4c3e4 <__alt_mem_epcs_flash+0xfffcb3e4>
        (*ctor) (); 
}
   4c40c:	0001883a 	nop
   4c410:	e037883a 	mov	sp,fp
   4c414:	dfc00117 	ldw	ra,4(sp)
   4c418:	df000017 	ldw	fp,0(sp)
   4c41c:	dec00204 	addi	sp,sp,8
   4c420:	f800283a 	ret

0004c424 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
   4c424:	defffd04 	addi	sp,sp,-12
   4c428:	dfc00215 	stw	ra,8(sp)
   4c42c:	df000115 	stw	fp,4(sp)
   4c430:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   4c434:	00800174 	movhi	r2,5
   4c438:	10b4db04 	addi	r2,r2,-11412
   4c43c:	e0bfff15 	stw	r2,-4(fp)
   4c440:	00000606 	br	4c45c <_do_dtors+0x38>
        (*dtor) (); 
   4c444:	e0bfff17 	ldw	r2,-4(fp)
   4c448:	10800017 	ldw	r2,0(r2)
   4c44c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   4c450:	e0bfff17 	ldw	r2,-4(fp)
   4c454:	10bfff04 	addi	r2,r2,-4
   4c458:	e0bfff15 	stw	r2,-4(fp)
   4c45c:	e0ffff17 	ldw	r3,-4(fp)
   4c460:	00800174 	movhi	r2,5
   4c464:	10b4dc04 	addi	r2,r2,-11408
   4c468:	18bff62e 	bgeu	r3,r2,4c444 <__alt_mem_epcs_flash+0xfffcb444>
        (*dtor) (); 
}
   4c46c:	0001883a 	nop
   4c470:	e037883a 	mov	sp,fp
   4c474:	dfc00117 	ldw	ra,4(sp)
   4c478:	df000017 	ldw	fp,0(sp)
   4c47c:	dec00204 	addi	sp,sp,8
   4c480:	f800283a 	ret

0004c484 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   4c484:	defffa04 	addi	sp,sp,-24
   4c488:	dfc00515 	stw	ra,20(sp)
   4c48c:	df000415 	stw	fp,16(sp)
   4c490:	df000404 	addi	fp,sp,16
   4c494:	e13ffe15 	stw	r4,-8(fp)
   4c498:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   4c49c:	e0bfff17 	ldw	r2,-4(fp)
   4c4a0:	10800017 	ldw	r2,0(r2)
   4c4a4:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   4c4a8:	e13ffe17 	ldw	r4,-8(fp)
   4c4ac:	00497200 	call	49720 <strlen>
   4c4b0:	10800044 	addi	r2,r2,1
   4c4b4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   4c4b8:	00000d06 	br	4c4f0 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   4c4bc:	e0bffc17 	ldw	r2,-16(fp)
   4c4c0:	10800217 	ldw	r2,8(r2)
   4c4c4:	e0fffd17 	ldw	r3,-12(fp)
   4c4c8:	180d883a 	mov	r6,r3
   4c4cc:	e17ffe17 	ldw	r5,-8(fp)
   4c4d0:	1009883a 	mov	r4,r2
   4c4d4:	004d0280 	call	4d028 <memcmp>
   4c4d8:	1000021e 	bne	r2,zero,4c4e4 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   4c4dc:	e0bffc17 	ldw	r2,-16(fp)
   4c4e0:	00000706 	br	4c500 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   4c4e4:	e0bffc17 	ldw	r2,-16(fp)
   4c4e8:	10800017 	ldw	r2,0(r2)
   4c4ec:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   4c4f0:	e0fffc17 	ldw	r3,-16(fp)
   4c4f4:	e0bfff17 	ldw	r2,-4(fp)
   4c4f8:	18bff01e 	bne	r3,r2,4c4bc <__alt_mem_epcs_flash+0xfffcb4bc>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   4c4fc:	0005883a 	mov	r2,zero
}
   4c500:	e037883a 	mov	sp,fp
   4c504:	dfc00117 	ldw	ra,4(sp)
   4c508:	df000017 	ldw	fp,0(sp)
   4c50c:	dec00204 	addi	sp,sp,8
   4c510:	f800283a 	ret

0004c514 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   4c514:	defffe04 	addi	sp,sp,-8
   4c518:	dfc00115 	stw	ra,4(sp)
   4c51c:	df000015 	stw	fp,0(sp)
   4c520:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   4c524:	01440004 	movi	r5,4096
   4c528:	0009883a 	mov	r4,zero
   4c52c:	004cf4c0 	call	4cf4c <alt_icache_flush>
#endif
}
   4c530:	0001883a 	nop
   4c534:	e037883a 	mov	sp,fp
   4c538:	dfc00117 	ldw	ra,4(sp)
   4c53c:	df000017 	ldw	fp,0(sp)
   4c540:	dec00204 	addi	sp,sp,8
   4c544:	f800283a 	ret

0004c548 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
   4c548:	defffe04 	addi	sp,sp,-8
   4c54c:	df000115 	stw	fp,4(sp)
   4c550:	df000104 	addi	fp,sp,4
   4c554:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
   4c558:	e0bfff17 	ldw	r2,-4(fp)
   4c55c:	10bffe84 	addi	r2,r2,-6
   4c560:	10c00428 	cmpgeui	r3,r2,16
   4c564:	18001a1e 	bne	r3,zero,4c5d0 <alt_exception_cause_generated_bad_addr+0x88>
   4c568:	100690ba 	slli	r3,r2,2
   4c56c:	00800174 	movhi	r2,5
   4c570:	10b16004 	addi	r2,r2,-14976
   4c574:	1885883a 	add	r2,r3,r2
   4c578:	10800017 	ldw	r2,0(r2)
   4c57c:	1000683a 	jmp	r2
   4c580:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
   4c584:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
   4c588:	0004c5d0 	cmplti	zero,zero,4887
   4c58c:	0004c5d0 	cmplti	zero,zero,4887
   4c590:	0004c5d0 	cmplti	zero,zero,4887
   4c594:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
   4c598:	0004c5c8 	cmpgei	zero,zero,4887
   4c59c:	0004c5d0 	cmplti	zero,zero,4887
   4c5a0:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
   4c5a4:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
   4c5a8:	0004c5d0 	cmplti	zero,zero,4887
   4c5ac:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
   4c5b0:	0004c5c8 	cmpgei	zero,zero,4887
   4c5b4:	0004c5d0 	cmplti	zero,zero,4887
   4c5b8:	0004c5d0 	cmplti	zero,zero,4887
   4c5bc:	0004c5c0 	call	4c5c <__alt_mem_onchip_memory-0x3b3a4>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   4c5c0:	00800044 	movi	r2,1
   4c5c4:	00000306 	br	4c5d4 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   4c5c8:	0005883a 	mov	r2,zero
   4c5cc:	00000106 	br	4c5d4 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
   4c5d0:	0005883a 	mov	r2,zero
  }
}
   4c5d4:	e037883a 	mov	sp,fp
   4c5d8:	df000017 	ldw	fp,0(sp)
   4c5dc:	dec00104 	addi	sp,sp,4
   4c5e0:	f800283a 	ret

0004c5e4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   4c5e4:	defff904 	addi	sp,sp,-28
   4c5e8:	dfc00615 	stw	ra,24(sp)
   4c5ec:	df000515 	stw	fp,20(sp)
   4c5f0:	df000504 	addi	fp,sp,20
   4c5f4:	e13ffc15 	stw	r4,-16(fp)
   4c5f8:	e17ffd15 	stw	r5,-12(fp)
   4c5fc:	e1bffe15 	stw	r6,-8(fp)
   4c600:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   4c604:	e1bfff17 	ldw	r6,-4(fp)
   4c608:	e17ffe17 	ldw	r5,-8(fp)
   4c60c:	e13ffd17 	ldw	r4,-12(fp)
   4c610:	004c8240 	call	4c824 <open>
   4c614:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   4c618:	e0bffb17 	ldw	r2,-20(fp)
   4c61c:	10001c16 	blt	r2,zero,4c690 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   4c620:	008001b4 	movhi	r2,6
   4c624:	10b2d704 	addi	r2,r2,-13476
   4c628:	e0fffb17 	ldw	r3,-20(fp)
   4c62c:	18c00324 	muli	r3,r3,12
   4c630:	10c5883a 	add	r2,r2,r3
   4c634:	10c00017 	ldw	r3,0(r2)
   4c638:	e0bffc17 	ldw	r2,-16(fp)
   4c63c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   4c640:	008001b4 	movhi	r2,6
   4c644:	10b2d704 	addi	r2,r2,-13476
   4c648:	e0fffb17 	ldw	r3,-20(fp)
   4c64c:	18c00324 	muli	r3,r3,12
   4c650:	10c5883a 	add	r2,r2,r3
   4c654:	10800104 	addi	r2,r2,4
   4c658:	10c00017 	ldw	r3,0(r2)
   4c65c:	e0bffc17 	ldw	r2,-16(fp)
   4c660:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   4c664:	008001b4 	movhi	r2,6
   4c668:	10b2d704 	addi	r2,r2,-13476
   4c66c:	e0fffb17 	ldw	r3,-20(fp)
   4c670:	18c00324 	muli	r3,r3,12
   4c674:	10c5883a 	add	r2,r2,r3
   4c678:	10800204 	addi	r2,r2,8
   4c67c:	10c00017 	ldw	r3,0(r2)
   4c680:	e0bffc17 	ldw	r2,-16(fp)
   4c684:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   4c688:	e13ffb17 	ldw	r4,-20(fp)
   4c68c:	004c9780 	call	4c978 <alt_release_fd>
  }
} 
   4c690:	0001883a 	nop
   4c694:	e037883a 	mov	sp,fp
   4c698:	dfc00117 	ldw	ra,4(sp)
   4c69c:	df000017 	ldw	fp,0(sp)
   4c6a0:	dec00204 	addi	sp,sp,8
   4c6a4:	f800283a 	ret

0004c6a8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   4c6a8:	defffb04 	addi	sp,sp,-20
   4c6ac:	dfc00415 	stw	ra,16(sp)
   4c6b0:	df000315 	stw	fp,12(sp)
   4c6b4:	df000304 	addi	fp,sp,12
   4c6b8:	e13ffd15 	stw	r4,-12(fp)
   4c6bc:	e17ffe15 	stw	r5,-8(fp)
   4c6c0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   4c6c4:	01c07fc4 	movi	r7,511
   4c6c8:	01800044 	movi	r6,1
   4c6cc:	e17ffd17 	ldw	r5,-12(fp)
   4c6d0:	010001b4 	movhi	r4,6
   4c6d4:	2132da04 	addi	r4,r4,-13464
   4c6d8:	004c5e40 	call	4c5e4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   4c6dc:	01c07fc4 	movi	r7,511
   4c6e0:	000d883a 	mov	r6,zero
   4c6e4:	e17ffe17 	ldw	r5,-8(fp)
   4c6e8:	010001b4 	movhi	r4,6
   4c6ec:	2132d704 	addi	r4,r4,-13476
   4c6f0:	004c5e40 	call	4c5e4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   4c6f4:	01c07fc4 	movi	r7,511
   4c6f8:	01800044 	movi	r6,1
   4c6fc:	e17fff17 	ldw	r5,-4(fp)
   4c700:	010001b4 	movhi	r4,6
   4c704:	2132dd04 	addi	r4,r4,-13452
   4c708:	004c5e40 	call	4c5e4 <alt_open_fd>
}  
   4c70c:	0001883a 	nop
   4c710:	e037883a 	mov	sp,fp
   4c714:	dfc00117 	ldw	ra,4(sp)
   4c718:	df000017 	ldw	fp,0(sp)
   4c71c:	dec00204 	addi	sp,sp,8
   4c720:	f800283a 	ret

0004c724 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   4c724:	defffe04 	addi	sp,sp,-8
   4c728:	dfc00115 	stw	ra,4(sp)
   4c72c:	df000015 	stw	fp,0(sp)
   4c730:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   4c734:	d0a00e17 	ldw	r2,-32712(gp)
   4c738:	10000326 	beq	r2,zero,4c748 <alt_get_errno+0x24>
   4c73c:	d0a00e17 	ldw	r2,-32712(gp)
   4c740:	103ee83a 	callr	r2
   4c744:	00000106 	br	4c74c <alt_get_errno+0x28>
   4c748:	d0a02004 	addi	r2,gp,-32640
}
   4c74c:	e037883a 	mov	sp,fp
   4c750:	dfc00117 	ldw	ra,4(sp)
   4c754:	df000017 	ldw	fp,0(sp)
   4c758:	dec00204 	addi	sp,sp,8
   4c75c:	f800283a 	ret

0004c760 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   4c760:	defffd04 	addi	sp,sp,-12
   4c764:	df000215 	stw	fp,8(sp)
   4c768:	df000204 	addi	fp,sp,8
   4c76c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   4c770:	e0bfff17 	ldw	r2,-4(fp)
   4c774:	10800217 	ldw	r2,8(r2)
   4c778:	10d00034 	orhi	r3,r2,16384
   4c77c:	e0bfff17 	ldw	r2,-4(fp)
   4c780:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   4c784:	e03ffe15 	stw	zero,-8(fp)
   4c788:	00001d06 	br	4c800 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   4c78c:	008001b4 	movhi	r2,6
   4c790:	10b2d704 	addi	r2,r2,-13476
   4c794:	e0fffe17 	ldw	r3,-8(fp)
   4c798:	18c00324 	muli	r3,r3,12
   4c79c:	10c5883a 	add	r2,r2,r3
   4c7a0:	10c00017 	ldw	r3,0(r2)
   4c7a4:	e0bfff17 	ldw	r2,-4(fp)
   4c7a8:	10800017 	ldw	r2,0(r2)
   4c7ac:	1880111e 	bne	r3,r2,4c7f4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   4c7b0:	008001b4 	movhi	r2,6
   4c7b4:	10b2d704 	addi	r2,r2,-13476
   4c7b8:	e0fffe17 	ldw	r3,-8(fp)
   4c7bc:	18c00324 	muli	r3,r3,12
   4c7c0:	10c5883a 	add	r2,r2,r3
   4c7c4:	10800204 	addi	r2,r2,8
   4c7c8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   4c7cc:	1000090e 	bge	r2,zero,4c7f4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   4c7d0:	e0bffe17 	ldw	r2,-8(fp)
   4c7d4:	10c00324 	muli	r3,r2,12
   4c7d8:	008001b4 	movhi	r2,6
   4c7dc:	10b2d704 	addi	r2,r2,-13476
   4c7e0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   4c7e4:	e0bfff17 	ldw	r2,-4(fp)
   4c7e8:	18800226 	beq	r3,r2,4c7f4 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   4c7ec:	00bffcc4 	movi	r2,-13
   4c7f0:	00000806 	br	4c814 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   4c7f4:	e0bffe17 	ldw	r2,-8(fp)
   4c7f8:	10800044 	addi	r2,r2,1
   4c7fc:	e0bffe15 	stw	r2,-8(fp)
   4c800:	d0a00d17 	ldw	r2,-32716(gp)
   4c804:	1007883a 	mov	r3,r2
   4c808:	e0bffe17 	ldw	r2,-8(fp)
   4c80c:	18bfdf2e 	bgeu	r3,r2,4c78c <__alt_mem_epcs_flash+0xfffcb78c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   4c810:	0005883a 	mov	r2,zero
}
   4c814:	e037883a 	mov	sp,fp
   4c818:	df000017 	ldw	fp,0(sp)
   4c81c:	dec00104 	addi	sp,sp,4
   4c820:	f800283a 	ret

0004c824 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   4c824:	defff604 	addi	sp,sp,-40
   4c828:	dfc00915 	stw	ra,36(sp)
   4c82c:	df000815 	stw	fp,32(sp)
   4c830:	df000804 	addi	fp,sp,32
   4c834:	e13ffd15 	stw	r4,-12(fp)
   4c838:	e17ffe15 	stw	r5,-8(fp)
   4c83c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   4c840:	00bfffc4 	movi	r2,-1
   4c844:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   4c848:	00bffb44 	movi	r2,-19
   4c84c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   4c850:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   4c854:	d1600b04 	addi	r5,gp,-32724
   4c858:	e13ffd17 	ldw	r4,-12(fp)
   4c85c:	004c4840 	call	4c484 <alt_find_dev>
   4c860:	e0bff815 	stw	r2,-32(fp)
   4c864:	e0bff817 	ldw	r2,-32(fp)
   4c868:	1000051e 	bne	r2,zero,4c880 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   4c86c:	e13ffd17 	ldw	r4,-12(fp)
   4c870:	004cda00 	call	4cda0 <alt_find_file>
   4c874:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   4c878:	00800044 	movi	r2,1
   4c87c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   4c880:	e0bff817 	ldw	r2,-32(fp)
   4c884:	10002926 	beq	r2,zero,4c92c <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
   4c888:	e13ff817 	ldw	r4,-32(fp)
   4c88c:	004cea80 	call	4cea8 <alt_get_fd>
   4c890:	e0bff915 	stw	r2,-28(fp)
   4c894:	e0bff917 	ldw	r2,-28(fp)
   4c898:	1000030e 	bge	r2,zero,4c8a8 <open+0x84>
    {
      status = index;
   4c89c:	e0bff917 	ldw	r2,-28(fp)
   4c8a0:	e0bffa15 	stw	r2,-24(fp)
   4c8a4:	00002306 	br	4c934 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
   4c8a8:	e0bff917 	ldw	r2,-28(fp)
   4c8ac:	10c00324 	muli	r3,r2,12
   4c8b0:	008001b4 	movhi	r2,6
   4c8b4:	10b2d704 	addi	r2,r2,-13476
   4c8b8:	1885883a 	add	r2,r3,r2
   4c8bc:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   4c8c0:	e0fffe17 	ldw	r3,-8(fp)
   4c8c4:	00900034 	movhi	r2,16384
   4c8c8:	10bfffc4 	addi	r2,r2,-1
   4c8cc:	1886703a 	and	r3,r3,r2
   4c8d0:	e0bffc17 	ldw	r2,-16(fp)
   4c8d4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   4c8d8:	e0bffb17 	ldw	r2,-20(fp)
   4c8dc:	1000051e 	bne	r2,zero,4c8f4 <open+0xd0>
   4c8e0:	e13ffc17 	ldw	r4,-16(fp)
   4c8e4:	004c7600 	call	4c760 <alt_file_locked>
   4c8e8:	e0bffa15 	stw	r2,-24(fp)
   4c8ec:	e0bffa17 	ldw	r2,-24(fp)
   4c8f0:	10001016 	blt	r2,zero,4c934 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   4c8f4:	e0bff817 	ldw	r2,-32(fp)
   4c8f8:	10800317 	ldw	r2,12(r2)
   4c8fc:	10000826 	beq	r2,zero,4c920 <open+0xfc>
   4c900:	e0bff817 	ldw	r2,-32(fp)
   4c904:	10800317 	ldw	r2,12(r2)
   4c908:	e1ffff17 	ldw	r7,-4(fp)
   4c90c:	e1bffe17 	ldw	r6,-8(fp)
   4c910:	e17ffd17 	ldw	r5,-12(fp)
   4c914:	e13ffc17 	ldw	r4,-16(fp)
   4c918:	103ee83a 	callr	r2
   4c91c:	00000106 	br	4c924 <open+0x100>
   4c920:	0005883a 	mov	r2,zero
   4c924:	e0bffa15 	stw	r2,-24(fp)
   4c928:	00000206 	br	4c934 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
   4c92c:	00bffb44 	movi	r2,-19
   4c930:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   4c934:	e0bffa17 	ldw	r2,-24(fp)
   4c938:	1000090e 	bge	r2,zero,4c960 <open+0x13c>
  {
    alt_release_fd (index);  
   4c93c:	e13ff917 	ldw	r4,-28(fp)
   4c940:	004c9780 	call	4c978 <alt_release_fd>
    ALT_ERRNO = -status;
   4c944:	004c7240 	call	4c724 <alt_get_errno>
   4c948:	1007883a 	mov	r3,r2
   4c94c:	e0bffa17 	ldw	r2,-24(fp)
   4c950:	0085c83a 	sub	r2,zero,r2
   4c954:	18800015 	stw	r2,0(r3)
    return -1;
   4c958:	00bfffc4 	movi	r2,-1
   4c95c:	00000106 	br	4c964 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   4c960:	e0bff917 	ldw	r2,-28(fp)
}
   4c964:	e037883a 	mov	sp,fp
   4c968:	dfc00117 	ldw	ra,4(sp)
   4c96c:	df000017 	ldw	fp,0(sp)
   4c970:	dec00204 	addi	sp,sp,8
   4c974:	f800283a 	ret

0004c978 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   4c978:	defffe04 	addi	sp,sp,-8
   4c97c:	df000115 	stw	fp,4(sp)
   4c980:	df000104 	addi	fp,sp,4
   4c984:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   4c988:	e0bfff17 	ldw	r2,-4(fp)
   4c98c:	108000d0 	cmplti	r2,r2,3
   4c990:	10000d1e 	bne	r2,zero,4c9c8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   4c994:	008001b4 	movhi	r2,6
   4c998:	10b2d704 	addi	r2,r2,-13476
   4c99c:	e0ffff17 	ldw	r3,-4(fp)
   4c9a0:	18c00324 	muli	r3,r3,12
   4c9a4:	10c5883a 	add	r2,r2,r3
   4c9a8:	10800204 	addi	r2,r2,8
   4c9ac:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   4c9b0:	008001b4 	movhi	r2,6
   4c9b4:	10b2d704 	addi	r2,r2,-13476
   4c9b8:	e0ffff17 	ldw	r3,-4(fp)
   4c9bc:	18c00324 	muli	r3,r3,12
   4c9c0:	10c5883a 	add	r2,r2,r3
   4c9c4:	10000015 	stw	zero,0(r2)
  }
}
   4c9c8:	0001883a 	nop
   4c9cc:	e037883a 	mov	sp,fp
   4c9d0:	df000017 	ldw	fp,0(sp)
   4c9d4:	dec00104 	addi	sp,sp,4
   4c9d8:	f800283a 	ret

0004c9dc <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   4c9dc:	defffa04 	addi	sp,sp,-24
   4c9e0:	df000515 	stw	fp,20(sp)
   4c9e4:	df000504 	addi	fp,sp,20
   4c9e8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   4c9ec:	0005303a 	rdctl	r2,status
   4c9f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   4c9f4:	e0fffc17 	ldw	r3,-16(fp)
   4c9f8:	00bfff84 	movi	r2,-2
   4c9fc:	1884703a 	and	r2,r3,r2
   4ca00:	1001703a 	wrctl	status,r2
  
  return context;
   4ca04:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   4ca08:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
   4ca0c:	e0bfff17 	ldw	r2,-4(fp)
   4ca10:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   4ca14:	e0bffd17 	ldw	r2,-12(fp)
   4ca18:	10800017 	ldw	r2,0(r2)
   4ca1c:	e0fffd17 	ldw	r3,-12(fp)
   4ca20:	18c00117 	ldw	r3,4(r3)
   4ca24:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   4ca28:	e0bffd17 	ldw	r2,-12(fp)
   4ca2c:	10800117 	ldw	r2,4(r2)
   4ca30:	e0fffd17 	ldw	r3,-12(fp)
   4ca34:	18c00017 	ldw	r3,0(r3)
   4ca38:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   4ca3c:	e0bffd17 	ldw	r2,-12(fp)
   4ca40:	e0fffd17 	ldw	r3,-12(fp)
   4ca44:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   4ca48:	e0bffd17 	ldw	r2,-12(fp)
   4ca4c:	e0fffd17 	ldw	r3,-12(fp)
   4ca50:	10c00015 	stw	r3,0(r2)
   4ca54:	e0bffb17 	ldw	r2,-20(fp)
   4ca58:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   4ca5c:	e0bffe17 	ldw	r2,-8(fp)
   4ca60:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   4ca64:	0001883a 	nop
   4ca68:	e037883a 	mov	sp,fp
   4ca6c:	df000017 	ldw	fp,0(sp)
   4ca70:	dec00104 	addi	sp,sp,4
   4ca74:	f800283a 	ret

0004ca78 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   4ca78:	defffb04 	addi	sp,sp,-20
   4ca7c:	dfc00415 	stw	ra,16(sp)
   4ca80:	df000315 	stw	fp,12(sp)
   4ca84:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   4ca88:	d0a00f17 	ldw	r2,-32708(gp)
   4ca8c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   4ca90:	d0a01f17 	ldw	r2,-32644(gp)
   4ca94:	10800044 	addi	r2,r2,1
   4ca98:	d0a01f15 	stw	r2,-32644(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   4ca9c:	00002e06 	br	4cb58 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   4caa0:	e0bffd17 	ldw	r2,-12(fp)
   4caa4:	10800017 	ldw	r2,0(r2)
   4caa8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   4caac:	e0bffd17 	ldw	r2,-12(fp)
   4cab0:	10800403 	ldbu	r2,16(r2)
   4cab4:	10803fcc 	andi	r2,r2,255
   4cab8:	10000426 	beq	r2,zero,4cacc <alt_tick+0x54>
   4cabc:	d0a01f17 	ldw	r2,-32644(gp)
   4cac0:	1000021e 	bne	r2,zero,4cacc <alt_tick+0x54>
    {
      alarm->rollover = 0;
   4cac4:	e0bffd17 	ldw	r2,-12(fp)
   4cac8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   4cacc:	e0bffd17 	ldw	r2,-12(fp)
   4cad0:	10800217 	ldw	r2,8(r2)
   4cad4:	d0e01f17 	ldw	r3,-32644(gp)
   4cad8:	18801d36 	bltu	r3,r2,4cb50 <alt_tick+0xd8>
   4cadc:	e0bffd17 	ldw	r2,-12(fp)
   4cae0:	10800403 	ldbu	r2,16(r2)
   4cae4:	10803fcc 	andi	r2,r2,255
   4cae8:	1000191e 	bne	r2,zero,4cb50 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   4caec:	e0bffd17 	ldw	r2,-12(fp)
   4caf0:	10800317 	ldw	r2,12(r2)
   4caf4:	e0fffd17 	ldw	r3,-12(fp)
   4caf8:	18c00517 	ldw	r3,20(r3)
   4cafc:	1809883a 	mov	r4,r3
   4cb00:	103ee83a 	callr	r2
   4cb04:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   4cb08:	e0bfff17 	ldw	r2,-4(fp)
   4cb0c:	1000031e 	bne	r2,zero,4cb1c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   4cb10:	e13ffd17 	ldw	r4,-12(fp)
   4cb14:	004c9dc0 	call	4c9dc <alt_alarm_stop>
   4cb18:	00000d06 	br	4cb50 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   4cb1c:	e0bffd17 	ldw	r2,-12(fp)
   4cb20:	10c00217 	ldw	r3,8(r2)
   4cb24:	e0bfff17 	ldw	r2,-4(fp)
   4cb28:	1887883a 	add	r3,r3,r2
   4cb2c:	e0bffd17 	ldw	r2,-12(fp)
   4cb30:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   4cb34:	e0bffd17 	ldw	r2,-12(fp)
   4cb38:	10c00217 	ldw	r3,8(r2)
   4cb3c:	d0a01f17 	ldw	r2,-32644(gp)
   4cb40:	1880032e 	bgeu	r3,r2,4cb50 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   4cb44:	e0bffd17 	ldw	r2,-12(fp)
   4cb48:	00c00044 	movi	r3,1
   4cb4c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   4cb50:	e0bffe17 	ldw	r2,-8(fp)
   4cb54:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   4cb58:	e0fffd17 	ldw	r3,-12(fp)
   4cb5c:	d0a00f04 	addi	r2,gp,-32708
   4cb60:	18bfcf1e 	bne	r3,r2,4caa0 <__alt_mem_epcs_flash+0xfffcbaa0>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   4cb64:	0001883a 	nop
}
   4cb68:	0001883a 	nop
   4cb6c:	e037883a 	mov	sp,fp
   4cb70:	dfc00117 	ldw	ra,4(sp)
   4cb74:	df000017 	ldw	fp,0(sp)
   4cb78:	dec00204 	addi	sp,sp,8
   4cb7c:	f800283a 	ret

0004cb80 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   4cb80:	deffff04 	addi	sp,sp,-4
   4cb84:	df000015 	stw	fp,0(sp)
   4cb88:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   4cb8c:	000170fa 	wrctl	ienable,zero
}
   4cb90:	0001883a 	nop
   4cb94:	e037883a 	mov	sp,fp
   4cb98:	df000017 	ldw	fp,0(sp)
   4cb9c:	dec00104 	addi	sp,sp,4
   4cba0:	f800283a 	ret

0004cba4 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   4cba4:	defff404 	addi	sp,sp,-48
   4cba8:	df000b15 	stw	fp,44(sp)
   4cbac:	df000b04 	addi	fp,sp,44
   4cbb0:	e13ffc15 	stw	r4,-16(fp)
   4cbb4:	e17ffd15 	stw	r5,-12(fp)
   4cbb8:	e1bffe15 	stw	r6,-8(fp)
   4cbbc:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
   4cbc0:	e0ffff17 	ldw	r3,-4(fp)
   4cbc4:	e0bffe17 	ldw	r2,-8(fp)
   4cbc8:	1885883a 	add	r2,r3,r2
   4cbcc:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
   4cbd0:	e0c00217 	ldw	r3,8(fp)
   4cbd4:	e0800117 	ldw	r2,4(fp)
   4cbd8:	1885883a 	add	r2,r3,r2
   4cbdc:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
   4cbe0:	e0800117 	ldw	r2,4(fp)
   4cbe4:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
   4cbe8:	e0bffe17 	ldw	r2,-8(fp)
   4cbec:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
   4cbf0:	00800044 	movi	r2,1
   4cbf4:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   4cbf8:	e0bffc17 	ldw	r2,-16(fp)
   4cbfc:	10800504 	addi	r2,r2,20
   4cc00:	1009883a 	mov	r4,r2
   4cc04:	00c00044 	movi	r3,1
   4cc08:	e0bffd17 	ldw	r2,-12(fp)
   4cc0c:	1884983a 	sll	r2,r3,r2
   4cc10:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   4cc14:	e0800317 	ldw	r2,12(fp)
   4cc18:	1080008c 	andi	r2,r2,2
   4cc1c:	1000051e 	bne	r2,zero,4cc34 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   4cc20:	e0bffc17 	ldw	r2,-16(fp)
   4cc24:	10800304 	addi	r2,r2,12
   4cc28:	1007883a 	mov	r3,r2
   4cc2c:	00810004 	movi	r2,1024
   4cc30:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   4cc34:	e0bffc17 	ldw	r2,-16(fp)
   4cc38:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   4cc3c:	e0bffc17 	ldw	r2,-16(fp)
   4cc40:	10800204 	addi	r2,r2,8
   4cc44:	10800037 	ldwio	r2,0(r2)
   4cc48:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   4cc4c:	e0bffa17 	ldw	r2,-24(fp)
   4cc50:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
   4cc54:	10000226 	beq	r2,zero,4cc60 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   4cc58:	e0bff717 	ldw	r2,-36(fp)
   4cc5c:	1000031e 	bne	r2,zero,4cc6c <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
   4cc60:	e0bffa17 	ldw	r2,-24(fp)
   4cc64:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   4cc68:	103ff426 	beq	r2,zero,4cc3c <__alt_mem_epcs_flash+0xfffcbc3c>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   4cc6c:	e0bffa17 	ldw	r2,-24(fp)
   4cc70:	1080100c 	andi	r2,r2,64
   4cc74:	10001e26 	beq	r2,zero,4ccf0 <alt_avalon_spi_command+0x14c>
   4cc78:	e0bff717 	ldw	r2,-36(fp)
   4cc7c:	00801c0e 	bge	zero,r2,4ccf0 <alt_avalon_spi_command+0x14c>
    {
      credits--;
   4cc80:	e0bff717 	ldw	r2,-36(fp)
   4cc84:	10bfffc4 	addi	r2,r2,-1
   4cc88:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
   4cc8c:	e0ffff17 	ldw	r3,-4(fp)
   4cc90:	e0bff817 	ldw	r2,-32(fp)
   4cc94:	18800a2e 	bgeu	r3,r2,4ccc0 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   4cc98:	e0bffc17 	ldw	r2,-16(fp)
   4cc9c:	10800104 	addi	r2,r2,4
   4cca0:	1009883a 	mov	r4,r2
   4cca4:	e0bfff17 	ldw	r2,-4(fp)
   4cca8:	10c00044 	addi	r3,r2,1
   4ccac:	e0ffff15 	stw	r3,-4(fp)
   4ccb0:	10800003 	ldbu	r2,0(r2)
   4ccb4:	10803fcc 	andi	r2,r2,255
   4ccb8:	20800035 	stwio	r2,0(r4)
   4ccbc:	00000c06 	br	4ccf0 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
   4ccc0:	e0bff517 	ldw	r2,-44(fp)
   4ccc4:	10000826 	beq	r2,zero,4cce8 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
   4ccc8:	e0bff517 	ldw	r2,-44(fp)
   4cccc:	10bfffc4 	addi	r2,r2,-1
   4ccd0:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   4ccd4:	e0bffc17 	ldw	r2,-16(fp)
   4ccd8:	10800104 	addi	r2,r2,4
   4ccdc:	0007883a 	mov	r3,zero
   4cce0:	10c00035 	stwio	r3,0(r2)
   4cce4:	00000206 	br	4ccf0 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
   4cce8:	00bf0004 	movi	r2,-1024
   4ccec:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   4ccf0:	e0bffa17 	ldw	r2,-24(fp)
   4ccf4:	1080200c 	andi	r2,r2,128
   4ccf8:	103fd026 	beq	r2,zero,4cc3c <__alt_mem_epcs_flash+0xfffcbc3c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   4ccfc:	e0bffc17 	ldw	r2,-16(fp)
   4cd00:	10800037 	ldwio	r2,0(r2)
   4cd04:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
   4cd08:	e0bff617 	ldw	r2,-40(fp)
   4cd0c:	10000426 	beq	r2,zero,4cd20 <alt_avalon_spi_command+0x17c>
        read_ignore--;
   4cd10:	e0bff617 	ldw	r2,-40(fp)
   4cd14:	10bfffc4 	addi	r2,r2,-1
   4cd18:	e0bff615 	stw	r2,-40(fp)
   4cd1c:	00000506 	br	4cd34 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
   4cd20:	e0800217 	ldw	r2,8(fp)
   4cd24:	10c00044 	addi	r3,r2,1
   4cd28:	e0c00215 	stw	r3,8(fp)
   4cd2c:	e0fffb17 	ldw	r3,-20(fp)
   4cd30:	10c00005 	stb	r3,0(r2)
      credits++;
   4cd34:	e0bff717 	ldw	r2,-36(fp)
   4cd38:	10800044 	addi	r2,r2,1
   4cd3c:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
   4cd40:	e0bff617 	ldw	r2,-40(fp)
   4cd44:	103fbd1e 	bne	r2,zero,4cc3c <__alt_mem_epcs_flash+0xfffcbc3c>
   4cd48:	e0c00217 	ldw	r3,8(fp)
   4cd4c:	e0bff917 	ldw	r2,-28(fp)
   4cd50:	18bfba1e 	bne	r3,r2,4cc3c <__alt_mem_epcs_flash+0xfffcbc3c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   4cd54:	e0bffc17 	ldw	r2,-16(fp)
   4cd58:	10800204 	addi	r2,r2,8
   4cd5c:	10800037 	ldwio	r2,0(r2)
   4cd60:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   4cd64:	e0bffa17 	ldw	r2,-24(fp)
   4cd68:	1080080c 	andi	r2,r2,32
   4cd6c:	103ff926 	beq	r2,zero,4cd54 <__alt_mem_epcs_flash+0xfffcbd54>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   4cd70:	e0800317 	ldw	r2,12(fp)
   4cd74:	1080004c 	andi	r2,r2,1
   4cd78:	1000041e 	bne	r2,zero,4cd8c <alt_avalon_spi_command+0x1e8>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   4cd7c:	e0bffc17 	ldw	r2,-16(fp)
   4cd80:	10800304 	addi	r2,r2,12
   4cd84:	0007883a 	mov	r3,zero
   4cd88:	10c00035 	stwio	r3,0(r2)

  return read_length;
   4cd8c:	e0800117 	ldw	r2,4(fp)
}
   4cd90:	e037883a 	mov	sp,fp
   4cd94:	df000017 	ldw	fp,0(sp)
   4cd98:	dec00104 	addi	sp,sp,4
   4cd9c:	f800283a 	ret

0004cda0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   4cda0:	defffb04 	addi	sp,sp,-20
   4cda4:	dfc00415 	stw	ra,16(sp)
   4cda8:	df000315 	stw	fp,12(sp)
   4cdac:	df000304 	addi	fp,sp,12
   4cdb0:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   4cdb4:	d0a00917 	ldw	r2,-32732(gp)
   4cdb8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   4cdbc:	00003106 	br	4ce84 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   4cdc0:	e0bffd17 	ldw	r2,-12(fp)
   4cdc4:	10800217 	ldw	r2,8(r2)
   4cdc8:	1009883a 	mov	r4,r2
   4cdcc:	00497200 	call	49720 <strlen>
   4cdd0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   4cdd4:	e0bffd17 	ldw	r2,-12(fp)
   4cdd8:	10c00217 	ldw	r3,8(r2)
   4cddc:	e0bffe17 	ldw	r2,-8(fp)
   4cde0:	10bfffc4 	addi	r2,r2,-1
   4cde4:	1885883a 	add	r2,r3,r2
   4cde8:	10800003 	ldbu	r2,0(r2)
   4cdec:	10803fcc 	andi	r2,r2,255
   4cdf0:	1080201c 	xori	r2,r2,128
   4cdf4:	10bfe004 	addi	r2,r2,-128
   4cdf8:	10800bd8 	cmpnei	r2,r2,47
   4cdfc:	1000031e 	bne	r2,zero,4ce0c <alt_find_file+0x6c>
    {
      len -= 1;
   4ce00:	e0bffe17 	ldw	r2,-8(fp)
   4ce04:	10bfffc4 	addi	r2,r2,-1
   4ce08:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   4ce0c:	e0bffe17 	ldw	r2,-8(fp)
   4ce10:	e0ffff17 	ldw	r3,-4(fp)
   4ce14:	1885883a 	add	r2,r3,r2
   4ce18:	10800003 	ldbu	r2,0(r2)
   4ce1c:	10803fcc 	andi	r2,r2,255
   4ce20:	1080201c 	xori	r2,r2,128
   4ce24:	10bfe004 	addi	r2,r2,-128
   4ce28:	10800be0 	cmpeqi	r2,r2,47
   4ce2c:	1000081e 	bne	r2,zero,4ce50 <alt_find_file+0xb0>
   4ce30:	e0bffe17 	ldw	r2,-8(fp)
   4ce34:	e0ffff17 	ldw	r3,-4(fp)
   4ce38:	1885883a 	add	r2,r3,r2
   4ce3c:	10800003 	ldbu	r2,0(r2)
   4ce40:	10803fcc 	andi	r2,r2,255
   4ce44:	1080201c 	xori	r2,r2,128
   4ce48:	10bfe004 	addi	r2,r2,-128
   4ce4c:	10000a1e 	bne	r2,zero,4ce78 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   4ce50:	e0bffd17 	ldw	r2,-12(fp)
   4ce54:	10800217 	ldw	r2,8(r2)
   4ce58:	e0fffe17 	ldw	r3,-8(fp)
   4ce5c:	180d883a 	mov	r6,r3
   4ce60:	e17fff17 	ldw	r5,-4(fp)
   4ce64:	1009883a 	mov	r4,r2
   4ce68:	004d0280 	call	4d028 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   4ce6c:	1000021e 	bne	r2,zero,4ce78 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   4ce70:	e0bffd17 	ldw	r2,-12(fp)
   4ce74:	00000706 	br	4ce94 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   4ce78:	e0bffd17 	ldw	r2,-12(fp)
   4ce7c:	10800017 	ldw	r2,0(r2)
   4ce80:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   4ce84:	e0fffd17 	ldw	r3,-12(fp)
   4ce88:	d0a00904 	addi	r2,gp,-32732
   4ce8c:	18bfcc1e 	bne	r3,r2,4cdc0 <__alt_mem_epcs_flash+0xfffcbdc0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   4ce90:	0005883a 	mov	r2,zero
}
   4ce94:	e037883a 	mov	sp,fp
   4ce98:	dfc00117 	ldw	ra,4(sp)
   4ce9c:	df000017 	ldw	fp,0(sp)
   4cea0:	dec00204 	addi	sp,sp,8
   4cea4:	f800283a 	ret

0004cea8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   4cea8:	defffc04 	addi	sp,sp,-16
   4ceac:	df000315 	stw	fp,12(sp)
   4ceb0:	df000304 	addi	fp,sp,12
   4ceb4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   4ceb8:	00bffa04 	movi	r2,-24
   4cebc:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   4cec0:	e03ffd15 	stw	zero,-12(fp)
   4cec4:	00001906 	br	4cf2c <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
   4cec8:	008001b4 	movhi	r2,6
   4cecc:	10b2d704 	addi	r2,r2,-13476
   4ced0:	e0fffd17 	ldw	r3,-12(fp)
   4ced4:	18c00324 	muli	r3,r3,12
   4ced8:	10c5883a 	add	r2,r2,r3
   4cedc:	10800017 	ldw	r2,0(r2)
   4cee0:	10000f1e 	bne	r2,zero,4cf20 <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
   4cee4:	008001b4 	movhi	r2,6
   4cee8:	10b2d704 	addi	r2,r2,-13476
   4ceec:	e0fffd17 	ldw	r3,-12(fp)
   4cef0:	18c00324 	muli	r3,r3,12
   4cef4:	10c5883a 	add	r2,r2,r3
   4cef8:	e0ffff17 	ldw	r3,-4(fp)
   4cefc:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   4cf00:	d0e00d17 	ldw	r3,-32716(gp)
   4cf04:	e0bffd17 	ldw	r2,-12(fp)
   4cf08:	1880020e 	bge	r3,r2,4cf14 <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
   4cf0c:	e0bffd17 	ldw	r2,-12(fp)
   4cf10:	d0a00d15 	stw	r2,-32716(gp)
      }
      rc = i;
   4cf14:	e0bffd17 	ldw	r2,-12(fp)
   4cf18:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   4cf1c:	00000606 	br	4cf38 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   4cf20:	e0bffd17 	ldw	r2,-12(fp)
   4cf24:	10800044 	addi	r2,r2,1
   4cf28:	e0bffd15 	stw	r2,-12(fp)
   4cf2c:	e0bffd17 	ldw	r2,-12(fp)
   4cf30:	10800810 	cmplti	r2,r2,32
   4cf34:	103fe41e 	bne	r2,zero,4cec8 <__alt_mem_epcs_flash+0xfffcbec8>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   4cf38:	e0bffe17 	ldw	r2,-8(fp)
}
   4cf3c:	e037883a 	mov	sp,fp
   4cf40:	df000017 	ldw	fp,0(sp)
   4cf44:	dec00104 	addi	sp,sp,4
   4cf48:	f800283a 	ret

0004cf4c <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   4cf4c:	defffb04 	addi	sp,sp,-20
   4cf50:	df000415 	stw	fp,16(sp)
   4cf54:	df000404 	addi	fp,sp,16
   4cf58:	e13ffe15 	stw	r4,-8(fp)
   4cf5c:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   4cf60:	e0bfff17 	ldw	r2,-4(fp)
   4cf64:	10840070 	cmpltui	r2,r2,4097
   4cf68:	1000021e 	bne	r2,zero,4cf74 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   4cf6c:	00840004 	movi	r2,4096
   4cf70:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   4cf74:	e0fffe17 	ldw	r3,-8(fp)
   4cf78:	e0bfff17 	ldw	r2,-4(fp)
   4cf7c:	1885883a 	add	r2,r3,r2
   4cf80:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   4cf84:	e0bffe17 	ldw	r2,-8(fp)
   4cf88:	e0bffc15 	stw	r2,-16(fp)
   4cf8c:	00000506 	br	4cfa4 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   4cf90:	e0bffc17 	ldw	r2,-16(fp)
   4cf94:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   4cf98:	e0bffc17 	ldw	r2,-16(fp)
   4cf9c:	10800804 	addi	r2,r2,32
   4cfa0:	e0bffc15 	stw	r2,-16(fp)
   4cfa4:	e0fffc17 	ldw	r3,-16(fp)
   4cfa8:	e0bffd17 	ldw	r2,-12(fp)
   4cfac:	18bff836 	bltu	r3,r2,4cf90 <__alt_mem_epcs_flash+0xfffcbf90>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   4cfb0:	e0bffe17 	ldw	r2,-8(fp)
   4cfb4:	108007cc 	andi	r2,r2,31
   4cfb8:	10000226 	beq	r2,zero,4cfc4 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   4cfbc:	e0bffc17 	ldw	r2,-16(fp)
   4cfc0:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   4cfc4:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   4cfc8:	0001883a 	nop
   4cfcc:	e037883a 	mov	sp,fp
   4cfd0:	df000017 	ldw	fp,0(sp)
   4cfd4:	dec00104 	addi	sp,sp,4
   4cfd8:	f800283a 	ret

0004cfdc <atexit>:
   4cfdc:	200b883a 	mov	r5,r4
   4cfe0:	000f883a 	mov	r7,zero
   4cfe4:	000d883a 	mov	r6,zero
   4cfe8:	0009883a 	mov	r4,zero
   4cfec:	004d0a41 	jmpi	4d0a4 <__register_exitproc>

0004cff0 <exit>:
   4cff0:	defffe04 	addi	sp,sp,-8
   4cff4:	000b883a 	mov	r5,zero
   4cff8:	dc000015 	stw	r16,0(sp)
   4cffc:	dfc00115 	stw	ra,4(sp)
   4d000:	2021883a 	mov	r16,r4
   4d004:	004d1bc0 	call	4d1bc <__call_exitprocs>
   4d008:	008001b4 	movhi	r2,6
   4d00c:	10b45104 	addi	r2,r2,-11964
   4d010:	11000017 	ldw	r4,0(r2)
   4d014:	20800f17 	ldw	r2,60(r4)
   4d018:	10000126 	beq	r2,zero,4d020 <exit+0x30>
   4d01c:	103ee83a 	callr	r2
   4d020:	8009883a 	mov	r4,r16
   4d024:	004d33c0 	call	4d33c <_exit>

0004d028 <memcmp>:
   4d028:	01c000c4 	movi	r7,3
   4d02c:	3980192e 	bgeu	r7,r6,4d094 <memcmp+0x6c>
   4d030:	2144b03a 	or	r2,r4,r5
   4d034:	11c4703a 	and	r2,r2,r7
   4d038:	10000f26 	beq	r2,zero,4d078 <memcmp+0x50>
   4d03c:	20800003 	ldbu	r2,0(r4)
   4d040:	28c00003 	ldbu	r3,0(r5)
   4d044:	10c0151e 	bne	r2,r3,4d09c <memcmp+0x74>
   4d048:	31bfff84 	addi	r6,r6,-2
   4d04c:	01ffffc4 	movi	r7,-1
   4d050:	00000406 	br	4d064 <memcmp+0x3c>
   4d054:	20800003 	ldbu	r2,0(r4)
   4d058:	28c00003 	ldbu	r3,0(r5)
   4d05c:	31bfffc4 	addi	r6,r6,-1
   4d060:	10c00e1e 	bne	r2,r3,4d09c <memcmp+0x74>
   4d064:	21000044 	addi	r4,r4,1
   4d068:	29400044 	addi	r5,r5,1
   4d06c:	31fff91e 	bne	r6,r7,4d054 <__alt_mem_epcs_flash+0xfffcc054>
   4d070:	0005883a 	mov	r2,zero
   4d074:	f800283a 	ret
   4d078:	20c00017 	ldw	r3,0(r4)
   4d07c:	28800017 	ldw	r2,0(r5)
   4d080:	18bfee1e 	bne	r3,r2,4d03c <__alt_mem_epcs_flash+0xfffcc03c>
   4d084:	31bfff04 	addi	r6,r6,-4
   4d088:	21000104 	addi	r4,r4,4
   4d08c:	29400104 	addi	r5,r5,4
   4d090:	39bff936 	bltu	r7,r6,4d078 <__alt_mem_epcs_flash+0xfffcc078>
   4d094:	303fe91e 	bne	r6,zero,4d03c <__alt_mem_epcs_flash+0xfffcc03c>
   4d098:	003ff506 	br	4d070 <__alt_mem_epcs_flash+0xfffcc070>
   4d09c:	10c5c83a 	sub	r2,r2,r3
   4d0a0:	f800283a 	ret

0004d0a4 <__register_exitproc>:
   4d0a4:	defffa04 	addi	sp,sp,-24
   4d0a8:	dc000315 	stw	r16,12(sp)
   4d0ac:	040001b4 	movhi	r16,6
   4d0b0:	84345104 	addi	r16,r16,-11964
   4d0b4:	80c00017 	ldw	r3,0(r16)
   4d0b8:	dc400415 	stw	r17,16(sp)
   4d0bc:	dfc00515 	stw	ra,20(sp)
   4d0c0:	18805217 	ldw	r2,328(r3)
   4d0c4:	2023883a 	mov	r17,r4
   4d0c8:	10003726 	beq	r2,zero,4d1a8 <__register_exitproc+0x104>
   4d0cc:	10c00117 	ldw	r3,4(r2)
   4d0d0:	010007c4 	movi	r4,31
   4d0d4:	20c00e16 	blt	r4,r3,4d110 <__register_exitproc+0x6c>
   4d0d8:	1a000044 	addi	r8,r3,1
   4d0dc:	8800221e 	bne	r17,zero,4d168 <__register_exitproc+0xc4>
   4d0e0:	18c00084 	addi	r3,r3,2
   4d0e4:	18c7883a 	add	r3,r3,r3
   4d0e8:	18c7883a 	add	r3,r3,r3
   4d0ec:	12000115 	stw	r8,4(r2)
   4d0f0:	10c7883a 	add	r3,r2,r3
   4d0f4:	19400015 	stw	r5,0(r3)
   4d0f8:	0005883a 	mov	r2,zero
   4d0fc:	dfc00517 	ldw	ra,20(sp)
   4d100:	dc400417 	ldw	r17,16(sp)
   4d104:	dc000317 	ldw	r16,12(sp)
   4d108:	dec00604 	addi	sp,sp,24
   4d10c:	f800283a 	ret
   4d110:	00800034 	movhi	r2,0
   4d114:	10800004 	addi	r2,r2,0
   4d118:	10002626 	beq	r2,zero,4d1b4 <__register_exitproc+0x110>
   4d11c:	01006404 	movi	r4,400
   4d120:	d9400015 	stw	r5,0(sp)
   4d124:	d9800115 	stw	r6,4(sp)
   4d128:	d9c00215 	stw	r7,8(sp)
   4d12c:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   4d130:	d9400017 	ldw	r5,0(sp)
   4d134:	d9800117 	ldw	r6,4(sp)
   4d138:	d9c00217 	ldw	r7,8(sp)
   4d13c:	10001d26 	beq	r2,zero,4d1b4 <__register_exitproc+0x110>
   4d140:	81000017 	ldw	r4,0(r16)
   4d144:	10000115 	stw	zero,4(r2)
   4d148:	02000044 	movi	r8,1
   4d14c:	22405217 	ldw	r9,328(r4)
   4d150:	0007883a 	mov	r3,zero
   4d154:	12400015 	stw	r9,0(r2)
   4d158:	20805215 	stw	r2,328(r4)
   4d15c:	10006215 	stw	zero,392(r2)
   4d160:	10006315 	stw	zero,396(r2)
   4d164:	883fde26 	beq	r17,zero,4d0e0 <__alt_mem_epcs_flash+0xfffcc0e0>
   4d168:	18c9883a 	add	r4,r3,r3
   4d16c:	2109883a 	add	r4,r4,r4
   4d170:	1109883a 	add	r4,r2,r4
   4d174:	21802215 	stw	r6,136(r4)
   4d178:	01800044 	movi	r6,1
   4d17c:	12406217 	ldw	r9,392(r2)
   4d180:	30cc983a 	sll	r6,r6,r3
   4d184:	4992b03a 	or	r9,r9,r6
   4d188:	12406215 	stw	r9,392(r2)
   4d18c:	21c04215 	stw	r7,264(r4)
   4d190:	01000084 	movi	r4,2
   4d194:	893fd21e 	bne	r17,r4,4d0e0 <__alt_mem_epcs_flash+0xfffcc0e0>
   4d198:	11006317 	ldw	r4,396(r2)
   4d19c:	218cb03a 	or	r6,r4,r6
   4d1a0:	11806315 	stw	r6,396(r2)
   4d1a4:	003fce06 	br	4d0e0 <__alt_mem_epcs_flash+0xfffcc0e0>
   4d1a8:	18805304 	addi	r2,r3,332
   4d1ac:	18805215 	stw	r2,328(r3)
   4d1b0:	003fc606 	br	4d0cc <__alt_mem_epcs_flash+0xfffcc0cc>
   4d1b4:	00bfffc4 	movi	r2,-1
   4d1b8:	003fd006 	br	4d0fc <__alt_mem_epcs_flash+0xfffcc0fc>

0004d1bc <__call_exitprocs>:
   4d1bc:	defff504 	addi	sp,sp,-44
   4d1c0:	df000915 	stw	fp,36(sp)
   4d1c4:	dd400615 	stw	r21,24(sp)
   4d1c8:	dc800315 	stw	r18,12(sp)
   4d1cc:	dfc00a15 	stw	ra,40(sp)
   4d1d0:	ddc00815 	stw	r23,32(sp)
   4d1d4:	dd800715 	stw	r22,28(sp)
   4d1d8:	dd000515 	stw	r20,20(sp)
   4d1dc:	dcc00415 	stw	r19,16(sp)
   4d1e0:	dc400215 	stw	r17,8(sp)
   4d1e4:	dc000115 	stw	r16,4(sp)
   4d1e8:	d9000015 	stw	r4,0(sp)
   4d1ec:	2839883a 	mov	fp,r5
   4d1f0:	04800044 	movi	r18,1
   4d1f4:	057fffc4 	movi	r21,-1
   4d1f8:	008001b4 	movhi	r2,6
   4d1fc:	10b45104 	addi	r2,r2,-11964
   4d200:	12000017 	ldw	r8,0(r2)
   4d204:	45005217 	ldw	r20,328(r8)
   4d208:	44c05204 	addi	r19,r8,328
   4d20c:	a0001c26 	beq	r20,zero,4d280 <__call_exitprocs+0xc4>
   4d210:	a0800117 	ldw	r2,4(r20)
   4d214:	15ffffc4 	addi	r23,r2,-1
   4d218:	b8000d16 	blt	r23,zero,4d250 <__call_exitprocs+0x94>
   4d21c:	14000044 	addi	r16,r2,1
   4d220:	8421883a 	add	r16,r16,r16
   4d224:	8421883a 	add	r16,r16,r16
   4d228:	84402004 	addi	r17,r16,128
   4d22c:	a463883a 	add	r17,r20,r17
   4d230:	a421883a 	add	r16,r20,r16
   4d234:	e0001e26 	beq	fp,zero,4d2b0 <__call_exitprocs+0xf4>
   4d238:	80804017 	ldw	r2,256(r16)
   4d23c:	e0801c26 	beq	fp,r2,4d2b0 <__call_exitprocs+0xf4>
   4d240:	bdffffc4 	addi	r23,r23,-1
   4d244:	843fff04 	addi	r16,r16,-4
   4d248:	8c7fff04 	addi	r17,r17,-4
   4d24c:	bd7ff91e 	bne	r23,r21,4d234 <__alt_mem_epcs_flash+0xfffcc234>
   4d250:	00800034 	movhi	r2,0
   4d254:	10800004 	addi	r2,r2,0
   4d258:	10000926 	beq	r2,zero,4d280 <__call_exitprocs+0xc4>
   4d25c:	a0800117 	ldw	r2,4(r20)
   4d260:	1000301e 	bne	r2,zero,4d324 <__call_exitprocs+0x168>
   4d264:	a0800017 	ldw	r2,0(r20)
   4d268:	10003226 	beq	r2,zero,4d334 <__call_exitprocs+0x178>
   4d26c:	a009883a 	mov	r4,r20
   4d270:	98800015 	stw	r2,0(r19)
   4d274:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   4d278:	9d000017 	ldw	r20,0(r19)
   4d27c:	a03fe41e 	bne	r20,zero,4d210 <__alt_mem_epcs_flash+0xfffcc210>
   4d280:	dfc00a17 	ldw	ra,40(sp)
   4d284:	df000917 	ldw	fp,36(sp)
   4d288:	ddc00817 	ldw	r23,32(sp)
   4d28c:	dd800717 	ldw	r22,28(sp)
   4d290:	dd400617 	ldw	r21,24(sp)
   4d294:	dd000517 	ldw	r20,20(sp)
   4d298:	dcc00417 	ldw	r19,16(sp)
   4d29c:	dc800317 	ldw	r18,12(sp)
   4d2a0:	dc400217 	ldw	r17,8(sp)
   4d2a4:	dc000117 	ldw	r16,4(sp)
   4d2a8:	dec00b04 	addi	sp,sp,44
   4d2ac:	f800283a 	ret
   4d2b0:	a0800117 	ldw	r2,4(r20)
   4d2b4:	80c00017 	ldw	r3,0(r16)
   4d2b8:	10bfffc4 	addi	r2,r2,-1
   4d2bc:	15c01426 	beq	r2,r23,4d310 <__call_exitprocs+0x154>
   4d2c0:	80000015 	stw	zero,0(r16)
   4d2c4:	183fde26 	beq	r3,zero,4d240 <__alt_mem_epcs_flash+0xfffcc240>
   4d2c8:	95c8983a 	sll	r4,r18,r23
   4d2cc:	a0806217 	ldw	r2,392(r20)
   4d2d0:	a5800117 	ldw	r22,4(r20)
   4d2d4:	2084703a 	and	r2,r4,r2
   4d2d8:	10000b26 	beq	r2,zero,4d308 <__call_exitprocs+0x14c>
   4d2dc:	a0806317 	ldw	r2,396(r20)
   4d2e0:	2088703a 	and	r4,r4,r2
   4d2e4:	20000c1e 	bne	r4,zero,4d318 <__call_exitprocs+0x15c>
   4d2e8:	89400017 	ldw	r5,0(r17)
   4d2ec:	d9000017 	ldw	r4,0(sp)
   4d2f0:	183ee83a 	callr	r3
   4d2f4:	a0800117 	ldw	r2,4(r20)
   4d2f8:	15bfbf1e 	bne	r2,r22,4d1f8 <__alt_mem_epcs_flash+0xfffcc1f8>
   4d2fc:	98800017 	ldw	r2,0(r19)
   4d300:	153fcf26 	beq	r2,r20,4d240 <__alt_mem_epcs_flash+0xfffcc240>
   4d304:	003fbc06 	br	4d1f8 <__alt_mem_epcs_flash+0xfffcc1f8>
   4d308:	183ee83a 	callr	r3
   4d30c:	003ff906 	br	4d2f4 <__alt_mem_epcs_flash+0xfffcc2f4>
   4d310:	a5c00115 	stw	r23,4(r20)
   4d314:	003feb06 	br	4d2c4 <__alt_mem_epcs_flash+0xfffcc2c4>
   4d318:	89000017 	ldw	r4,0(r17)
   4d31c:	183ee83a 	callr	r3
   4d320:	003ff406 	br	4d2f4 <__alt_mem_epcs_flash+0xfffcc2f4>
   4d324:	a0800017 	ldw	r2,0(r20)
   4d328:	a027883a 	mov	r19,r20
   4d32c:	1029883a 	mov	r20,r2
   4d330:	003fb606 	br	4d20c <__alt_mem_epcs_flash+0xfffcc20c>
   4d334:	0005883a 	mov	r2,zero
   4d338:	003ffb06 	br	4d328 <__alt_mem_epcs_flash+0xfffcc328>

0004d33c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   4d33c:	defffd04 	addi	sp,sp,-12
   4d340:	df000215 	stw	fp,8(sp)
   4d344:	df000204 	addi	fp,sp,8
   4d348:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   4d34c:	0001883a 	nop
   4d350:	e0bfff17 	ldw	r2,-4(fp)
   4d354:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   4d358:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   4d35c:	10000226 	beq	r2,zero,4d368 <_exit+0x2c>
    ALT_SIM_FAIL();
   4d360:	002af070 	cmpltui	zero,zero,43969
   4d364:	00000106 	br	4d36c <_exit+0x30>
  } else {
    ALT_SIM_PASS();
   4d368:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   4d36c:	003fff06 	br	4d36c <__alt_mem_epcs_flash+0xfffcc36c>
